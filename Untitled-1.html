
﻿<!DOCTYPE html>
<html lang="ko" data-theme="dark">
  <head>
    
    <meta charset="utf-8" />
    <meta name="naver-site-verification" content="a9cf4fb600a690bf9221ab684ba809e651944719" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />
    <meta name="description" content="아이온2 캐릭터 검색, 전투력 랭킹, 통계, 티어 분석, 스펙 비교 등 아이온2 게임 정보를 한눈에 확인하세요." />
    <meta name="keywords" content="아이온2, AION2, 아이온2 검색, 아이온2 랭킹, 아이온2 통계, 아이온2 티어, 아이온2 스펙, 아이온2 캐릭터, 아이온2 전투력" />
    <meta name="author" content="아툴" />
    <meta name="theme-color" content="#68217A">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="아툴">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="robots" content="index, follow" />
    <meta name="googlebot" content="index, follow" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://aion2tool.com/char/serverid=2004/콕" />
    <meta property="og:title" content="아툴 - 아이온2 정보 검색·랭킹 사이트" />
    <meta property="og:description" content="아이온2 캐릭터 검색, 랭킹, 통계, 티어 분석, 스펙 비교 등 아이온2 게임 정보를 한눈에 확인하세요." />
    <meta property="og:image" content="https://aion2tool.com//images/A2TOOL_LOGO.png" />
    <meta property="og:locale" content="ko_KR" />
    <meta property="og:site_name" content="아툴" />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://aion2tool.com/char/serverid=2004/콕" />
    <meta name="twitter:title" content="아툴 - 아이온2 정보 검색·랭킹 사이트" />
    <meta name="twitter:description" content="아이온2 캐릭터 검색, 랭킹, 통계, 티어 분석, 스펙 비교 등 아이온2 게임 정보를 한눈에 확인하세요." />
    <meta name="twitter:image" content="https://aion2tool.com//images/A2TOOL_LOGO.png" />
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://aion2tool.com/char/serverid=2004/콕" />
    
    <title>아툴 - 아이온2 정보 검색·랭킹 사이트</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico?v=new_ico_fix">
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Do+Hyeon&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg-outer: #0d1117;
        --bg-inner: #0d1117;
        --card-bg: rgba(22, 27, 34, 0.95);
        --card-border: rgba(255, 255, 255, 0.15);
        --accent: #a78bfa;
        --accent-strong: #ec4899;
        --text-primary: #e6edf3;
        --text-muted: #7d8590;
        --text-bright: #ffffff;
        --purple-light: #c4b5fd;
        --purple-dark: #7c3aed;
        --pink-light: #f9a8d4;
        --blue-light: #60a5fa;
      }

      :root[data-theme="light"] {
        color-scheme: light;
        --bg-outer: #f5f7fa;
        --bg-inner: #f5f7fa;
        --card-bg: rgba(255, 255, 255, 0.95);
        --card-border: rgba(0, 0, 0, 0.1);
        --accent: #7c3aed;
        --accent-strong: #ec4899;
        --text-primary: #1a1a2e;
        --text-muted: #6b7280;
      }

      :root[data-theme="light"] .glow::before,
      :root[data-theme="light"] .glow::after {
        opacity: 0.1;
      }

      :root[data-theme="light"] .dashboard,
      :root[data-theme="light"] .data-card {
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
      }

      :root[data-theme="light"] .stat-chip {
        background: rgba(244, 244, 255, 0.5);
        border-color: rgba(0, 0, 0, 0.06);
      }

      :root[data-theme="light"] .data-card {
        background: rgba(255, 255, 255, 0.98);
        border-color: rgba(0, 0, 0, 0.12);
      }

      :root[data-theme="light"] .data-card strong {
        color: #1a1a2e;
      }

      :root[data-theme="light"] .data-card p {
        color: #4b5563;
      }

      :root[data-theme="light"] .badge {
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        border: 1px solid rgba(124, 58, 237, 0.2);
      }

      * {
        box-sizing: border-box;
      }

      html {
        overflow: visible;
        width: 100%;
        max-width: 100vw;
        position: relative;
        background: #0d1117;
      }

      /* 로딩 오버레이 기본 스타일 */
      #fullscreen-loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 99999;
        background-color: white;
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
      }

      /* 로딩 스피너 */
      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #333;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 1rem;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .loading-text {
        font-size: 1.5rem;
        color: #333;
      }

      /* 1400~2200px 화면에서 전체 스케일 비율적으로 축소 (좌우 광고 공간 확보) */
      @media (min-width: 1400px) and (max-width: 2200px) {
        html {
          /* zoom 속성으로 모든 요소를 87.5%로 축소 (모든 컨테이너, 폰트, 간격 자동 축소) */
          zoom: 0.875;
          /* zoom 적용 시 중앙 정렬을 위해 너비 조정 */
          width: 114.2857%; /* 100% / 0.875 = 114.2857% */
          margin-left: auto;
          margin-right: auto;
          transform-origin: center top;
        }
        
        body {
          width: 100%;
          margin: 0 auto;
        }
        
        /* 로딩 오버레이는 zoom의 영향을 받지 않도록 별도 처리 */
        #fullscreen-loading-overlay {
          zoom: 1.142857 !important; /* 1 / 0.875 = 1.142857 (원래 크기로 복원) */
          position: fixed !important;
          top: 0 !important;
          left: 0 !important;
          width: 100vw !important;
          height: 100vh !important;
          z-index: 99999 !important;
        }
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: #0d1117 !important;
        font-family: 'Pretendard', 'Noto Sans KR', sans-serif;
        color: var(--text-primary);
        overflow: visible;
        width: 100%;
        max-width: 100vw;
        position: relative;
        /* 모바일에서 확대 방지 */
        -webkit-text-size-adjust: 100%;
        -moz-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
        text-size-adjust: 100%;
        /* 모바일 터치 제스처 제어 */
        touch-action: pan-y;
      }

      .shell {
        max-width: 1600px;
        margin: 0 auto;
        padding: 2.5rem clamp(1rem, 4vw, 3rem) 4rem;
        position: relative;
        width: 100%;
        overflow-x: hidden;
        overflow-y: visible;
        flex: 1 1 auto;
        min-width: 0;
      }

      .site-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1.5rem 0;
        margin-bottom: 0;
        border-bottom: none;
        position: relative;
        overflow: visible;
      }

      .header-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        justify-content: flex-end;
        flex: 1;
        flex-wrap: wrap;
      }

      nav.header-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        justify-content: flex-end;
        flex: 1;
        flex-wrap: wrap;
      }

      .brand-block {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        text-decoration: none;
        cursor: pointer;
      }

      .header-actions .tabs {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        width: auto;
      }

      .brand-emblem {
        font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Noto Sans KR', sans-serif;
        font-size: clamp(1.35rem, 2.5vw, 1.6rem);
        letter-spacing: 0;
        color: rgb(240, 240, 240);
        line-height: 1.25;
        font-weight: 500;
      }

      .brand-emblem::after {
        display: none;
      }


      .site-title {
        margin: 0;
        font-size: clamp(1.5rem, 3vw, 2rem);
        font-weight: 700;
        background: linear-gradient(135deg, var(--accent), var(--accent-strong));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .site-logo {
        height: clamp(2rem, 4vw, 3rem);
        width: auto;
        cursor: pointer;
        transition: transform 0.2s ease, opacity 0.2s ease;
      }

      .site-logo:hover {
        transform: scale(1.05);
        opacity: 0.9;
      }

      main {
        position: relative;
        z-index: 1;
        width: 100%;
        max-width: 100vw;
        overflow-x: hidden;
        overflow-y: visible;
      }

      .glow {
        display: none;
      }

      footer {
        margin-top: 4rem;
        padding-top: 2rem;
        border-top: 1px solid var(--card-border);
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        align-items: center;
      }

      .footer-links {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 1rem 2rem;
      }

      .footer-link {
        display: inline-flex;
        align-items: center;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
        color: var(--text-muted);
        text-decoration: none;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .footer-link:hover {
        background: rgba(157, 140, 255, 0.15);
        border-color: rgba(157, 140, 255, 0.4);
        color: var(--accent);
        transform: translateY(-2px);
      }

      .footer-link-text {
        color: var(--text-muted);
        text-decoration: none;
        font-size: 0.9rem;
        transition: color 0.2s ease;
        cursor: pointer;
      }

      .footer-link-text:hover {
        color: var(--accent);
      }

      .footer-separator {
        color: var(--text-muted);
        opacity: 0.4;
        margin: 0 0.5rem;
      }

      /* 모달 스타일 */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 1rem;
        overflow-y: auto;
      }

      .modal-content {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 16px;
        max-width: 800px;
        width: 100%;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        /* box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5); */
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1.5rem 2rem;
        border-bottom: 1px solid var(--card-border);
      }

      .modal-header h2 {
        margin: 0;
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
      }

      .modal-close {
        background: none;
        border: none;
        color: var(--text-muted);
        font-size: 2rem;
        line-height: 1;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: all 0.2s ease;
      }

      .modal-close:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
      }

      .modal-body {
        padding: 2rem;
        overflow-y: auto;
        color: var(--text-primary);
        line-height: 1.8;
        font-size: 0.95rem;
      }

      .modal-body h3 {
        margin-top: 2rem;
        margin-bottom: 1rem;
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--accent);
      }

      .modal-body h3:first-child {
        margin-top: 0;
      }

      .modal-body p {
        margin: 0.75rem 0;
      }

      .modal-body ul {
        margin: 0.75rem 0;
        padding-left: 1.5rem;
      }

      .modal-body li {
        margin: 0.5rem 0;
      }

      .modal-body strong {
        color: var(--accent);
        font-weight: 600;
      }

      .footer-copyright {
        text-align: center;
        color: var(--text-muted);
        font-size: 0.85rem;
        line-height: 1.6;
      }

      .footer-copyright p {
        margin: 0.25rem 0;
      }

      @media (max-width: 1024px) {
        .shell {
          padding: 2rem clamp(1rem, 5vw, 2rem) 3rem;
        }

        .header-actions {
          width: 100%;
          justify-content: flex-start;
        }

        .header-actions .tabs {
          position: static;
          left: auto;
          transform: none;
          flex: 1 1 100%;
          min-width: 0;
          width: 100%;
        }
      }

      @media (max-width: 768px) {
        .shell {
          padding: 1.75rem 1.25rem 2.5rem;
        }

        .site-header {
          flex-direction: column;
          align-items: stretch;
          gap: 1rem;
          padding-top: 1rem;
        }

        .header-actions {
          flex-direction: column;
          align-items: stretch;
          gap: 0.75rem;
        }

        .header-actions .tabs {
          position: static;
          left: auto;
          transform: none;
          width: 100%;
          overflow-x: auto;
          overflow-y: visible;
          padding: 0.5rem 0 0.25rem 0;
        }

        .tab-controls {
          justify-content: center !important;
        }

        .tab-controls label,
        .tab-controls .tab-link {
          transform: none !important;
        }

        #tab-character:checked ~ .site-header .tab-controls label[for="tab-character"],
        #tab-ranking:checked ~ .site-header .tab-controls label[for="tab-ranking"],
        #tab-statistics:checked ~ .site-header .tab-controls label[for="tab-statistics"] {
          transform: none !important;
        }

        .header-actions .tabs::-webkit-scrollbar,
        .tab-controls::-webkit-scrollbar {
          display: none;
        }

        .settings-menu {
          position: static;
          align-self: flex-end;
        }

        .footer-links {
          flex-direction: column;
          gap: 0.75rem;
        }

        .footer-separator {
          display: none;
        }

        .footer-link {
          width: 100%;
          justify-content: center;
        }

        .footer-copyright {
          font-size: 0.8rem;
        }
      }

      @media (max-width: 600px) {
        .shell {
          padding: 1.5rem 1rem 2.25rem;
        }

        .brand-block {
          width: auto;
          justify-content: flex-start;
          gap: 0.5rem;
          flex-wrap: nowrap;
        }

        .brand-emblem {
          font-size: clamp(1.05rem, 6vw, 1.3rem);
          letter-spacing: 0;
          white-space: nowrap;
          font-weight: 700;
        }

        .brand-emblem::after {
          display: none;
        }

        .header-actions {
          gap: 0.5rem;
        }

        .settings-menu {
          align-self: stretch;
        }
      }

      /* [공통] 모바일 탭 스타일 통일 (base.html style 맨 아래에 추가) */
      @media (max-width: 768px) {
        /* 탭 컨트롤 컨테이너 */
        .tab-controls {
          display: flex !important;
          flex-wrap: wrap !important;
          justify-content: center !important;
          gap: 0.4rem !important; /* 간격 통일 */
          margin-bottom: 0 !important;
        }

        /* 탭 버튼 (label과 a태그 모두 적용) */
        .tab-controls label,
        .tab-controls .tab-link {
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          
          /* 크기 및 여백 강제 통일 */
          padding: 0.5rem 0.9rem !important; 
          min-height: 40px !important;
          height: auto !important;
          
          /* 폰트 크기 통일 */
          font-size: 0.85rem !important; /* 혹은 clamp(0.8rem, 2vw, 0.9rem) */
          font-weight: 500 !important;
          
          border-radius: 12px !important;
          box-sizing: border-box !important;
          margin: 0 !important;
          transform: none !important; /* 탭 활성화 시 튀어오름 방지 통일 */
        }

        /* 탭 제목 텍스트 */
        .tab-controls span.title {
          font-size: 0.85rem !important;
          display: block !important;
        }

        /* 탭 설명(meta) 숨김 강제 */
        .tab-controls span.meta {
          display: none !important;
        }
        
        /* 헤더 영역 내의 탭 위치 조정 */
        .header-actions .tabs {
           padding: 0.5rem 0 !important;
           overflow-x: visible !important; /* 가로 스크롤 제거하고 줄바꿈 */
        }
      }

      /* 사이드 광고 영역 스타일 */
      .page-container {
        display: grid;
        grid-template-columns: 180px 1fr 180px;
        gap: 1rem;
        max-width: 2000px;
        margin: 0 auto;
        width: 100%;
        position: relative;
      }

      .side-ad {
        position: fixed;
        top: 150px;
        width: 160px;
        min-width: 160px;
        /* max-height 삭제 (광고가 화면보다 길어도 스크롤바 안 생기게) */
        min-height: 600px;
        overflow: visible; /* 중요: 스크롤바 생성 방지 */
        will-change: transform;
        z-index: 10;
      }

      .side-ad-left {
        left: 1rem;
      }

      .side-ad-right {
        right: 1rem;
      }

      /* 1400px 이상에서 광고 표시 및 위치 조정 */
      @media (min-width: 1400px) {
        .side-ad-left {
          left: max(1rem, calc((100vw - 1200px) / 2 - 250px));
        }
        
        .side-ad-right {
          right: max(1rem, calc((100vw - 1200px) / 2 - 250px));
        }
      }

      /* 2200px 이상 (QHD 등)에서 광고 위치 조정 */
      @media (min-width: 2200px) {
        .side-ad-left {
          left: calc((100vw - 1920px) / 2 - 100px);
        }
        
        .side-ad-right {
          right: calc((100vw - 1920px) / 2 - 100px);
        }
      }

      /* 중간 사이즈 화면에서는 광고 숨김 - 1400px 미만에서만 숨김 */
      @media (max-width: 1399px) {
        .side-ad {
          display: none;
        }
        
        .page-container {
          grid-template-columns: 1fr;
          justify-items: center;
        }
      }
    </style>
    
<style>
  /* ===== UI 전면 개편: 가시성 & 색감 개선 ===== */
  
  /* 배경 - 더 밝고 깔끔한 다크 */
  html, body {
    background: #0d1117 !important;
  }
  
  * {
    background-image: none !important;
  }
  
  /* box-shadow 제거 규칙 완화 - 필요한 곳에 적용 */
  .hero-card,
  .tab-button,
  .ranking-filter-btn,
  .search-button,
  input,
  select {
    box-shadow: initial !important;
  }
  
  /* 슬라이더 트랙과 직업 통계 바는 배경 이미지 허용 */
  .dual-range-track,
  .statistics-gauge-bg > div,
  .statistics-gauge-bar,
  .skill-stats-bar-segment,
  .exceed-level-badge {
    background-image: initial !important;
  }
  
  /* 슬라이더 트랙 기본 배경 */
  .dual-range-track {
    background: rgba(255, 255, 255, 0.15) !important;
  }
  
  /* 직업 통계 바 배경 */
  .statistics-gauge-bg {
    background: rgba(255, 255, 255, 0.1) !important;
  }
  
  .statistics-gauge-bar {
    background: linear-gradient(90deg, rgba(157, 140, 255, 0.8), rgba(236, 72, 153, 0.8)) !important;
    background-image: linear-gradient(90deg, rgba(157, 140, 255, 0.8), rgba(236, 72, 153, 0.8)) !important;
  }
  
  /* 큐나 시세는 마우스 오버 시에만 box-shadow 허용 */
  /*
  a[href="/quna-chart"] .hero-card {
    box-shadow: none !important;
    transition: transform 0.2s ease, box-shadow 0.2s ease !important;
  }
  
  a[href="/quna-chart"] .hero-card:hover {
    box-shadow: 0 10px 30px rgba(157, 140, 255, 0.2) !important;
    transform: translateY(-2px) !important;
  }
  */
  
  /* ===== 텍스트 크기 및 간격 개선 ===== */
  html {
    font-size: 16px !important; /* 프로덕션과 로컬 동일한 크기 보장 */
  }
  
  body {
    font-size: 16px !important; /* 고정 크기로 변경 */
    line-height: 1.6;
    color: var(--text-primary);
  }
  
  
  /* 1400~2200px 화면에서 전체 스케일 비율적으로 축소 (좌우 광고 공간 확보) */
  @media (min-width: 1400px) and (max-width: 2200px) {
    html {
      /* zoom 속성으로 모든 요소를 87.5%로 축소 (모든 컨테이너, 폰트, 간격 자동 축소) */
      zoom: 0.875;
      /* zoom 적용 시 중앙 정렬을 위해 너비 조정 */
      width: 114.2857%; /* 100% / 0.875 = 114.2857% */
      margin-left: auto;
      margin-right: auto;
      transform-origin: center top;
    }
    
    body {
      width: 100%;
      margin: 0 auto;
    }
    
    /* 로딩 오버레이는 zoom의 영향을 받지 않도록 별도 처리 */
    #fullscreen-loading-overlay {
      zoom: 1.142857 !important; /* 1 / 0.875 = 1.142857 (원래 크기로 복원) */
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
    }
    
    /* 즐겨찾기 컨테이너 높이 줄이기 */
    #favorites-container {
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 0.5rem !important;
    }
    
    #favorites-container .hero-card {
      padding: 0.5rem !important;
      min-height: auto !important;
    }
    
    #favorites-container .hero-card > div {
      padding: 0.25rem !important;
    }
    
    /* 즐겨찾기 캐릭터 이미지 크기 축소 */
    #favorites-container img,
    #favorites-container .character-image {
      width: 60px !important;
      height: 60px !important;
      min-width: 60px !important;
      min-height: 60px !important;
    }
    
    /* 즐겨찾기 텍스트 크기 축소 및 넘침 방지 */
    #favorites-container .character-name,
    #favorites-container .character-info,
    #favorites-container > div > div > div:not(:first-child),
    #favorites-container > div > div > div > div {
      font-size: 0.75rem !important;
      line-height: 1.2 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      max-width: 100% !important;
    }
    
    /* 즐겨찾기 컨테이너 내부 요소 넘침 방지 */
    #favorites-container > div {
      overflow: hidden !important;
      min-width: 0 !important;
    }
    
    #favorites-container .hero-card {
      overflow: hidden !important;
      min-width: 0 !important;
    }
    
    /* 즐겨찾기 카드 내부 flex 컨테이너 넘침 방지 */
    #favorites-container > div > div {
      overflow: hidden !important;
      min-width: 0 !important;
    }
    
    #favorites-container > div > div > div[style*="flex: 1"] {
      overflow: hidden !important;
      min-width: 0 !important;
    }
    
    /* 전투력 TOP 5 컨테이너 동일하게 축소 보장 */
    #power-top5-wrapper {
      display: grid !important;
      grid-template-columns: 1fr 1fr !important;
      gap: 1rem !important;
      width: 100% !important;
      box-sizing: border-box !important;
      overflow: visible !important;
      
      height: auto !important; /* 추가 */
      min-height: 0 !important; /* 추가 */
    }

    /* 전투력 TOP 5를 감싸는 hero-card overflow 제거 */
    .sidebar-left .hero-card,
    .sidebar-right .hero-card,
    .sidebar-banner .hero-card { /* sidebar-banner 선택자도 확실하게 추가 */
      overflow: visible !important;
      max-height: none !important;
      min-height: auto !important;
      height: auto !important; /* 핵심: 고정된 높이를 해제하고 내용물에 맞춤 */
      padding-bottom: 2.5rem !important; /* 하단 여백 안전하게 확보 */
    }
    
    /* 전투력 TOP 5 hero-card 내부 div도 overflow 제거 */
    .sidebar-left .hero-card > div,
    .sidebar-right .hero-card > div {
      overflow: visible !important;
      max-height: none !important;
    }
    
    .power-top5-section {
      overflow: visible !important;
      max-height: none !important;
      min-height: auto !important;
    }
    
    #power-top5-elyos,
    #power-top5-asmodian {
      gap: 0.2rem !important;
      width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box !important;
      overflow: visible !important;
      max-height: none !important;
    }
    
    #power-top5-elyos > div,
    #power-top5-asmodian > div {
      min-height: auto !important;
      height: auto !important;
      padding: 0.5rem !important;
      align-items: start !important;
      flex-shrink: 1 !important;
      flex-grow: 0 !important;
      width: 100% !important;
      box-sizing: border-box !important;
      overflow: visible !important;
      margin-bottom: 0 !important;
    }
    
    /* 마지막 항목도 잘 보이도록 */
    #power-top5-elyos > div:last-child,
    #power-top5-asmodian > div:last-child {
      margin-bottom: 0 !important;
      padding-bottom: 0.5rem !important;
    }
    
    #power-top5-elyos > div > span:nth-child(2),
    #power-top5-asmodian > div > span:nth-child(2) {
      white-space: normal !important;
      word-break: break-word !important;
      line-height: 1.7 !important;
      overflow: visible !important;
    }
    
    /* 전투력 TOP 5 항목들이 동일한 높이를 가지지 않도록 */
    #power-top5-elyos > div,
    #power-top5-asmodian > div {
      flex-shrink: 1 !important;
      flex-grow: 0 !important;
    }
  }
  
  h1, h2, h3, h4, h5, h6 {
    color: var(--text-bright);
    font-weight: 700;
    line-height: 1.3;
    margin-bottom: 1rem;
  }
  
  p {
    margin-bottom: 1rem;
    color: var(--text-primary);
  }
  
  /* ===== Badge 스타일 개선 ===== */
  .badge {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--purple-light);
    background: rgba(167, 139, 250, 0.15);
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    border: 1px solid rgba(167, 139, 250, 0.3);
    display: inline-block;
    margin-bottom: 1.2rem;
  }
  
  .main-layout,
  .shell,
  #panel-ranking,
  #panel-statistics,
  .main-content,
  .sidebar-left,
  .sidebar-right {
    background: #0d1117 !important;
    background-image: none !important;
  }

  /* 메인 레이아웃: 좌우 배너 + 중앙 콘텐츠 */
  .main-layout {
    display: grid;
    grid-template-columns: 400px 1fr 400px;
    gap: 1.5rem;
    align-items: start;
    margin-bottom: 2rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    padding-top: 1.5rem;
  }

  /* 좌우 배너 */
  .sidebar-banner {
    position: sticky;
    top: 2rem;
    height: fit-content;
  }
  
  /* 좌중우 섹션 시작 높이 맞추기 - 모든 첫 요소가 line에 딱 붙도록 */
  .sidebar-left > :first-child,
  .main-content > :first-child:not([style*="display: none"]),
  .sidebar-right > :first-child {
    margin-top: 0 !important;
    padding-top: 0 !important;
  }

  .sidebar-banner .hero-card {
    position: relative;
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  .sidebar-banner .hero-card > div {
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  .sidebar-banner .hero-card > div > div {
    flex: 1;
  }

  /* 중앙 메인 콘텐츠 */
  .main-content {
    min-width: 0; /* grid 오버플로우 방지 */
  }

  /* 각 섹션의 첫 번째 badge 높이 맞추기 */
  .sidebar-left,
  .main-content,
  .sidebar-right {
    padding-top: 0 !important;
  }
  
  .sidebar-left > .badge:first-child,
  .main-content > *:first-child > .badge:first-child,
  .main-content > .badge:first-child,
  .main-content > #streamer-title:first-of-type,
  .sidebar-right > .badge:first-child {
    margin-top: 0 !important;
    padding-top: 0 !important;
    position: relative;
    top: 0 !important;
  }
  
  /* 데스크톱에서 모든 section 간격 통일 */
  .badge {
    margin-bottom: 0.75rem !important;
    margin-top: 1.5rem !important;
  }
  
  /* 첫 번째 badge는 margin-top 0 */
  .sidebar-left > .badge:first-child,
  .main-content > .badge:first-child,
  .sidebar-right > .badge:first-child {
    margin-top: 0 !important;
  }
  
  /* 모든 hero-card 하단 간격 통일 */
  .hero-card {
    margin-bottom: 1.5rem !important;
  }
  
  /* 마지막 hero-card는 margin-bottom 줄이기 */
  .sidebar-left > .hero-card:last-child,
  .sidebar-right > .hero-card:last-child {
    margin-bottom: 0 !important;
  }
  
  /* section 전체 하단 간격 통일 */
  #character-search-wrapper {
    margin-bottom: 1.5rem !important;
  }
  
  #favorites-section {
    margin-bottom: 1.5rem !important;
  }
  
  #streamer-section {
    margin-bottom: 1.5rem !important;
  }
  
  /* 서버 정보 섹션의 제목과 내용 사이 간격만 줄이기 */
  .sidebar-right > div[style*="margin-bottom: 0.75rem"]:has(.badge) {
    margin-bottom: 0rem !important;
  }

  /* 탭 상태에 따른 레이아웃 제어 (CSS로 처리) */
  /* 랭킹 또는 통계 탭이 선택되었을 때 사이드바 숨김 */
  #tab-ranking:checked ~ * .main-layout .sidebar-left,
  #tab-ranking:checked ~ * .main-layout .sidebar-right,
  #tab-statistics:checked ~ * .main-layout .sidebar-left,
  #tab-statistics:checked ~ * .main-layout .sidebar-right {
    display: none;
  }

  /* 랭킹 또는 통계 탭이 선택되었을 때 홈화면 전용 요소 숨김 */
  #tab-ranking:checked ~ * #streamer-section,
  #tab-ranking:checked ~ * #streamer-title,
  #tab-statistics:checked ~ * #streamer-section,
  #tab-statistics:checked ~ * #streamer-title,
  #tab-ranking:checked ~ * #favorites-section,
  #tab-ranking:checked ~ * #favorites-title,
  #tab-statistics:checked ~ * #favorites-section,
  #tab-statistics:checked ~ * #favorites-title,
  #tab-ranking:checked ~ * #character-all-servers-result,
  #tab-statistics:checked ~ * #character-all-servers-result {
    display: none !important;
  }

  /* 모바일에서도 동일하게 적용 */
  @media (max-width: 768px) {
    #tab-ranking:checked ~ * #streamer-section,
    #tab-ranking:checked ~ * #streamer-title,
    #tab-statistics:checked ~ * #streamer-section,
    #tab-statistics:checked ~ * #streamer-title,
    #tab-ranking:checked ~ * #favorites-section,
    #tab-ranking:checked ~ * #favorites-title,
    #tab-statistics:checked ~ * #favorites-section,
    #tab-statistics:checked ~ * #favorites-title,
    #tab-ranking:checked ~ * #character-all-servers-result,
    #tab-statistics:checked ~ * #character-all-servers-result {
      display: none !important;
    }

    /* 캐릭터 검색 결과 표시 시 스트리머 섹션 숨김 (모바일) */
    .main-layout.show-character-result #streamer-section,
    .main-layout.show-character-result #streamer-title {
      display: none !important;
    }
    
    /* 캐릭터 검색 결과 화면에서 즐겨찾기 섹션은 표시 (모바일) */
    .main-layout.show-character-result #favorites-container {
      grid-template-columns: repeat(2, 1fr) !important;
    }
  }

  /* 랭킹 또는 통계 탭이 선택되었을 때 중앙 정렬 및 너비 제한 */
  #tab-ranking:checked ~ * .main-layout,
  #tab-statistics:checked ~ * .main-layout {
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    max-width: 1200px !important;
    margin-left: auto !important;
    margin-right: auto !important;
    width: 100% !important;
  }

  #tab-ranking:checked ~ * .main-layout .main-content,
  #tab-statistics:checked ~ * .main-layout .main-content {
    width: 100%;
  }

  /* 전투력 랭킹 탭과 통계 탭의 내용을 중앙 정렬 */
  #panel-ranking,
  #panel-statistics {
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    overflow-y: visible;
    box-sizing: border-box;
    position: relative;
  }

  #panel-ranking .card-grid {
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
  }
  
  #panel-statistics .card-grid {
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    overflow-y: visible;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
  }
  
  #panel-ranking .hero-card {
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    box-sizing: border-box;
  }
  
  #panel-statistics .hero-card {
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    overflow-y: visible;
    box-sizing: border-box;
  }
  
  #panel-statistics .hero-card > div {
    overflow-y: visible;
    min-height: auto;
    height: auto;
  }
  
  /* 아이템 통계 컨텐츠가 잘리지 않도록 보장 */
  #item-statistics-content {
    overflow: visible !important;
    min-height: auto !important;
    height: auto !important;
    max-height: none !important;
  }
  
  /* 통계 서브탭 버튼이 잘리지 않도록 */
  .statistics-sub-tabs {
    overflow: visible !important;
    flex-wrap: wrap;
  }
  
  /* 아이템 통계 컨테이너도 잘리지 않도록 */
  #item-statistics-container {
    overflow: visible !important;
    min-height: auto !important;
    height: auto !important;
    max-height: none !important;
  }

  /* 반응형: 작은 화면에서는 세로 배치 */
  @media (max-width: 1400px) {
    .main-layout {
      grid-template-columns: 220px 1fr 220px;
      gap: 1rem;
    }
    
    /* 중앙 콘텐츠 너비 제한으로 좌우 콘텐츠가 잘리지 않도록 */
    .main-content {
      max-width: 100%;
      min-width: 0;
      overflow-x: hidden;
    }
    
    /* 캐릭터 검색 폼과 스트리머 섹션 너비 제한 */
    #character-search-wrapper,
    #streamer-section,
    #favorites-section {
      max-width: 100%;
      overflow-x: hidden;
    }
  }
  
  /* 1200~1400px 범위에서 더 타이트하게 */
  @media (min-width: 1201px) and (max-width: 1400px) {
    .main-layout {
      grid-template-columns: 360px minmax(0, 1fr) 360px;
      gap: 0;
      column-gap: 0;
      row-gap: 0;
    }
    
    .main-content {
      max-width: calc(100vw - 720px);
      min-width: 0;
      overflow-x: hidden;
      margin: 0;
      padding: 0;
      width: 100%;
    }
    
    .sidebar-left {
      padding: 0;
      margin: 0;
      width: 360px;
      max-width: 360px;
      min-width: 360px;
    }
    
    .sidebar-right {
      padding: 0;
      margin: 0;
      width: 360px;
      max-width: 360px;
      min-width: 360px;
    }
    
    /* 좌우 사이드바 너비 확대 및 오버플로우 제거 */
    .sidebar-banner {
      min-width: 360px;
      max-width: 360px;
      width: 360px;
      overflow: visible;
      margin: 0;
      padding: 0;
    }
    
    /* 사이드바 내부 hero-card의 margin 제거 */
    .sidebar-banner .hero-card {
      margin-left: 0 !important;
      margin-right: 0 !important;
    }
    
    /* 중앙 콘텐츠의 margin 제거 */
    .main-content {
      margin-left: 0 !important;
      margin-right: 0 !important;
      padding-left: 1rem !important;
      padding-right: 1rem !important;
    }
    
    /* 중앙 콘텐츠 내부 요소들 너비 제한 - 절반으로 */
    #character-search-wrapper {
      max-width: 100%;
      width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    .character-search-form {
      max-width: 100%;
      width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    .search-container {
      max-width: 100%;
      width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    #streamer-section {
      max-width: 100%;
      width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    #streamer-race-wrapper {
      max-width: 100%;
      width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
      grid-template-columns: 1fr 1fr !important;
      gap: 0.75rem !important;
    }
    
    /* 스트리머 카드 너비 제한 */
    #streamer-section .hero-card {
      max-width: 100%;
      width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    /* 스트리머 개별 카드도 너비 제한 */
    .streamer-race-column {
      max-width: 100%;
      overflow-x: hidden;
      box-sizing: border-box;
    }
    
    /* 스트리머 컨테이너 1컬럼 레이아웃 (1200~1400px만) */
    .streamer-container {
      grid-template-columns: 1fr !important;
    }
    
    /* 전투력 TOP 5 레이아웃 변경 - 2컬럼 (순위 | 닉네임/전투력) */
    #power-top5-elyos > div,
    #power-top5-asmodian > div {
      display: grid !important;
      grid-template-columns: 30px 1fr !important;
      gap: 0.5rem !important;
      align-items: start !important;
      padding: 0.5rem !important;
      background: rgba(255, 255, 255, 0.03) !important;
      border-radius: 8px !important;
    }
    
    #power-top5-elyos > div > span:first-child,
    #power-top5-asmodian > div > span:first-child {
      grid-column: 1 !important;
      grid-row: 1 / 3 !important;
      align-self: center !important;
      margin: 0 !important;
    }
    
    #power-top5-elyos > div > span:nth-child(2),
    #power-top5-asmodian > div > span:nth-child(2) {
      grid-column: 2 !important;
      grid-row: 1 !important;
      flex: none !important;
      margin: 0 !important;
    }
    
    #power-top5-elyos > div > span:last-child,
    #power-top5-asmodian > div > span:last-child {
      grid-column: 2 !important;
      grid-row: 2 !important;
      text-align: left !important;
      min-width: auto !important;
      margin: 0 !important;
    }
  }

  @media (max-width: 1200px) {
    .main-layout {
      grid-template-columns: 1fr;
      gap: 1rem;
    }
    
    /* 모바일/태블릿에서는 사이드바 순서 조정 */
    .sidebar-banner {
      position: static;
      order: 1;
    }
    
    .sidebar-left {
      order: 1;
    }
    
    .main-content {
      order: 2;
    }
    
    /* 우측 사이드바도 아래가 아닌 위나 중간에 배치하고 싶다면 조정 가능 */
    /* 현재는 모바일에서 1열 배치 시 순서대로 나옴 */
    .sidebar-right {
      order: 3;
    }

    .sidebar-banner .hero-card {
      height: auto !important;
    }
  }
  
  /* 모바일 최적화: 캐릭터 검색 결과 화면 전면 개편 */
  @media (max-width: 768px) {
    /* === 전체 캐릭터 검색 결과 영역 너비 제한 === */
    #character-result {
      max-width: 100vw !important;
      overflow-x: hidden !important;
      box-sizing: border-box !important;
    }
    
    #character-result * {
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    #character-result .hero-card {
      max-width: 100% !important;
      width: 100% !important;
    }
    
    /* === 모바일 캐릭터 정보 압축 === */
    /* 캐릭터 결과 카드 padding 줄이기 */
    #character-result .hero-card {
      padding: 0.75rem !important;
      margin-bottom: 0.75rem !important;
      position: relative !important;
    }
    
    /* === 캐릭터 기본 정보 영역 === */
    /* 캐릭터 이미지와 기본 정보 세로 배치 */
    #character-result .hero-card > div:first-child {
      flex-direction: column !important;
      gap: 0.5rem !important;
      align-items: center !important;
      max-width: 100% !important;
    }
    
    /* 캐릭터 이미지 중앙 정렬 및 크기 축소 */
    #result-avatar-container {
      width: 80px !important;
      min-width: 0 !important;
      max-width: 80px !important;
      display: flex !important;
      justify-content: center !important;
      margin-bottom: 0.5rem !important;
    }
    
    #result-avatar {
      width: 80px !important;
      height: 133px !important;
      max-width: 80px !important;
    }
    
    /* 닉네임과 기본 정보 중앙 정렬 */
    #character-result .hero-card > div:first-child > div:nth-child(2) {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    #character-result .hero-card > div:first-child > div:nth-child(2) > div:first-child {
      justify-content: center !important;
      margin-bottom: 0.25rem !important;
    }
    
    #result-nickname {
      font-size: 1.1rem !important;
      text-align: center !important;
      margin: 0 !important;
    }
    
    #favorite-star-btn {
      font-size: 1.2rem !important;
    }
    
    /* 업데이트 시간 및 갱신 버튼 중앙 정렬 */
    #character-update-info {
      justify-content: center !important;
      flex-wrap: wrap !important;
      width: 100% !important;
      max-width: 100% !important;
      margin-bottom: 0.25rem !important;
      gap: 0.4rem !important;
    }
    
    #character-update-time {
      font-size: 0.7rem !important;
    }
    
    #character-refresh-btn {
      padding: 0.2rem 0.5rem !important;
      font-size: 0.75rem !important;
    }
    
    #character-refresh-cooldown {
      font-size: 0.65rem !important;
    }
    
    /* 펫/날개 배지 중앙 정렬 */
    #companion-badges {
      justify-content: center !important;
      width: 100% !important;
      max-width: 100% !important;
      margin-bottom: 0.25rem !important;
      gap: 0.4rem !important;
    }
    
    .companion-badge {
      padding: 0.3rem 0.5rem !important;
    }
    
    .companion-badge img {
      width: 18px !important;
      height: 18px !important;
    }
    
    .companion-badge-name {
      font-size: 0.7rem !important;
    }
    
    /* 종족/서버/직업/레기온/전투력 그리드 압축 */
    #character-result .hero-stats {
      gap: 0.25rem !important;
      margin-bottom: 0.25rem !important;
      width: 100% !important;
      max-width: 100% !important;
      display: grid !important;
    }
    
    /* 첫 번째 hero-stats (종족/서버/직업) - 3열 강제 */
    #character-result .hero-stats-first,
    #character-result .hero-stats.hero-stats-first {
      grid-template-columns: repeat(3, 1fr) !important;
    }
    
    /* 두 번째 hero-stats (레기온/전투력) - 2열 강제 */
    #character-result .hero-stats-second,
    #character-result .hero-stats.hero-stats-second {
      grid-template-columns: repeat(2, 1fr) !important;
    }
    
    .stat-chip {
      padding: 0.3rem 0.25rem !important;
      text-align: center !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    .stat-chip .label {
      font-size: 0.6rem !important;
      margin-bottom: 0.1rem !important;
    }
    
    .stat-chip .value {
      font-size: 0.75rem !important;
      justify-content: center !important;
    }
    
    .stat-chip img {
      width: 18px !important;
      height: 18px !important;
    }
    
    /* 레기온 랭크 정보 */
    #result-guild-rank {
      font-size: 0.55rem !important;
      margin-top: 0.15rem !important;
    }
    
    /* 레기온 검색 링크 - 데스크톱용 숨김, 모바일용 표시 */
    .region-search-desktop {
      display: none !important;
    }
    
    .region-search-mobile {
      display: block !important;
    }
    
    #region-search-link-mobile {
      font-size: 0.65rem !important;
    }
    
    /* 우측 액션 영역 - 우측 위에 고정 */
    #character-result .hero-card > div:first-child > div:nth-child(3) {
      position: absolute !important;
      top: 0.5rem !important;
      right: 0.5rem !important;
      width: auto !important;
      max-width: none !important;
      align-items: flex-end !important;
      gap: 0.5rem !important;
    }
    
    /* 내 캐릭터랑 비교 버튼 */
    #compare-with-mine-button {
      padding: 0.3rem 0.6rem !important;
      font-size: 0.7rem !important;
      white-space: nowrap !important;
    }
    
    /* === 아툴 전투 점수 영역 === */
    .dps-stats-info {
      padding: 0.75rem !important;
      margin-top: 0.5rem !important;
      margin-bottom: 0.5rem !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      box-sizing: border-box !important;
    }
    
    .dps-stats-info > div:first-child {
      margin-bottom: 0.75rem !important;
      padding-bottom: 0.75rem !important;
    }
    
    .dps-stats-info > div:first-child > div:first-child {
      font-size: 0.75rem !important;
      margin-bottom: 0.25rem !important;
    }
    
    #dps-score-value {
      font-size: 1.75rem !important;
      margin-bottom: 0.25rem !important;
      line-height: 1 !important;
    }
    
    #combat-score-power-range-info {
      font-size: 0.7rem !important;
      margin-bottom: 0.5rem !important;
    }
    
    /* 전투 점수 랭킹 정보 3열 유지하되 크기 축소 */
    #combat-score-rankings-info {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      padding: 0.5rem !important;
    }
    
    #combat-score-rankings-info > div {
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 0.4rem !important;
      text-align: center !important;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    #combat-score-rankings-info > div > div > div:first-child {
      font-size: 0.65rem !important;
      margin-bottom: 0.15rem !important;
    }
    
    #combat-score-rankings-info > div > div > div:last-child {
      font-size: 0.75rem !important;
    }
    
    /* 딜 스탯 카드들 2열로 변경 (더 압축) */
    .dps-stats-info .ranking-stats {
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 0.4rem !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    .dps-stats-info .ranking-stat-item {
      padding: 0.5rem !important;
      min-height: auto !important;
      text-align: center !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
    }
    
    .dps-stats-info .ranking-stat-item > div:first-child {
      width: 100% !important;
      max-width: 100% !important;
      justify-content: center !important;
      font-size: 0.65rem !important;
      margin-bottom: 0.25rem !important;
      text-align: center !important;
    }
    
    .dps-stats-info .ranking-stat-item > div:nth-child(2) {
      font-size: 0.95rem !important;
      width: 100% !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
      text-align: center !important;
    }
    
    /* 노란색 숫자 값들 폰트 통일 */
    .dps-stats-info .ranking-stat-item > div:nth-child(2) > div:first-child {
      font-size: 1.1rem !important;
      font-weight: 700 !important;
      color: #fbbf24 !important;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
      letter-spacing: -0.02em !important;
    }
  }
  
  /* 전투 스탯 값 통일 스타일 */
  .combat-stat-value {
    font-size: 1.3rem;
    font-weight: 700;
    color: #fbbf24;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    letter-spacing: -0.02em;
  }
  
  /* 모바일에서 전투 스탯 값 크기 조정 */
  @media (max-width: 768px) {
    .combat-stat-value {
      font-size: 1.1rem !important;
    }
    
    /* 경고 메시지 박스 압축 */
    #dps-stats-info > div:last-child {
      margin-top: 0.5rem !important;
      padding: 0.5rem 0.75rem !important;
      font-size: 0.65rem !important;
      line-height: 1.3 !important;
    }
    
    #dps-stats-info > div:last-child > div:first-child {
      margin-bottom: 0.5rem !important;
    }
    
    #dps-stats-info > div:last-child > div:last-child {
      padding-top: 0.5rem !important;
    }
    
    /* 캐릭터 검색 광고 스타일 */
    #character-search-ad {
      width: 100% !important;
      max-width: 728px !important;
      margin-left: auto !important;
      margin-right: auto !important;
    }
    
    #character-search-ad ins.adsbygoogle {
      display: block !important;
      width: 100% !important;
      max-width: 728px !important;
      height: 90px !important;
    }
    
    /* 모바일에서 광고 크기 조정 */
    @media (max-width: 768px) {
      #character-search-ad {
        max-width: 100% !important;
        padding: 0 0 !important;
      }
      
      #character-search-ad ins.adsbygoogle {
        max-width: 100% !important;
        height: auto !important;
        min-height: 50px !important;
      }
    }
    
    /* === 캐릭터 정보 탭 === */
    .character-info-tabs {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    .character-tab-controls {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: auto !important;
      flex-wrap: nowrap !important;
    }
    
    /* 탭 버튼 크기 조정 */
    .character-tab-btn {
      font-size: 0.9rem !important;
      padding: 0.6rem 0.8rem !important;
      flex: 1 1 auto !important;
      min-width: 0 !important;
      white-space: nowrap !important;
    }
    
    .character-tab-card {
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    /* 컨텐츠 랭킹 카드 2열로 변경 (2개씩 5줄) - 최우선 적용 */
    #panel-basic-info .content-rankings-grid,
    .character-tab-panel .content-rankings-grid,
    .content-rankings .content-rankings-grid {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.4rem !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    #panel-basic-info .content-rankings-grid > div,
    .character-tab-panel .content-rankings-grid > div,
    .content-rankings .content-rankings-grid > div {
      padding: 0.5rem 0.4rem !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      min-height: 100px !important;
      box-sizing: border-box !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:first-child,
    .character-tab-panel .content-rankings-grid > div > div:first-child,
    .content-rankings .content-rankings-grid > div > div:first-child {
      font-size: 0.7rem !important;
      margin-bottom: 0.25rem !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:nth-child(2),
    .character-tab-panel .content-rankings-grid > div > div:nth-child(2),
    .content-rankings .content-rankings-grid > div > div:nth-child(2) {
      font-size: 1rem !important;
      font-weight: 600 !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:nth-child(3),
    .character-tab-panel .content-rankings-grid > div > div:nth-child(3),
    .content-rankings .content-rankings-grid > div > div:nth-child(3) {
      font-size: 0.7rem !important;
      margin-top: 0.2rem !important;
    }
    
    /* 전투력 랭킹 정보 3열로 변경 (1줄에 모두 표시, 좌우 압축) */
    .ranking-info {
      width: 100% !important;
      max-width: 100% !important;
    }
    
    .ranking-info .ranking-stats {
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 0.3rem !important;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    .ranking-info .ranking-stat-item {
      text-align: center !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      padding: 0.5rem 0.25rem !important;
    }
    
    .ranking-info .ranking-stat-item > div:first-child {
      font-size: 0.65rem !important;
      margin-bottom: 0.25rem !important;
    }
    
    .ranking-info .ranking-stat-item > div:nth-child(2) {
      font-size: 0.95rem !important;
      font-weight: 600 !important;
    }
    
    .ranking-info .ranking-stat-item > div:nth-child(3) {
      font-size: 0.65rem !important;
      margin-top: 0.15rem !important;
    }
    
    /* 장비 2컬럼을 1컬럼으로 변경 */
    .equipment-info {
      width: 100% !important;
      max-width: 100% !important;
    }
    
    #equipment-two-column {
      grid-template-columns: 1fr !important;
      gap: 1rem !important;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    /* === 툴팁 모바일 최적화 === */
    .attack-power-tooltip,
    .combat-speed-tooltip,
    .damage-amplification-tooltip,
    .cooldown-reduction-tooltip,
    .critical-hit-tooltip,
    .stun-hit-tooltip,
    .perfect-tooltip,
    .multi-hit-tooltip {
      min-width: 200px !important;
      max-width: calc(100vw - 2rem) !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      font-size: 0.75rem !important;
    }
    
    /* 툴팁 내용 간격 조정 */
    .attack-power-tooltip > div:last-of-type,
    .combat-speed-tooltip > div:last-of-type,
    .damage-amplification-tooltip > div:last-of-type,
    .cooldown-reduction-tooltip > div:last-of-type,
    .critical-hit-tooltip > div:last-of-type,
    .stun-hit-tooltip > div:last-of-type,
    .perfect-tooltip > div:last-of-type {
      gap: 0.3rem !important;
    }
  }

  /* 모바일 최적화 */
  @media (max-width: 768px) {
    /* 모바일에서 홈 화면의 사이드바 hero-card 테두리 진하게 */
    .sidebar-banner .hero-card {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
    }
    
    /* 모바일에서 홈 화면의 메인 콘텐츠 hero-card 테두리 진하게 */
    .main-content .hero-card,
    #streamer-section .hero-card,
    #favorites-section .hero-card {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
    }
    
    /* 모바일에서 랭킹/통계 탭의 hero-card 테두리 진하게 */
    #panel-ranking .hero-card,
    #panel-statistics .hero-card {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
    }
    
    /* 모바일에서 캐릭터 검색 wrapper의 직사각형 테두리 제거 */
    #character-search-wrapper {
      border: none !important;
    }
    
    /* 모바일에서 캐릭터 검색 폼의 둥근 테두리 진하게 유지 */
    .character-search-form {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
    }
    
    /* 캐릭터 검색 결과 화면의 컨테이너들 테두리 제거 */
    #character-result .hero-card,
    #equipment-container,
    #accessories-container,
    #stats-section,
    #normal-stats-section {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
      border-radius: 12px;
      padding: 1.5rem !important;
    }
    
    /* 모바일에서 타이틀과 스킬 섹션 테두리 제거 및 왼쪽 여백 제거 */
    #title-info,
    #skill-info {
      border: none !important;
      border-radius: 12px;
      padding: 1.5rem 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
    }
    
    /* 모바일에서 스킬 카테고리 카드 테두리 진하게 */
    .skill-category-card {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
    }
    
    /* 모바일에서 stat-chip (종족/서버/직업/레기온/전투력) 카드 테두리 진하게 */
    .stat-chip {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
    }
    
    /* 모바일에서 랭킹 정보 카드 테두리 진하게 */
    .ranking-stat-item {
      border: 1px solid rgba(255, 255, 255, 0.4) !important;
      text-align: center !important;
    }
    
    /* 모바일에서 랭킹 스탯 레이아웃 변경 - 인라인 스타일 덮어쓰기 */
    .ranking-stat-item > div:nth-child(2) {
      display: flex !important;
      flex-direction: column !important;
      align-items: center !important;
      justify-content: center !important;
      gap: 0.35rem !important;
      margin-bottom: 0.4rem !important;
    }
    
    /* 모바일에서 제목과 버튼이 세로로 배치되도록 */
    .ranking-stat-item > div:nth-child(2) > span {
      display: block !important;
      text-align: center !important;
      width: 100% !important;
    }
    
    .ranking-stat-item > div:nth-child(2) > button {
      display: block !important;
      margin: 0 auto !important;
    }
    
    /* 모바일에서 i 버튼 크기 줄이기 */
    .ranking-stat-item .attack-power-info-icon,
    .ranking-stat-item .critical-hit-info-icon,
    .ranking-stat-item .combat-speed-info-icon,
    .ranking-stat-item .weapon-damage-amplification-info-icon,
    .ranking-stat-item .damage-amplification-info-icon,
    .ranking-stat-item .critical-damage-amplification-info-icon,
    .ranking-stat-item .skill-damage-info-icon,
    .ranking-stat-item .cooldown-reduction-info-icon,
    .ranking-stat-item .stun-hit-info-icon,
    .ranking-stat-item .perfect-info-icon,
    .ranking-stat-item .multi-hit-info-icon {
      width: 14px !important;
      height: 14px !important;
      font-size: 9px !important;
      min-width: 14px !important;
      min-height: 14px !important;
      max-width: 14px !important;
      max-height: 14px !important;
    }
    
    /* 모바일에서 값 크기 줄이기 */
    .ranking-stat-item > div:last-child {
      font-size: 1.1rem !important;
    }
    
    /* 모바일에서 라벨 크기 줄이기 */
    .ranking-stat-item > div:first-of-type:not(.damage-increase-badge) {
      font-size: 0.7rem !important;
    }
    
    /* 모바일에서 스탯 이름 span */
    .ranking-stat-item > div:first-of-type:not(.damage-increase-badge) > span {
      display: block !important;
      text-align: center !important;
    }
    html {
      font-size: 16px; /* 고정 크기로 변경 - 프로덕션과 로컬 동일하게 */
      overflow-x: hidden !important;
      width: 100% !important;
      max-width: 100vw !important;
    }
    
    body {
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
      overflow-x: hidden !important;
      width: 100% !important;
      max-width: 100vw !important;
      touch-action: pan-y;
    }
    
    /* 모바일에서 터치 영역 확대 */
    .tab-controls label,
    .tab-controls .tab-link,
    button,
    .search-button {
      min-height: 44px;
      min-width: 44px;
    }
    
    /* 전체 컨테이너 너비 조정 */
    .main-layout {
      width: 100%;
      max-width: 100vw;
      box-sizing: border-box;
    }
    
    /* 사이드바 너비 조정 */
    .sidebar-banner {
      width: 100%;
      max-width: 100%;
    }
    
    /* 메인 콘텐츠 너비 조정 */
    .main-content {
      width: 100%;
      max-width: 100%;
    }
  }

  .dashboard {
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 28px;
    padding: 1rem clamp(0.75rem, 3vw, 1.5rem);
    /* box-shadow: 0 25px 80px rgba(3, 6, 18, 0.65); */
  }
  
  /* 캐릭터 검색 탭에서만 더 타이트한 padding */
  #panel-character .character-search-form {
    margin-bottom: 0.5rem;
  }
  
  #panel-character .search-row-first,
  #panel-character .search-row-second {
    margin-bottom: 0.5rem;
  }
  
  #panel-character .search-row-second {
    margin-bottom: 0;
  }

  .tabs {
    position: relative;
    flex: 1;
  }

  .tabs input[type="radio"] {
    display: none;
  }

  .tab-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .tab-controls li {
    margin: 0;
    padding: 0;
  }

  .tab-controls label,
  .tab-controls .tab-link {
    display: flex;
    align-items: center;
    padding: 0.6rem 1.2rem;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.04);
    border: 1px solid transparent;
    cursor: pointer;
    transition: border 0.2s ease, transform 0.2s ease,
      background 0.2s ease;
    font-size: 0.9rem;
    font-weight: 500;
    text-decoration: none;
    color: var(--text-muted);
    position: relative;
  }

  /* 새 업데이트 표시 빨간 점 */
  .tab-controls label .new-badge-dot,
  .tab-controls .tab-link .new-badge-dot {
    position: absolute;
    top: 6px;
    left: 6px;
    width: 8px;
    height: 8px;
    background: #ef4444;
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
    z-index: 10;
  }

  .tab-controls .tab-link:hover {
    border-color: rgba(157, 140, 255, 0.3);
    background: rgba(157, 140, 255, 0.08);
  }

  .tab-controls .tab-link.active {
    border-color: rgba(157, 140, 255, 0.8);
    background: rgba(157, 140, 255, 0.12);
    box-shadow: 0 10px 30px rgba(157, 140, 255, 0.15);
    transform: translateY(-2px);
    color: var(--accent);
  }

  .tab-controls span.title {
    font-size: 0.9rem;
    font-weight: 500;
  }

  .tab-controls span.meta {
    display: none;
  }

  #tab-character:checked ~ .site-header .tab-controls label[for="tab-character"],
  #tab-ranking:checked ~ .site-header .tab-controls label[for="tab-ranking"],
  #tab-statistics:checked ~ .site-header .tab-controls label[for="tab-statistics"] {
    border-color: rgba(157, 140, 255, 0.8);
    background: rgba(157, 140, 255, 0.12);
    box-shadow: 0 10px 30px rgba(157, 140, 255, 0.15);
    transform: translateY(-2px);
  }

  .tab-panels {
    min-height: 280px;
    position: relative;
  }
  
  /* 캐릭터 탭일 때는 최소 높이 제거 (전체 서버 검색 결과가 밖에 있으므로) */
  #tab-character:checked ~ * .tab-panels {
    min-height: 0;
  }

  .tab-panel {
    display: none;
    opacity: 0;
    transform: translateY(12px);
    transition: opacity 0.25s ease, transform 0.25s ease;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 1;
    pointer-events: none;
  }

  #tab-character:checked ~ * .tab-panels #panel-character,
  #tab-ranking:checked ~ * .tab-panels #panel-ranking,
  #tab-statistics:checked ~ * .tab-panels #panel-statistics {
    display: grid;
    opacity: 1;
    transform: translateY(0);
    position: relative;
    pointer-events: auto;
    z-index: 2;
    top: 0;
    left: 0;
  }
  

  /* 탭 패널이 dashboard 안에 있을 때 */
  .dashboard .tab-panels {
    margin-top: 0;
  }

  /* ===== Card 디자인 개선 ===== */
  .hero-card {
    background: rgba(22, 27, 34, 0.95);
    border: 1px solid rgba(167, 139, 250, 0.3);
    border-radius: 16px;
    padding: 1.5rem;
    display: grid;
    gap: 1.2rem;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
    transition: all 0.2s ease;
  }
  
  .hero-card:hover {
    border-color: rgba(167, 139, 250, 0.5);
    box-shadow: 0 8px 24px rgba(167, 139, 250, 0.2);
  }
  
  /* 랭킹/통계 탭의 hero-card */
  #panel-ranking .hero-card,
  #panel-statistics .hero-card {
    border: 1px solid rgba(167, 139, 250, 0.3) !important;
  }
  
  /* 홈 화면의 사이드바 hero-card 테두리 진하게 */
  .sidebar-banner .hero-card {
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
  }
  
  /* 캐릭터 검색 wrapper의 직사각형 테두리 제거 */
  #character-search-wrapper {
    border: none !important;
  }
  
  /* 캐릭터 검색 폼의 둥근 테두리 진하게 유지 */
  .character-search-form {
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
  }
  
  /* 인라인 스타일로 설정된 테두리도 오버라이드 (둥근 테두리 유지) */
  .character-search-form[style*="border"] {
    border: 1px solid rgba(255, 255, 255, 0.4) !important;
  }
  
  /* 일일 검색 랭킹과 컨텐츠 타이머 카드의 패딩 줄이기 */
  .sidebar-banner .hero-card {
    padding: 1rem 1.25rem;
    gap: 0.75rem;
  }

  .hero-card h3 {
    margin: 0;
    font-size: 1.4rem;
    font-weight: 600;
  }

  .hero-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.8rem;
  }

  .stat-chip {
    padding: 0.8rem;
    border-radius: 16px;
    background: rgba(4, 7, 25, 0.35);
    border: 1px solid rgba(255, 255, 255, 0.12);
  }

  .stat-chip span {
    display: block;
  }

  .stat-chip span.label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.2rem;
  }

  .stat-chip span.value {
    font-weight: 600;
    font-size: 1.05rem;
  }

  /* 라이트 모드에서 stat-chip 색상 통일 */
  :root[data-theme="light"] .stat-chip {
    background: rgba(244, 244, 255, 0.5);
    border-color: rgba(0, 0, 0, 0.06);
  }

  /* 컨텐츠 랭킹 그리드 기본 스타일 (데스크톱) */
  .content-rankings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    gap: 0.75rem;
  }

  /* 랭킹 정보 카드 스타일 */
  .ranking-stat-item {
    padding: 1rem;
    background: rgba(4, 7, 25, 0.35);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.12);
    position: relative;
  }
  
  /* 딜증 박스 스타일 */
  .damage-increase-badge {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    padding: 3px 10px;
    background: rgba(74, 222, 128, 0.15);
    border: 1px solid rgba(74, 222, 128, 0.3);
    border-radius: 6px;
    font-size: 0.65rem;
    font-weight: 600;
    color: #4ade80;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    z-index: 10;
    white-space: nowrap;
    letter-spacing: 0.3px;
    backdrop-filter: blur(4px);
  }
  
  :root[data-theme="light"] .damage-increase-badge {
    background: rgba(34, 197, 94, 0.12);
    border: 1px solid rgba(34, 197, 94, 0.25);
    color: #16a34a;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  }

  /* 라이트 모드에서 랭킹 정보 카드 색상 통일 */
  :root[data-theme="light"] .ranking-stat-item {
    background: rgba(244, 244, 255, 0.5);
    border-color: rgba(0, 0, 0, 0.06);
  }

  /* 공격력 정보 아이콘 및 툴팁 스타일 */
  .attack-power-tooltip {
    opacity: 0;
    pointer-events: none;
  }

  /* attack-power tooltip도 기본 숨김 */

  /* 모든 tooltip 기본 숨김 (hover 제거) */
  .combat-speed-tooltip,
  .damage-amplification-tooltip,
  .weapon-damage-amplification-tooltip,
  .pve-damage-amplification-tooltip,
  .critical-damage-amplification-tooltip,
  .critical-hit-tooltip,
  .skill-damage-tooltip,
  .cooldown-reduction-tooltip,
  .stun-hit-tooltip,
  .perfect-tooltip,
  .multi-hit-tooltip,
  .attack-power-tooltip {
    display: none !important;
    opacity: 0 !important;
    pointer-events: none !important;
  }

  /* i 버튼 hover 효과 (tooltip은 표시하지 않음) */
  .combat-speed-info-icon:hover,
  .damage-amplification-info-icon:hover,
  .weapon-damage-amplification-info-icon:hover,
  .pve-damage-amplification-info-icon:hover,
  .critical-damage-amplification-info-icon:hover,
  .critical-hit-info-icon:hover,
  .skill-damage-info-icon:hover,
  .cooldown-reduction-info-icon:hover,
  .stun-hit-info-icon:hover,
  .perfect-info-icon:hover,
  .multi-hit-info-icon:hover,
  .attack-power-info-icon:hover {
    background: rgba(157, 140, 255, 0.3) !important;
    border-color: rgba(157, 140, 255, 0.6) !important;
    color: #a78bfa !important;
  }

  /* 모달 팝업 스타일 */
  .stat-info-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background: rgba(0, 0, 0, 0.7);
    z-index: 100000 !important;
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
    margin: 0 !important;
  }

  .stat-info-modal.active {
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  .stat-info-modal-content {
    background: rgba(22, 27, 34, 0.98);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    padding: 1.5rem;
    width: 100%;
    max-width: 600px;
    max-height: 90vh;
    overflow-y: auto;
    overflow-x: hidden;
    color: var(--text-primary);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    box-sizing: border-box;
    word-wrap: break-word;
    -webkit-overflow-scrolling: touch;
    position: relative;
    margin: 0 auto;
  }

  @media (max-width: 768px) {
    .stat-info-modal {
      padding: 10px;
    }
    
    .stat-info-modal-content {
      padding: 1rem;
      max-height: 85vh;
    }
  }
  
  /* 장비/장신구 요약 모달 */
  #equipment-summary-modal .stat-info-modal-content {
    max-width: 900px;
    width: 100%;
  }
  
  .equipment-summary-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
  }
  
  @media (max-width: 768px) {
    #equipment-summary-modal .stat-info-modal-content {
      max-width: 100%;
      max-height: 95vh !important;
      padding: 0.3rem !important;
      width: calc(100vw - 20px) !important;
      box-sizing: border-box !important;
    }
    
    /* 모바일에서도 2column 유지 */
    .equipment-summary-grid {
      grid-template-columns: 1fr 1fr !important;
      gap: 0.3rem !important;
    }
    
    /* 모바일: 섹션 타이틀 크기 조정 */
    #equipment-summary-modal h5 {
      font-size: 0.65rem !important;
      margin: 0 0 0.3rem 0 !important;
    }
    
    /* 모바일: 패딩 조정 */
    #equipment-summary-modal .stat-info-modal-content > div {
      padding: 0.3rem !important;
      box-sizing: border-box !important;
    }
    
    /* 모바일: 각 컬럼 너비 제한 */
    #equipment-summary-modal .equipment-summary-grid > div {
      min-width: 0 !important;
      overflow: hidden !important;
    }
    
    /* 모바일: 각 아이템 컨테이너 높이 증가 */
    #equipment-summary-list > div,
    #accessories-summary-list > div {
      padding: 0.3rem !important;
      gap: 0.3rem !important;
      border-radius: 4px !important;
      min-height: 52px !important;
      display: flex !important;
      align-items: center !important;
      box-sizing: border-box !important;
      overflow: hidden !important;
    }
    
    /* 모바일: 아이콘 크기 조정 (32px -> 28px) */
    #equipment-summary-list img,
    #accessories-summary-list img {
      width: 28px !important;
      height: 28px !important;
      border-radius: 4px !important;
      flex-shrink: 0 !important;
    }
    
    /* 모바일: 초월 배지 크기 조정 (14px -> 12px) */
    #equipment-summary-list span[style*="rotate(45deg)"],
    #accessories-summary-list span[style*="rotate(45deg)"] {
      width: 12px !important;
      height: 12px !important;
      font-size: 0.5rem !important;
      border-width: 0.5px !important;
      flex-shrink: 0 !important;
    }
    
    /* 모바일: 정보 컨테이너 overflow 처리 */
    #equipment-summary-list > div > div,
    #accessories-summary-list > div > div {
      min-width: 0 !important;
      overflow: hidden !important;
      flex: 1 !important;
    }
    
    /* 모바일: 아이템 이름 크기 조정 (0.65rem -> 0.58rem) */
    #equipment-summary-list > div > div > div:first-child,
    #accessories-summary-list > div > div > div:first-child {
      font-size: 0.58rem !important;
      margin-bottom: 0.15rem !important;
      gap: 0.2rem !important;
      flex-wrap: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      line-height: 1.3 !important;
      display: flex !important;
      align-items: center !important;
    }
    
    /* 모바일: 아이템 이름 내부 텍스트도 크기 조정 */
    #equipment-summary-list > div > div > div:first-child span,
    #accessories-summary-list > div > div > div:first-child span {
      font-size: 0.58rem !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }
    
    /* 모바일: 레벨 정보 크기 조정 (0.55rem -> 0.52rem) */
    #equipment-summary-list > div > div > div:not(:first-child),
    #accessories-summary-list > div > div > div:not(:first-child) {
      font-size: 0.52rem !important;
      margin-bottom: 0.08rem !important;
      line-height: 1.35 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
    }
    
    /* 모바일: 리스트 아이템 간격 */
    #equipment-summary-list,
    #accessories-summary-list {
      gap: 0.35rem !important;
    }
    
    /* 모바일: 모달 타이틀 크기 조정 */
    #equipment-summary-modal .stat-info-modal-title {
      font-size: 0.85rem !important;
    }
    
    /* 모바일: 닫기 버튼 크기 조정 */
    #equipment-summary-modal .stat-info-modal-close {
      width: 24px !important;
      height: 24px !important;
      font-size: 1.2rem !important;
      flex-shrink: 0 !important;
    }
    
    /* 모바일: 모달 헤더 패딩 조정 */
    #equipment-summary-modal .stat-info-modal-header {
      margin-bottom: 0.5rem !important;
      padding-bottom: 0.5rem !important;
    }
  }

  .stat-info-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .stat-info-modal-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--accent);
  }

  .stat-info-modal-close {
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s ease;
  }

  .stat-info-modal-close:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
  }

  .stat-info-breakdown-section {
    margin-bottom: 1.5rem;
  }

  .stat-info-breakdown-title {
    font-size: 0.875rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
    font-weight: 500;
  }

  .stat-info-breakdown-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.4rem 0;
    font-size: 0.875rem;
  }

  .stat-info-breakdown-value {
    color: #60a5fa;
    font-weight: 500;
  }

  .stat-info-description-section {
    margin-top: 1.5rem;
    padding-top: 1.5rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .stat-info-description-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
  }

  .stat-info-description-text {
    font-size: 0.875rem;
    color: var(--text-muted);
    line-height: 1.6;
    margin-bottom: 0.5rem;
  }

  .stat-info-damage-increase {
    margin-top: 1rem;
    padding: 0.75rem;
    background: rgba(251, 191, 36, 0.1);
    border: 1px solid rgba(251, 191, 36, 0.3);
    border-radius: 8px;
    font-size: 0.875rem;
    color: #fbbf24;
    font-weight: 600;
    text-align: center;
  }

  /* 통계 게이지바 배경 스타일 */
  .statistics-gauge-bg {
    background: rgba(255, 255, 255, 0.1);
  }

  /* 라이트 모드에서 통계 게이지바 배경 */
  :root[data-theme="light"] .statistics-gauge-bg {
    background: rgba(0, 0, 0, 0.08);
  }

  .statistics-controls {
    margin: 1.5rem 0;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .statistics-desc-wrap {
    margin-top: 0.4rem;
  }

  .statistics-desc {
    margin: 0.15rem 0;
    color: var(--text-muted);
    font-size: 0.95rem;
  }

  /* 통계 서브 탭 스타일 */
  .statistics-sub-tabs {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--card-border);
    border-top: none !important;
    width: 100%;
    box-sizing: border-box;
  }
  
  /* 내실 랭킹 및 컨텐츠 랭킹이 활성화되었을 때 메인 탭의 border-bottom 유지하되 위치 조정 */
  #panel-ranking .statistics-sub-tabs.no-border-bottom {
    border-bottom: 1px solid var(--card-border) !important;
    padding-bottom: 0.5rem !important;
    margin-bottom: 0.5rem !important;
  }
  
  .statistics-sub-tab-btn {
    background: transparent;
    border: none;
    border-top: none !important;
    color: var(--text-muted);
    font-size: 1.1rem;
    font-weight: 600;
    padding: 0.5rem 1.5rem;
    cursor: pointer;
    position: relative;
    transition: color 0.2s;
    white-space: nowrap;
    text-decoration: none;
    display: inline-block;
  }

  /* 스킬 통계 새 업데이트 표시 빨간 점 */
  .statistics-sub-tab-btn .new-badge-dot {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 8px;
    height: 8px;
    background: #ef4444;
    border-radius: 50%;
    box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
    z-index: 10;
  }

  /* New 배지 floating 애니메이션 */
  .new-badge-floating {
    position: absolute;
    top: -8px;
    right: -8px;
    background: #ef4444;
    color: white;
    font-size: 0.65rem;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.5);
    z-index: 100;
    animation: float 2s ease-in-out infinite;
    white-space: nowrap;
  }

  @keyframes float {
    0%, 100% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-5px);
    }
  }
  
  .statistics-sub-tab-btn:hover {
    color: var(--text-primary);
  }
  
  .statistics-sub-tab-btn.active {
    color: var(--accent);
    background: rgba(157, 140, 255, 0.12) !important;
    border-radius: 8px 8px 0 0 !important;
    position: relative;
  }
  
  /* 활성화된 메인 탭의 배경색이 밑줄까지 내려가도록 */
  .statistics-sub-tab-btn.active::before {
    content: '';
    position: absolute;
    bottom: -1.1rem;
    left: 0;
    width: 100%;
    height: calc(1rem + 4px);
    background: rgba(157, 140, 255, 0.12);
    border-radius: 0 0 0 0;
    z-index: 1;
    border-top: none !important;
    /* 컨테이너의 border-bottom을 덮기 위해 1px 더 내려감 */
    bottom: calc(-1.1rem - 0.1px);
    height: calc(1rem + 2px);
  }
  
  .statistics-sub-tab-btn.active::after {
    display: none;
  }

  /* 아툴 전투 점수 랭킹 특별 스타일 (rectangle 효과 제거, NEW만 표시) */
  .combat-score-ranking-special {
    position: relative;
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    overflow: visible !important;
  }

  .combat-score-ranking-special:hover {
    background: rgba(167, 139, 250, 0.15) !important;
    border: none !important;
    box-shadow: none !important;
    transform: translateY(-2px);
    transition: all 0.3s ease;
  }

  .combat-score-ranking-special.active {
    background: rgba(167, 139, 250, 0.2) !important;
    border: none !important;
    box-shadow: none !important;
  }

  .combat-score-ranking-special.active::after {
    display: block !important;
    background: linear-gradient(90deg, 
      transparent, 
      rgba(167, 139, 250, 1), 
      rgba(236, 72, 153, 1), 
      rgba(167, 139, 250, 1), 
      transparent) !important;
    height: 3px !important;
  }

  /* 반짝이는 효과 */
  .sparkle-effect {
    display: inline-block;
    animation: sparkle 2s ease-in-out infinite;
    font-size: 0.9em;
    margin: 0 0.2rem;
  }

  .sparkle-effect:nth-child(1) {
    animation-delay: 0s;
  }

  .sparkle-effect:nth-child(3) {
    animation-delay: 1s;
  }

  /* NEW 배지 */
  .combat-score-ranking-special .new-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
    color: white;
    font-size: 0.65rem;
    font-weight: 700;
    padding: 0.15rem 0.4rem;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(255, 107, 107, 0.5),
                0 0 15px rgba(255, 107, 107, 0.3);
    animation: new-badge-pulse 2s ease-in-out infinite;
    z-index: 10;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }

  /* 애니메이션 */
  @keyframes sparkle-glow {
    0%, 100% {
      box-shadow: 0 0 20px rgba(167, 139, 250, 0.3), 
                  0 0 40px rgba(236, 72, 153, 0.2),
                  inset 0 0 20px rgba(167, 139, 250, 0.1);
    }
    50% {
      box-shadow: 0 0 30px rgba(167, 139, 250, 0.5), 
                  0 0 60px rgba(236, 72, 153, 0.4),
                  inset 0 0 30px rgba(167, 139, 250, 0.2);
    }
  }

  @keyframes sparkle-glow-active {
    0%, 100% {
      box-shadow: 0 0 40px rgba(167, 139, 250, 0.6), 
                  0 0 80px rgba(236, 72, 153, 0.4),
                  inset 0 0 40px rgba(167, 139, 250, 0.3);
    }
    50% {
      box-shadow: 0 0 50px rgba(167, 139, 250, 0.8), 
                  0 0 100px rgba(236, 72, 153, 0.6),
                  inset 0 0 50px rgba(167, 139, 250, 0.4);
    }
  }

  @keyframes sparkle {
    0%, 100% {
      opacity: 1;
      transform: scale(1) rotate(0deg);
    }
    50% {
      opacity: 0.5;
      transform: scale(1.2) rotate(180deg);
    }
  }

  @keyframes shimmer-sparkle {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }

  @keyframes new-badge-pulse {
    0%, 100% {
      transform: scale(1);
      box-shadow: 0 2px 8px rgba(255, 107, 107, 0.5),
                  0 0 15px rgba(255, 107, 107, 0.3);
    }
    50% {
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.7),
                  0 0 25px rgba(255, 107, 107, 0.5);
    }
  }

  /* 내실 랭킹 및 컨텐츠 랭킹 서브탭 컨테이너 (메인 탭 바로 아래 배치) */
  #internal-ranking-content > .statistics-sub-tabs,
  #contents-ranking-content > .statistics-sub-tabs {
    margin-left: 0;
    margin-top: -2.1rem;
    margin-bottom: 1.5rem;
    padding-top: 0;
    padding-bottom: 0;
    border-top: none !important;
    position: relative;
    display: flex;
    gap: 0;
  }

  /* 내실 랭킹 및 컨텐츠 랭킹 서브탭 스타일 (작은 탭 형태, 일정한 크기) */
  .internal-sub-tab,
  .contents-sub-tab {
    background: rgba(255, 255, 255, 0.03) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-radius: 0 !important;
    font-size: 0.85rem !important;
    font-weight: 500 !important;
    padding: 0.5rem 0.5rem !important;
    margin: 0 !important;
    margin-right: -1px !important; /* 서브탭들 사이 간격 제거 */
    color: var(--text-muted) !important;
    transition: all 0.2s !important;
    position: relative !important;
    border-bottom: 2px solid transparent !important;
    cursor: pointer !important;
    white-space: nowrap !important;
    text-align: center !important;
    flex-shrink: 0 !important;
    box-sizing: border-box !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
  }
  
  /* 첫 번째 서브탭만 왼쪽 border-radius */
  .internal-sub-tab:first-child,
  .contents-sub-tab:first-child {
    border-radius: 6px 0 0 0 !important;
  }
  
  /* 마지막 서브탭만 오른쪽 border-radius */
  .internal-sub-tab:last-child,
  .contents-sub-tab:last-child {
    border-radius: 0 6px 0 0 !important;
    margin-right: 0 !important;
  }
  
  /* 서브탭 버튼 일정한 크기 (가장 긴 텍스트 기준: "◆ 스티그마 샤드", "협력의 투기장") */
  .internal-sub-tab {
    min-width: 130px !important;
    width: 130px !important;
  }
  
  .contents-sub-tab {
    min-width: 115px !important;
    width: 115px !important;
  }

  .internal-sub-tab:hover,
  .contents-sub-tab:hover {
    color: var(--text-primary) !important;
    background: rgba(255, 255, 255, 0.05) !important;
    border-color: rgba(157, 140, 255, 0.3) !important;
  }

  /* 활성화된 서브탭 스타일 (메인 탭과 연결되는 느낌) */
  .internal-sub-tab.active,
  .contents-sub-tab.active {
    color: var(--accent) !important;
    background: rgba(157, 140, 255, 0.15) !important;
    border-color: var(--accent) !important;
    border-bottom-color: var(--accent) !important;
    border-bottom-width: 3px !important;
  }

  .internal-sub-tab.active::before,
  .contents-sub-tab.active::before,
  .internal-sub-tab.active::after,
  .contents-sub-tab.active::after {
    display: none !important;
  }

  /* 스킬 통계 스타일 */
  .skill-stats-class-selector {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 2rem;
    justify-content: center;
  }
  
  .skill-stats-class-btn {
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--card-border);
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
  }
  
  .skill-stats-class-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-primary);
  }
  
  .skill-stats-class-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  
  .skill-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
  }
  
  .skill-stats-column {
    background: var(--card-bg);
    border: 1px solid var(--card-border);
    border-radius: 12px;
    padding: 1.5rem;
  }
  
  .skill-stats-col-header {
    font-size: 1.1rem;
    font-weight: 600;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--card-border);
    color: var(--text-primary);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .skill-stats-list {
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
  }
  
  .skill-stats-item {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    padding: 0.8rem;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 8px;
  }

  .skill-stats-meta {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .skill-stats-header {
    display: flex;
    align-items: center;
    gap: 0.35rem;
  }

  .skill-stats-icon {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    object-fit: cover;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.06);
  }
  
  .skill-stats-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .skill-stats-name {
    font-weight: 600;
    color: var(--text-primary);
  }
  
  .skill-stats-rate {
    color: var(--accent);
    font-weight: 700;
    font-size: 0.8rem;
  }
  
  .skill-stats-bars {
    display: flex;
    height: 8px;
    border-radius: 4px;
    overflow: hidden;
    background: rgba(0,0,0,0.3);
    margin-top: 0.2rem;
  }
  
  .skill-stats-bar-segment {
    height: 100%;
  }
  
  .skill-stats-bar-high { background: #ef4444; }
  .skill-stats-bar-mid { background: #fbbf24; }
  .skill-stats-bar-low { background: #3b82f6; }
  
  .skill-stats-details {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.2rem;
  }
  
  .skill-stats-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    font-size: 0.8rem;
    color: var(--text-muted);
    justify-content: flex-start;
    margin-bottom: 1.5rem;
  }
  
  .skill-stats-legend-item {
    display: flex;
    align-items: center;
    gap: 0.3rem;
  }
  
  .skill-stats-legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }

  /* 성장기록 그래프 모바일 최적화 */
  #growth-history-content {
    width: 100%;
    max-width: 100%;
    overflow: hidden;
    position: relative;
  }

  #growth-history-content > div {
    width: 100%;
    max-width: 100%;
  }

  #growth-chart {
    max-width: 100% !important;
    height: auto !important;
  }

  @media (max-width: 768px) {
    #growth-history-content {
      min-height: 300px;
    }

    #growth-history-content canvas {
      max-width: 100% !important;
    }
  }

      .companion-badge-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin: 0.25rem 0 0.75rem;
      }

      .companion-badge {
        display: flex;
        align-items: center;
        gap: 0.45rem;
        padding: 0.35rem 0.65rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.04);
      }

      .companion-badge img {
        width: 22px;
        height: 22px;
        border-radius: 6px;
        object-fit: cover;
        background: rgba(0, 0, 0, 0.35);
      }

      .companion-badge-name {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--text-primary);
      }

  /* 즐겨찾기 닉네임 넘침 방지 (일반 스타일) */
  #favorites-container .character-name,
  #favorites-container .character-info,
  #favorites-container [class*="name"],
  #favorites-container [class*="info"],
  #favorites-container > div > div > div:not(:first-child) {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
  }
  
  #favorites-container > div {
    overflow: hidden;
    min-width: 0;
  }

  .stat-filter-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }

  .stat-filter-label {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-muted);
  }

  /* 스트리머 방송 컬럼 스타일 */
  .streamer-race-column {
    padding: 0 0.5rem;
  }

  .streamer-container {
    max-height: 600px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
  }

  /* 전투력 TOP 5 높이 맞추기 */
  #power-top5-wrapper {
    align-items: stretch !important;
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
  }
  
  .power-top5-section {
    display: flex !important;
    flex-direction: column !important;
    align-items: stretch !important;
    min-height: 100% !important;
  }
  
  #power-top5-elyos,
  #power-top5-asmodian {
    flex: 1 1 auto !important;
    min-height: 0 !important;
    display: flex !important;
    flex-direction: column !important;
  }
  
  /* 전투력 TOP 5 항목들이 동일한 높이를 가지도록 */
  #power-top5-elyos > div,
  #power-top5-asmodian > div {
    flex-shrink: 0 !important;
  }
  
  /* 모바일에서 전투력 TOP 5 레이아웃 조정 */
  @media (max-width: 768px) {
    #power-top5-wrapper {
      grid-template-columns: 1fr !important;
      gap: 1rem !important;
    }
  }

  /* 모바일에서 즐겨찾기 카드 레이아웃 조정 */
  @media (max-width: 770px) {
    #favorites-container {
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 0.5rem !important;
    }
    
    #favorites-section .hero-card {
      padding: 0.75rem !important;
    }
    
    #favorites-section {
      margin-bottom: 0.75rem !important;
    }
    
    /* 캐릭터 검색 결과 화면에서도 모바일에서는 2 column */
    .main-layout.show-character-result #favorites-container {
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 0.5rem !important;
    }
    
    /* 모바일에서 즐겨찾기 섹션 overflow 방지 */
    #favorites-section {
      overflow: visible !important;
      max-width: 100% !important;
      width: 100% !important;
    }
    
    #favorites-container {
      overflow: visible !important;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }
    
    #favorites-section .hero-card {
      overflow: visible !important;
      max-width: 100% !important;
      width: 100% !important;
    }
    
    /* 모바일에서 즐겨찾기 이미지 비율 유지 */
    #favorites-container img {
      width: 56px !important;
      height: auto !important;
      max-height: 126px !important;
      object-fit: contain !important;
    }
    
    /* 모바일에서 이미지 컨테이너도 비율 유지 */
    #favorites-container > div > div:first-child {
      display: flex !important;
      align-items: flex-start !important;
    }
    
    /* 모바일에서 즐겨찾기 닉네임 넘침 방지 */
    #favorites-container .character-name,
    #favorites-container .character-info,
    #favorites-container [class*="name"],
    #favorites-container [class*="info"],
    #favorites-container > div > div > div:not(:first-child) {
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      max-width: 100% !important;
    }
    
    #favorites-container > div {
      overflow: hidden !important;
      min-width: 0 !important;
    }
  }
  
  /* 작은 모바일 화면 추가 처리 (320px 이상) */
  @media (max-width: 480px) and (min-width: 320px) {
    #favorites-container {
      grid-template-columns: 1fr !important;
      gap: 0.5rem !important;
    }
    
    /* 캐릭터 검색 결과 화면에서도 작은 모바일에서는 1 column */
    .main-layout.show-character-result #favorites-container {
      grid-template-columns: 1fr !important;
    }
    
    /* 작은 화면에서 i 버튼 더 작게 */
    .ranking-stat-item .attack-power-info-icon,
    .ranking-stat-item .critical-hit-info-icon,
    .ranking-stat-item .combat-speed-info-icon,
    .ranking-stat-item .weapon-damage-amplification-info-icon,
    .ranking-stat-item .damage-amplification-info-icon,
    .ranking-stat-item .critical-damage-amplification-info-icon,
    .ranking-stat-item .skill-damage-info-icon,
    .ranking-stat-item .cooldown-reduction-info-icon,
    .ranking-stat-item .stun-hit-info-icon,
    .ranking-stat-item .perfect-info-icon,
    .ranking-stat-item .multi-hit-info-icon {
      width: 16px !important;
      height: 16px !important;
      font-size: 8px !important;
      min-width: 16px !important;
      min-height: 16px !important;
      max-width: 16px !important;
      max-height: 16px !important;
    }
    
    /* 작은 화면에서 값 크기 더 줄이기 */
    .ranking-stat-item > div:last-child {
      font-size: 1rem !important;
    }
  }
  
  /* 모바일에서 홈화면 section 간격 통일 */
  @media (max-width: 768px) {
    /* 모든 section 제목(badge) 간격 통일 */
    .main-content .badge,
    .sidebar-banner .badge {
      margin-bottom: 0.1rem !important;
      margin-top: 0 !important;
    }
    
    /* 모든 hero-card 하단 간격 통일 */
    .main-content .hero-card,
    .sidebar-banner .hero-card {
      margin-bottom: 1rem !important;
    }
    
    /* section 전체 하단 간격 통일 */
    #character-search-wrapper,
    #favorites-section,
    #streamer-section {
      margin-bottom: 1rem !important;
    }
  }

  /* 모바일에서 스트리머 카드 레이아웃 조정 */
  @media (max-width: 768px) {
    /* 스트리머 섹션 전체 레이아웃 - 가로 배치 */
    #streamer-section {
      display: block !important;
    }
    
    /* 스트리머 레이스 래퍼 - 가로 배치 */
    #streamer-race-wrapper {
      display: flex !important;
      flex-direction: row !important;
      gap: 0.5rem !important;
      width: 100% !important;
    }
    
    /* 천족/마족 컬럼을 가로로 배치 (1열에 2개씩) */
    .streamer-race-column {
      width: 50% !important;
      flex: 1 1 50% !important;
      display: flex !important;
      flex-direction: column !important;
      min-width: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* 각 컬럼 내부 스트리머 컨테이너 - 1열로 */
    .streamer-container {
      display: grid !important;
      grid-template-columns: 1fr !important;
      gap: 0.75rem !important;
      width: 100% !important;
      min-width: 0 !important;
    }
    
    /* 스트리머 카드 크기 조정 */
    .streamer-card {
      width: 100% !important;
      min-width: 0 !important;
      max-width: 100% !important;
    }
    
    /* 전체 UI 자동 조정을 위한 추가 스타일 */
    .main-layout {
      gap: 0.75rem !important;
      padding: 0 0.5rem !important;
    }
    
    .dashboard {
      padding: 0.75rem clamp(0.5rem, 2vw, 1rem) !important;
    }
    
    .hero-card {
      padding: 1rem !important;
    }
    
    /* 폰트 크기 조정 */
    .badge {
      font-size: clamp(0.85rem, 2.5vw, 1rem) !important;
    }
    
    /* 탭 컨트롤 조정 */
    .tab-controls {
      gap: 0.4rem !important;
    }
    
    .tab-controls label,
    .tab-controls .tab-link {
      padding: 0.5rem 0.9rem !important;
      font-size: clamp(0.8rem, 2vw, 0.9rem) !important;
    }
  }

  .streamer-card {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--card-border);
    border-radius: 12px;
    padding: 0;
    transition: all 0.2s ease;
    position: relative;
    overflow: hidden;
    width: 100%;
    height: auto;
    min-width: 0; /* grid 오버플로우 방지 */
    display: flex;
    flex-direction: column;
  }

  .streamer-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    border-color: rgba(157, 140, 255, 0.4);
  }
  
  .streamer-card-thumbnail-wrapper {
    position: relative;
    aspect-ratio: 16 / 9;
    width: 100%;
    cursor: pointer;
    overflow: hidden;
  }

  .streamer-card.chzzk {
    border-left: 4px solid #00ff00;
  }

  .streamer-card.soop {
    border-left: 4px solid #3b82f6;
  }

  .streamer-thumbnail {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .streamer-card-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.7) 100%);
    z-index: 2;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: 0.5rem;
    padding-bottom: 0.25rem;
    pointer-events: none;
  }
  
  .streamer-info-section {
    background: rgba(255, 255, 255, 0.05);
    padding: 0.5rem;
    border-top: 1px solid var(--card-border);
    cursor: pointer;
    transition: background 0.2s ease;
  }
  
  .streamer-info-section:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .streamer-platform-badge {
    position: absolute;
    top: 0.1rem;
    left: 0.1rem;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.65rem;
    font-weight: 600;
    z-index: 3;
  }

  .streamer-platform-badge.chzzk {
    background: rgba(0, 255, 0, 0.2);
    border: 1px solid rgba(0, 255, 0, 0.4);
    color: #00ff00;
  }

  .streamer-platform-badge.soop {
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid rgba(59, 130, 246, 0.4);
    color: #3b82f6;
  }

  .streamer-viewers-badge {
    position: absolute;
    top: 0.1rem;
    right: 0.1rem;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.65rem;
    font-weight: 600;
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: var(--text-primary);
    z-index: 3;
    display: flex;
    align-items: center;
    gap: 0.3rem;
  }

  .streamer-viewers-dot {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: #ef4444;
    animation: pulse 2s infinite;
  }

  .streamer-info-bottom {
    z-index: 3;
    pointer-events: none;
  }

  .streamer-name {
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.05rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .streamer-server {
    font-size: 0.6rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .streamer-info-section .streamer-name {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.15rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .streamer-info-section .streamer-server {
    font-size: 0.7rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  @keyframes countdownBlink {
    0%, 100% {
      opacity: 1;
      text-shadow: 0 0 10px currentColor;
    }
    50% {
      opacity: 0.6;
      text-shadow: 0 0 20px currentColor, 0 0 30px currentColor;
    }
  }

  .countdown-blink {
    animation: countdownBlink 1s ease-in-out infinite;
  }

  .stat-range-input {
    width: 110px;
    padding: 0.45rem 0.6rem;
    border-radius: 8px;
    border: 1px solid var(--card-border);
    background: rgba(255, 255, 255, 0.04);
    color: var(--text-primary);
    font-size: 1rem;
    font-family: inherit;
  }

  .stat-range-input:focus {
    outline: none;
    border-color: var(--accent);
    background: rgba(157, 140, 255, 0.08);
  }

  .dual-range {
    position: relative;
    flex: 1;
    min-width: 160px;
    height: 26px;
  }

  .dual-range-track {
    position: absolute;
    top: 50%;
    left: 0;
    width: 100%;
    height: 6px;
    transform: translateY(-50%);
    border-radius: 999px;
    background: rgba(255, 255, 255, 0.15);
  }

  .dual-range input[type="range"] {
    position: absolute;
    width: 100%;
    height: 100%;
    margin: 0;
    pointer-events: none;
    appearance: none;
    -webkit-appearance: none;
    background: none;
  }

  .dual-range input[type="range"]::-webkit-slider-thumb {
    pointer-events: auto;
    appearance: none;
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid var(--card-bg);
    background: var(--text-primary);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  }

  .dual-range input[type="range"]::-moz-range-thumb {
    pointer-events: auto;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid var(--card-bg);
    background: var(--text-primary);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  }

  .dual-range input[type="range"]::-webkit-slider-runnable-track,
  .dual-range input[type="range"]::-moz-range-track {
    height: 6px;
    border-radius: 999px;
    background: transparent;
  }

  .stat-apply-button {
    padding: 0.5rem 1.25rem;
    border-radius: 8px;
    border: 1px solid var(--accent);
    background: rgba(157, 140, 255, 0.2);
    color: var(--text-primary);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
  }

  .stat-apply-button:hover {
    background: rgba(157, 140, 255, 0.3);
    transform: translateY(-1px);
  }

  .stat-range-summary {
    font-size: 1rem;
    color: var(--text-muted);
  }

  /* 공지사항 스타일 */
  .announcement-list {
    display: flex;
    flex-direction: column;
    gap: 0;
    min-width: 0;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .announcement-item {
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    cursor: pointer;
    transition: background 0.2s ease;
    min-width: 0;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
  }

  .announcement-item:last-child {
    border-bottom: none;
  }

  .announcement-item:hover {
    background: rgba(255, 255, 255, 0.03);
  }

  .announcement-header {
    display: flex;
    align-items: center;
    padding: 0.75rem 0;
    gap: 0.5rem;
    font-size: 0.9rem;
    min-height: 2.5rem;
    height: 2.5rem;
    min-width: 0 !important;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
  }

  .announcement-date {
    color: var(--text-muted);
    font-size: 0.82rem;
    min-width: 0 !important;
    flex-shrink: 1 !important;
    flex-basis: auto;
    box-sizing: border-box;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 90px;
  }

  .announcement-title {
    flex: 1 1 0;
    color: var(--text-primary);
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.82rem;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    white-space: nowrap !important;
    min-width: 0 !important;
    box-sizing: border-box;
    flex-shrink: 1;
  }
  
  .announcement-title > span {
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    white-space: nowrap !important;
    min-width: 0 !important;
    flex: 1 1 0 !important;
    box-sizing: border-box !important;
  }

  /* 뱃지는 ellipsis 영향 받지 않도록 */
  .announcement-title > .announcement-badge-new {
    overflow: visible !important;
    text-overflow: clip !important;
    white-space: nowrap !important;
    flex: 0 0 auto !important;
    min-width: 20px !important;
  }

  /* 아이온2 업데이트 내역 container 강제 축소 */
  #aion2-updates-container,
  #announcements-container {
    min-width: 0 !important;
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    overflow-x: hidden !important;
  }
  
  #aion2-updates-container > *,
  #announcements-container > * {
    min-width: 0 !important;
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
  }

  /* 작은 화면에서 announcement 강제 축소 */
  @media (max-width: 600px) {
    .announcement-header {
      gap: 0.25rem !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
    }
    
    .announcement-date {
      font-size: 0.7rem !important;
      min-width: 0 !important;
      flex-shrink: 1 !important;
      max-width: 60px !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }
    
    .announcement-title {
      font-size: 0.75rem !important;
      gap: 0.25rem !important;
      min-width: 0 !important;
      flex: 1 1 0 !important;
      overflow: hidden !important;
    }
    
    .announcement-title > span {
      min-width: 0 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
    }
  }

  /* 매우 작은 화면에서 강력하게 축소 */
  @media (max-width: 480px) {
    /* 주신 스탯 컨테이너 2열 강제 (아주 작은 화면) */
    #stats-container {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.3rem !important;
    }
    
    .stat-card {
      min-height: 110px !important;
      padding: 0.5rem 0.4rem !important;
      width: 100% !important;
      min-width: 0 !important;
    }
    
    /* 컨텐츠 랭킹 2열 강제 유지 (아주 작은 화면) - 최우선 적용 */
    #panel-basic-info .content-rankings-grid,
    .character-tab-panel .content-rankings-grid,
    .content-rankings .content-rankings-grid {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.3rem !important;
      min-width: 0 !important;
      overflow: hidden !important;
    }
    
    #panel-basic-info .content-rankings-grid > div,
    .character-tab-panel .content-rankings-grid > div,
    .content-rankings .content-rankings-grid > div {
      padding: 0.4rem 0.25rem !important;
      min-width: 0 !important;
      min-height: 90px !important;
      box-sizing: border-box !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:first-child,
    .character-tab-panel .content-rankings-grid > div > div:first-child,
    .content-rankings .content-rankings-grid > div > div:first-child {
      font-size: 0.6rem !important;
      margin-bottom: 0.15rem !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:nth-child(2),
    .character-tab-panel .content-rankings-grid > div > div:nth-child(2),
    .content-rankings .content-rankings-grid > div > div:nth-child(2) {
      font-size: 0.85rem !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:nth-child(3),
    .character-tab-panel .content-rankings-grid > div > div:nth-child(3),
    .content-rankings .content-rankings-grid > div > div:nth-child(3) {
      font-size: 0.6rem !important;
      margin-top: 0.15rem !important;
    }
    
    /* 전투력 랭킹 3열 강제 유지 (아주 작은 화면) */
    .ranking-info .ranking-stats {
      grid-template-columns: repeat(3, 1fr) !important;
      gap: 0.25rem !important;
    }
    
    .ranking-info .ranking-stat-item {
      padding: 0.4rem 0.2rem !important;
      min-width: 0 !important;
    }
    
    .ranking-info .ranking-stat-item > div:first-child {
      font-size: 0.6rem !important;
      margin-bottom: 0.2rem !important;
    }
    
    .ranking-info .ranking-stat-item > div:nth-child(2) {
      font-size: 0.85rem !important;
    }
    
    .ranking-info .ranking-stat-item > div:nth-child(3) {
      font-size: 0.6rem !important;
      margin-top: 0.15rem !important;
    }
    
    .announcement-header {
      gap: 0.15rem !important;
      min-width: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    .announcement-date {
      font-size: 0.65rem !important;
      max-width: 50px !important;
      min-width: 0 !important;
      flex-shrink: 1 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }
    
    .announcement-title {
      font-size: 0.7rem !important;
      gap: 0.15rem !important;
      min-width: 0 !important;
      flex: 1 1 0 !important;
      overflow: hidden !important;
    }
    
    .announcement-title > span {
      min-width: 0 !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      white-space: nowrap !important;
      display: block !important;
    }

    /* 모바일에서도 뱃지는 정사각형 유지 */
    .announcement-title > .announcement-badge-new {
      display: inline-flex !important;
      width: 18px !important;
      height: 18px !important;
      min-width: 18px !important;
      min-height: 18px !important;
      max-width: 18px !important;
      max-height: 18px !important;
      flex: 0 0 auto !important;
      overflow: visible !important;
      text-overflow: clip !important;
      white-space: nowrap !important;
      display: inline-flex !important;
    }
    
    .announcement-badge-new {
      width: 18px !important;
      height: 18px !important;
      min-width: 18px !important;
      min-height: 18px !important;
      max-width: 18px !important;
      max-height: 18px !important;
      font-size: 0.7rem !important;
      border-radius: 4px !important;
      flex-shrink: 0 !important;
      flex-grow: 0 !important;
      margin-right: 0.2rem !important;
      line-height: 1 !important;
      overflow: visible !important;
      text-overflow: clip !important;
      white-space: nowrap !important;
    }
  }

  .announcement-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 20px;
    height: 20px;
    background: #3b82f6;
    color: white;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: bold;
    margin-left: auto;
  }

  .announcement-badge.new {
    background: #3b82f6;
  }

  .announcement-badge-new {
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    width: 20px !important;
    height: 20px !important;
    min-width: 20px !important;
    min-height: 20px !important;
    max-width: 20px !important;
    max-height: 20px !important;
    background: #ef4444 !important;
    color: white !important;
    border-radius: 4px !important;
    font-size: 0.75rem !important;
    font-weight: bold !important;
    line-height: 1 !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    box-sizing: border-box !important;
    overflow: visible !important;
    text-overflow: clip !important;
    white-space: nowrap !important;
    margin-right: 0.25rem !important;
  }

  .announcement-toggle {
    color: var(--text-muted);
    font-size: 0.8rem;
    transition: transform 0.2s ease;
    margin-left: 0.5rem;
    min-width: 16px;
  }

  .announcement-item.active .announcement-toggle {
    transform: rotate(180deg);
  }

  .announcement-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease, padding 0.3s ease;
    padding: 0 0 0 0;
  }

  .announcement-item.active .announcement-content {
    max-height: 1000px;
    padding: 0 0 1rem 0;
  }

  .announcement-content ul {
    margin: 0.5rem 0 0 0;
    padding-left: 1.5rem;
    list-style-type: disc;
  }

  .announcement-content li {
    margin-bottom: 0.75rem;
    color: var(--text-secondary);
    font-size: 0.82rem;
    line-height: 1.5;
  }

  .announcement-content li strong {
    color: var(--text-primary);
    font-weight: 600;
    display: block;
    margin-bottom: 0.25rem;
    font-size: 0.82rem;
  }

  .announcement-content p {
    margin: 0.5rem 0 0 0;
    color: var(--text-secondary);
    font-size: 0.82rem;
    line-height: 1.5;
  }

  /* 라이트 모드 공지사항 스타일 */
  :root[data-theme="light"] .announcement-item {
    border-bottom-color: rgba(0, 0, 0, 0.1);
  }

  :root[data-theme="light"] .announcement-item:hover {
    background: rgba(0, 0, 0, 0.02);
  }

  /* 캐릭터 검색 결과 표시 시 좌우 배너 숨김 */
  .main-layout.show-character-result .sidebar-banner {
    display: none;
  }

  /* 캐릭터 검색 결과 표시 시 스트리머 섹션 숨김 (모든 화면 크기) */
  .main-layout.show-character-result #streamer-section,
  .main-layout.show-character-result #streamer-title {
    display: none !important;
  }
  
  /* 캐릭터 검색 결과 화면에서 즐겨찾기 섹션은 표시 (CSS로 처리) */
  .main-layout.show-character-result #favorites-section {
    display: grid !important;
  }
  
  .main-layout.show-character-result #favorites-title {
    display: block !important;
  }
  
  /* 캐릭터 검색 결과 화면에서 즐겨찾기 컨테이너를 7 column으로 표시 (데스크톱만) */
  @media (min-width: 771px) {
    .main-layout.show-character-result #favorites-container {
      grid-template-columns: repeat(7, 1fr) !important;
      gap: 0.5rem !important;
    }
  }

  .main-layout.show-character-result {
    grid-template-columns: 1fr;
    max-width: 100%;
    width: 100%;
    margin-left: 0;
    margin-right: 0;
    padding: 0;
    overflow-x: visible !important;
  }
  
  .main-layout.show-character-result #character-result {
    max-width: 100%;
    width: 100%;
    overflow: visible !important;
    overflow-x: visible !important;
    overflow-y: visible !important;
    padding: 0;
    margin: 0;
  }
  
  .main-layout.show-character-result .character-info-tabs {
    max-width: 100%;
    width: 100%;
    overflow: visible !important;
    overflow-x: visible !important;
    overflow-y: visible !important;
    padding: 0;
    margin: 0;
  }

  .main-layout.show-character-result .main-content {
    max-width: 100%;
    width: 100%;
    overflow-x: visible !important;
    padding: 0;
    margin: 0;
  }

  .card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1rem;
  }

  .data-card {
    border-radius: 20px;
    border: 1px solid var(--card-border);
    background: var(--card-bg);
    padding: 1.2rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .data-card strong {
    font-size: 1.05rem;
    color: var(--text-primary);
  }

  .data-card p {
    margin: 0;
    color: var(--text-muted);
    font-size: 0.9rem;
  }

  .badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 1.25rem;
    font-weight: 700;
    padding: 0;
    border-radius: 0;
    background: transparent;
    color: var(--text-primary);
    margin-bottom: 1rem;
    border: none;
  }

  .empty-state {
    padding: 2rem;
    text-align: center;
    color: var(--text-muted);
    border: 1px dashed rgba(255, 255, 255, 0.2);
    border-radius: 20px;
  }

  /* 캐릭터 검색 오류 컨테이너는 항상 숨김 */
  #character-error {
    display: none !important;
  }
  
  /* ===== 전체 화면 로딩 오버레이 ===== */
  #fullscreen-loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(10, 14, 26, 0.95);
    backdrop-filter: blur(5px);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    /* zoom의 영향을 받지 않도록 별도 처리 */
  }
  
  
  .loading-spinner-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
  }
  
  /* 회전 스피너 */
  .loading-spinner {
    width: 60px;
    height: 60px;
    border: 4px solid rgba(157, 140, 255, 0.2);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  /* 점 애니메이션 */
  .loading-dots {
    font-size: 1.5rem;
    color: var(--text-primary);
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }
  
  .loading-dots .dot {
    animation: dot-blink 1.4s infinite;
    opacity: 0;
  }
  
  .loading-dots .dot:nth-child(2) {
    animation-delay: 0.2s;
  }
  
  .loading-dots .dot:nth-child(3) {
    animation-delay: 0.4s;
  }
  
  .loading-dots .dot:nth-child(4) {
    animation-delay: 0.6s;
  }
  
  @keyframes dot-blink {
    0%, 20% {
      opacity: 0;
    }
    50% {
      opacity: 1;
    }
    100% {
      opacity: 0;
    }
  }
  
  /* 모바일 최적화 */
  @media (max-width: 768px) {
    .loading-spinner {
      width: 50px;
      height: 50px;
    }
    
    .loading-dots {
      font-size: 1.2rem;
    }
  }

  /* 캐릭터 검색 폼 스타일 */
  .character-search-form {
    margin-bottom: 0;
    position: relative;
    z-index: 10;
    pointer-events: auto;
  }

  .search-container {
    background: transparent;
    border: none;
    border-radius: 0;
    padding: 0;
  }

  .search-row {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .search-row-first {
    display: flex;
    gap: 0.75rem;
    margin-bottom: 0.5rem;
  }

  .search-row-second {
    display: flex;
    gap: 0.75rem;
  }

  /* 종족 선택 버튼 스타일 */
  .race-button {
    padding: 0.5rem 1rem;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s ease;
    border: 1px solid;
  }

  .race-button.active {
    font-weight: 600 !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
    transform: scale(1.02) !important;
  }
  
  /* 전체 버튼 active 스타일 */
  #race-all.race-button.active {
    background: rgba(148, 163, 184, 0.5) !important;
    border: 2px solid rgba(255, 255, 255, 1) !important;
    color: #f1f5f9 !important;
  }
  
  /* 천족 버튼 active 스타일 */
  #race-elyos.race-button.active {
    background: rgba(59, 130, 246, 1) !important;
    border: 2px solid rgba(255, 255, 255, 1) !important;
    color: #ffffff !important;
  }
  
  /* 마족 버튼 active 스타일 */
  #race-asmodian.race-button.active {
    background: rgba(239, 68, 68, 1) !important;
    border: 2px solid rgba(255, 255, 255, 1) !important;
    color: #ffffff !important;
  }

  .race-button:not(.active) {
    opacity: 0.4;
    border-width: 2px !important;
    background: rgba(0, 0, 0, 0.2) !important;
  }
  
  /* 전체 버튼 비활성화 상태 - 더 밝게 */
  #race-all.race-button:not(.active) {
    background: rgba(148, 163, 184, 0.3) !important;
    border-color: rgba(148, 163, 184, 0.6) !important;
    color: rgba(241, 245, 249, 0.85) !important;
  }
  
  /* 천족 버튼 비활성화 상태 - 더 밝게 */
  #race-elyos.race-button:not(.active) {
    background: rgba(59, 130, 246, 0.3) !important;
    border-color: rgba(59, 130, 246, 0.6) !important;
    color: rgba(191, 219, 254, 0.9) !important;
  }
  
  /* 마족 버튼 비활성화 상태 - 더 밝게 */
  #race-asmodian.race-button:not(.active) {
    background: rgba(239, 68, 68, 0.3) !important;
    border-color: rgba(239, 68, 68, 0.6) !important;
    color: rgba(254, 202, 202, 0.9) !important;
  }
  
  .race-button:not(.active):hover {
    opacity: 1;
    transform: scale(1.01);
    border-color: rgba(255, 255, 255, 0.4) !important;
  }

  /* ===== 검색 입력 필드 개선 ===== */
  .search-select {
    flex: 1;
    min-width: 150px;
    padding: 0.9rem 1.2rem;
    border: 2px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    background: rgba(22, 27, 34, 0.8);
    color: var(--text-bright);
    font-size: 0.95rem;
    font-weight: 500;
    font-family: inherit;
    transition: all 0.2s ease;
    position: relative;
    z-index: 11;
    pointer-events: auto;
  }

  .search-input {
    flex: 1;
    min-width: 150px;
    padding: 0.9rem 1.2rem;
    border: 2px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    background: rgba(22, 27, 34, 0.8);
    color: var(--text-bright);
    font-size: 0.95rem;
    font-weight: 500;
    font-family: inherit;
    transition: all 0.2s ease;
    position: relative;
    z-index: 11;
    pointer-events: auto;
  }
  
  .search-input::placeholder {
    color: rgba(255, 255, 255, 0.4);
    font-weight: 400;
  }

  /* 다크모드에서 드롭다운 가시성 개선 */
  :root:not([data-theme="light"]) .search-select {
    background: rgba(22, 27, 34, 0.8);
    border-color: rgba(255, 255, 255, 0.15);
    color: var(--text-bright);
  }

  :root:not([data-theme="light"]) .search-select:hover {
    background: rgba(30, 35, 42, 0.9);
    border-color: rgba(167, 139, 250, 0.5);
  }

  :root:not([data-theme="light"]) .search-select:focus {
    background: rgba(30, 35, 42, 0.9);
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.2) !important;
  }

  /* 드롭다운 옵션 스타일 (다크모드) */
  :root:not([data-theme="light"]) .search-select option {
    background: rgba(22, 27, 34, 0.98);
    color: var(--text-bright);
    padding: 0.5rem;
  }

  .search-select:hover,
  .search-input:hover {
    border-color: rgba(167, 139, 250, 0.5);
    background: rgba(30, 35, 42, 0.9);
  }

  .search-input:focus,
  .search-select:focus {
    outline: none;
    border-color: var(--accent);
    background: rgba(30, 35, 42, 0.9);
    box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.2) !important;
  }

  .search-select:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* ===== 검색 버튼 개선 (필터 버튼과 동일한 스타일) ===== */
  .search-button {
    padding: 0.9rem 2rem;
    border: 2px solid rgba(255, 255, 255, 0.15);
    border-radius: 10px;
    background: rgba(22, 27, 34, 0.8);
    color: var(--text-bright);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
    position: relative;
    z-index: 11;
    pointer-events: auto;
    box-shadow: none !important;
  }

  .search-button:hover {
    background: rgba(30, 35, 42, 0.9);
    border-color: rgba(167, 139, 250, 0.5);
    color: var(--text-bright);
    transform: translateY(-2px);
    box-shadow: none !important;
  }

  .search-button:active {
    transform: translateY(0);
  }

  .search-button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
    box-shadow: none !important;
  }

  /* 전투력 랭킹 탭 스타일 */
  .ranking-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  /* 직업 필터는 서버 필터와 같은 스타일로, 최대 2줄 */
  #ranking-job-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  
  #ranking-job-filters .ranking-filter-btn {
    flex: 0 0 auto;
  }

  /* ===== 필터 버튼 개선 ===== */
  .ranking-filter-btn {
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    background: rgba(22, 27, 34, 0.8);
    color: rgba(255, 255, 255, 0.85);
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    flex: 0 0 auto;
  }
  
  .ranking-filter-btn:hover {
    border-color: rgba(167, 139, 250, 0.5);
    background: rgba(30, 35, 42, 0.9);
    color: var(--text-bright);
  }

  .ranking-filter-btn.active {
    border-color: var(--accent);
    background: rgba(167, 139, 250, 0.2);
    color: var(--purple-light);
    font-weight: 600;
    box-shadow: 0 0 20px rgba(167, 139, 250, 0.3) !important;
  }

  .ranking-server-tab-btn {
    padding: 0.6rem 1.2rem;
    border-radius: 8px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    background: rgba(22, 27, 34, 0.8);
    color: rgba(255, 255, 255, 0.85);
    font-weight: 500;
    cursor: pointer;
    font-size: 0.95rem;
    transition: all 0.2s ease;
  }
  
  .ranking-server-tab-btn:hover {
    border-color: rgba(167, 139, 250, 0.5);
    background: rgba(30, 35, 42, 0.9);
    color: var(--text-bright);
  }
  
  .ranking-server-tab-btn.active {
    border-color: var(--accent);
    background: rgba(167, 139, 250, 0.2);
    color: var(--purple-light);
    font-weight: 600;
  }

  #ranking-container {
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    overflow-y: visible;
    -webkit-overflow-scrolling: touch;
    position: relative;
    box-sizing: border-box;
  }

  /* ===== 테이블 스타일 개선 ===== */
  .ranking-list {
    width: 100%;
    max-width: 100%;
    border-collapse: collapse;
    font-size: 1rem;
    table-layout: auto;
    box-sizing: border-box;
  }

  .ranking-list th,
  .ranking-list td {
    padding: 1rem 0.75rem;
    text-align: left;
    white-space: nowrap;
  }

  .ranking-list .col-power {
    text-align: right;
    font-weight: 700;
    color: var(--text-bright);
  }

  .ranking-list td.col-nickname {
    color: var(--text-bright);
    font-weight: 600;
  }

  .ranking-list td.col-nickname a,
  .ranking-list td.col-nickname .nickname-link {
    color: var(--text-bright) !important;
    font-weight: 600;
    text-decoration: none;
    transition: color 0.2s ease;
  }
  
  .ranking-list td.col-nickname a:hover,
  .ranking-list td.col-nickname .nickname-link:hover {
    color: var(--purple-light) !important;
  }

  .ranking-list th {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--purple-light);
    border-bottom: 2px solid rgba(167, 139, 250, 0.3);
    padding: 1rem 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .ranking-list tbody tr {
    background: rgba(255, 255, 255, 0.02);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    transition: all 0.2s ease;
  }

  .ranking-list tbody tr:hover {
    background: rgba(167, 139, 250, 0.15);
    transform: scale(1.01);
  }

  .ranking-position {
    font-weight: 700;
    font-size: 1.1rem;
    color: var(--purple-light);
  }

  /* 페이지네이션 스타일 - 모던하고 세련된 디자인 */
  .pagination-btn {
    min-width: 32px;
    height: 32px;
    padding: 0.4rem 0.7rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    background: rgba(15, 23, 42, 0.6);
    color: var(--text-primary);
    font-size: 0.75rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  
  /* 모바일 반응형 */
  @media (max-width: 768px) {
    .pagination-btn {
      min-width: 28px;
      height: 28px;
      padding: 0.3rem 0.5rem;
      font-size: 0.7rem;
      border-radius: 6px;
    }
  }

  .pagination-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(157, 140, 255, 0.1), rgba(236, 72, 153, 0.1));
    opacity: 0;
    transition: opacity 0.25s ease;
  }

  .pagination-btn:hover:not(:disabled)::before {
    opacity: 1;
  }

  .pagination-btn:hover:not(:disabled) {
    border-color: rgba(157, 140, 255, 0.5);
    color: var(--accent);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(157, 140, 255, 0.2);
  }

  .pagination-btn:active:not(:disabled) {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(157, 140, 255, 0.15);
  }

  .pagination-btn.active {
    background: linear-gradient(135deg, rgba(157, 140, 255, 0.3), rgba(236, 72, 153, 0.25));
    border-color: rgba(157, 140, 255, 0.7);
    color: #ffffff;
    box-shadow: 0 4px 16px rgba(157, 140, 255, 0.4);
    font-weight: 600;
  }

  .pagination-btn.active::before {
    opacity: 1;
    background: linear-gradient(135deg, rgba(157, 140, 255, 0.2), rgba(236, 72, 153, 0.15));
  }

  .pagination-btn:disabled {
    opacity: 0.35;
    cursor: not-allowed;
    background: rgba(15, 23, 42, 0.3);
    border-color: rgba(255, 255, 255, 0.05);
  }

  .pagination-info {
    color: var(--text-muted);
    font-size: 0.8rem;
    padding: 0.4rem 0.7rem;
    display: inline-flex;
    align-items: center;
    font-weight: 500;
  }
  
  /* 페이지네이션 컨테이너 */
  .pagination-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    justify-content: center;
    align-items: center;
  }
  
  /* 모바일 반응형 */
  @media (max-width: 768px) {
    .pagination-info {
      font-size: 0.65rem;
      padding: 0.25rem 0.4rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }
    
    .pagination-container {
      gap: 0.3rem;
      padding: 0.5rem;
    }
  }

  /* 캐릭터 아바타 이미지 스타일 */
  #result-avatar-container {
    transition: transform 0.3s ease;
    position: relative;
  }

  #result-avatar-container:hover {
    transform: scale(1.05);
  }

  /* 장비 아이템 스타일 - 더 작고 컴팩트하게 */
  .equipment-item {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
    padding: 0.75rem; /* 0.5rem * 1.5 = 0.75rem */
    margin-bottom: 0.5rem; /* 아이템 간 간격 추가로 겹침 방지 */
    border-radius: 6px;
    background: rgba(4, 7, 25, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.08);
    transition: background 0.2s ease, border-color 0.2s ease;
    width: 100%; /* 전체 너비 사용 */
    max-width: 100%;
    box-sizing: border-box; /* padding 포함한 너비 계산 */
    position: relative;
    clear: both;
    overflow: visible;
  }

  /* 서버 통계 헤더(천족/마족) */
  .server-stat-header {
    font-size: 1.02rem;
    font-weight: 700;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 0.1rem;
    line-height: 1.2;
  }

  .server-stat-header-label {
    letter-spacing: 0.04em;
  }

  .server-stat-header-count {
    font-size: 0.87rem;
    font-weight: 500;
    opacity: 0.9;
  }

  .server-stat-header--elyos {
    color: #60a5fa;
  }

  .server-stat-header--asmodian {
    color: #f97373;
  }

  .equipment-item:hover {
    background: rgba(4, 7, 25, 0.5);
    border-color: rgba(157, 140, 255, 0.3);
  }

  /* 라이트 모드에서 장비 아이템 카드 색상 통일 */
  :root[data-theme="light"] .equipment-item {
    background: rgba(244, 244, 255, 0.5);
    border-color: rgba(0, 0, 0, 0.06);
  }

  :root[data-theme="light"] .equipment-item:hover {
    background: rgba(244, 244, 255, 0.7);
    border-color: rgba(124, 58, 237, 0.3);
  }
  
  .equipment-item-content {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 1;
  }
  
  .equipment-item-stats {
    flex: 1;
    display: flex;
    flex-direction: row;
    gap: 0.5rem;
    font-size: 0.7rem;
    color: var(--text-secondary);
    margin-left: 0;
  }
  
  .equipment-stat-line {
    display: flex;
    gap: 0.5rem;
  }
  
  .equipment-stat-label {
    color: var(--text-muted);
    min-width: 60px;
  }
  
  .equipment-stat-value {
    color: #4a90e2;
    font-weight: 500;
  }

  .equipment-item-icon {
    width: 32px;
    height: 32px;
    border-radius: 4px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    flex-shrink: 0;
  }

  .equipment-item-icon img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .equipment-item-name {
    flex: 1;
    font-size: 0.75rem;
    font-weight: 500;
    line-height: 1.3;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  /* 장비 섹션 최대 높이 제한 (스크롤 가능) - 항상 스크롤바 표시 */
  #equipment-container,
  #accessories-container {
    max-height: 800px;
    min-height: 200px;
    height: auto;
    overflow-y: scroll !important; /* 항상 스크롤바 표시 */
    overflow-x: hidden;
    padding-right: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 0;
    width: 100%;
    box-sizing: border-box;
  }
  
  #arcana-container {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 0.5rem;
  }
  
  .arcana-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
    padding: 0.5rem;
    border-radius: 6px;
    background: rgba(4, 7, 25, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.08);
    transition: background 0.2s ease, border-color 0.2s ease;
    min-width: 80px;
  }
  
  .arcana-item:hover {
    background: rgba(4, 7, 25, 0.5);
    border-color: rgba(157, 140, 255, 0.3);
  }
  
  .arcana-item-icon {
    width: 48px;
    height: 48px;
    border-radius: 4px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.05);
  }
  
  .arcana-item-icon img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  .arcana-item-name {
    font-size: 0.7rem;
    font-weight: 500;
    text-align: center;
    color: var(--text-primary);
    line-height: 1.2;
  }
  
  /* 아르카나 아이템 오버레이 툴팁 */
  .arcana-item {
    position: relative;
    cursor: pointer;
  }
  
  .arcana-tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-bottom: 0.5rem;
    z-index: 1000;
    display: none;
    min-width: 280px;
    max-width: 350px;
    background: rgba(15, 23, 42, 0.98);
    border: 1px solid rgba(157, 140, 255, 0.3);
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    pointer-events: none;
  }
  
  .arcana-item:hover .arcana-tooltip {
    display: block;
  }
  
  .arcana-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid rgba(15, 23, 42, 0.98);
  }
  
  .arcana-tooltip-section {
    margin-bottom: 0.75rem;
  }
  
  .arcana-tooltip-section:last-child {
    margin-bottom: 0;
  }
  
  .arcana-tooltip-section-title {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accent);
    margin-bottom: 0.5rem;
  }
  
  .arcana-tooltip-stat {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    color: var(--text-primary);
    margin-bottom: 0.25rem;
  }
  
  .arcana-tooltip-stat-name {
    color: var(--text-secondary);
  }
  
  .arcana-tooltip-stat-value {
    color: var(--text-primary);
    font-weight: 500;
  }
  
  .arcana-tooltip-skill {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
    color: var(--text-primary);
    margin-bottom: 0.4rem;
  }
  
  .arcana-tooltip-skill-icon {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    flex-shrink: 0;
  }
  
  .arcana-tooltip-skill-name {
    flex: 1;
    color: var(--text-primary);
  }
  
  .arcana-tooltip-skill-level {
    color: var(--accent);
    font-weight: 600;
    font-size: 0.75rem;
  }
  
  /* 라이트 모드에서 아르카나 아이템 카드 색상 통일 */
  :root[data-theme="light"] .arcana-item {
    background: rgba(244, 244, 255, 0.5);
    border-color: rgba(0, 0, 0, 0.06);
  }
  
  :root[data-theme="light"] .arcana-item:hover {
    background: rgba(244, 244, 255, 0.7);
    border-color: rgba(124, 58, 237, 0.3);
  }
  
  :root[data-theme="light"] .arcana-tooltip {
    background: rgba(255, 255, 255, 0.98);
    border-color: rgba(124, 58, 237, 0.3);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  }
  
  :root[data-theme="light"] .arcana-tooltip::after {
    border-top-color: rgba(255, 255, 255, 0.98);
  }
  
  /* 모바일에서 아르카나 툴팁 위치 조정 */
  @media (max-width: 768px) {
    .arcana-tooltip {
      min-width: 240px;
      max-width: calc(100vw - 2rem);
      left: auto;
      right: 0;
      transform: none;
    }
    
    .arcana-tooltip::after {
      left: auto;
      right: 1rem;
      transform: none;
    }
    
    /* 오른쪽 끝에 붙어있을 때는 왼쪽으로 조정 */
    .arcana-item:last-child .arcana-tooltip,
    .arcana-item:nth-last-child(2) .arcana-tooltip {
      left: 0;
      right: auto;
    }
    
    .arcana-item:last-child .arcana-tooltip::after,
    .arcana-item:nth-last-child(2) .arcana-tooltip::after {
      left: 1rem;
      right: auto;
    }
  }
  
  /* 캐릭터 정보 탭 스타일 */
  .character-info-tabs {
    margin-top: 1.5rem;
  }
  
  .character-tab-controls {
    display: inline-flex;
    gap: 0.25rem;
    padding: 0.35rem;
    border-radius: 10px 10px 0 0;
    background: rgba(15, 23, 42, 0.85);
    border: 1px solid rgba(148, 163, 184, 0.25);
    border-bottom: none;
    margin-bottom: 0;
    position: relative;
  }
  
  .character-tab-btn {
    padding: 0.55rem 1.4rem;
    border: none;
    background: transparent;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 600;
    border-radius: 8px;
    transition: all 0.2s;
  }
  
  .character-tab-btn:hover {
    color: var(--text-primary);
    background: rgba(15, 23, 42, 0.35);
  }
  
  .character-tab-btn.active {
    color: #0f172a;
    background: #f97316;
    box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9), 0 8px 18px rgba(15, 23, 42, 0.85);
  }
  
  .character-tab-panel {
    display: none;
  }
  
  .character-tab-panel.active {
    display: block;
  }

  .character-tab-card {
    margin-top: 0;
    padding: 1.5rem 1.75rem;
    border-radius: 0 14px 14px 14px;
    background: rgba(15, 23, 42, 0.9);
    border: 1px solid rgba(148, 163, 184, 0.35);
    box-shadow: 0 18px 45px rgba(15, 23, 42, 0.9);
  }
  
  /* 데바니온 서브탭 스타일 */
  .daevanion-subtabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
  }
  
  .daevanion-subtab-btn {
    padding: 0.5rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.04);
    color: var(--text-muted);
    cursor: pointer;
    border-radius: 8px;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s;
  }
  
  .daevanion-subtab-btn:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(157, 140, 255, 0.2);
  }
  
  .daevanion-subtab-btn.active {
    background: rgba(157, 140, 255, 0.12);
    border-color: rgba(157, 140, 255, 0.3);
    color: var(--accent);
  }
  
  /* 라이트 모드에서 탭 스타일 */
  :root[data-theme="light"] .character-tab-controls {
    border-bottom-color: rgba(0, 0, 0, 0.1);
  }
  
  :root[data-theme="light"] .character-tab-btn:hover {
    background: rgba(0, 0, 0, 0.02);
  }
  
  :root[data-theme="light"] .daevanion-subtab-btn {
    background: rgba(244, 244, 255, 0.5);
    border-color: rgba(0, 0, 0, 0.06);
  }
  
  :root[data-theme="light"] .daevanion-subtab-btn:hover {
    background: rgba(244, 244, 255, 0.7);
    border-color: rgba(124, 58, 237, 0.2);
  }
  
  :root[data-theme="light"] .daevanion-subtab-btn.active {
    background: rgba(124, 58, 237, 0.1);
    border-color: rgba(124, 58, 237, 0.3);
  }
  
  /* 빈 상태 메시지도 작게 */
  #equipment-container > div[style*="text-align: center"],
  #accessories-container > div[style*="text-align: center"] {
    padding: 0.5rem !important;
    font-size: 0.75rem !important;
  }
  
  /* 스크롤바 스타일링 */
  #equipment-container::-webkit-scrollbar,
  #accessories-container::-webkit-scrollbar {
    width: 6px;
  }
  
  #equipment-container::-webkit-scrollbar-track,
  #accessories-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
  }
  
  #equipment-container::-webkit-scrollbar-thumb,
  #accessories-container::-webkit-scrollbar-thumb {
    background: rgba(157, 140, 255, 0.3);
    border-radius: 3px;
  }
  
  #equipment-container::-webkit-scrollbar-thumb:hover,
  #accessories-container::-webkit-scrollbar-thumb:hover {
    background: rgba(157, 140, 255, 0.5);
  }
  
  /* 모바일에서 1컬럼으로 변경 - 640px 이하만 (640~770px은 별도 처리) */
  @media (max-width: 639px) {
    #equipment-two-column {
      grid-template-columns: 1fr !important;
      display: flex !important;
      flex-direction: column !important;
      gap: 2rem !important;
      align-items: stretch !important;
    }

    #equipment-column {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      order: 1 !important;
      margin-bottom: 1rem !important;
    }

    #accessories-column {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      order: 2 !important;
      margin-top: 1rem !important;
    }

    #equipment-container,
    #accessories-container {
      display: flex !important;
      flex-direction: column !important;
      gap: 0.25rem !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      max-height: 600px !important;
      min-height: 200px !important;
      height: auto !important;
      overflow-y: scroll !important; /* 항상 스크롤바 표시 */
      overflow-x: hidden !important;
      padding-right: 0.25rem !important;
      position: relative !important;
    }
    
    /* 스크롤바가 보이도록 강제 */
    #equipment-container::-webkit-scrollbar,
    #accessories-container::-webkit-scrollbar {
      width: 6px !important;
      display: block !important;
    }
  }

  /* 전체 서버 검색 결과 카드 반응형 스타일 */
  #character-all-servers-result {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }
  
  #all-servers-result-list {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.8rem;
  }
  
  @media (max-width: 770px) {
    #character-all-servers-result {
      margin-bottom: 1rem;
      width: 100%;
      max-width: 100%;
    }
    
    #all-servers-result-list {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }
    
    .character-search-card {
      padding: 0.5rem !important;
      gap: 0.5rem !important;
    }
    
    .character-search-card img,
    .character-search-card > div:first-child {
      width: 50px !important;
      height: 75px !important;
    }
    
    .character-search-card > div:last-child {
      font-size: 0.65rem !important;
    }
    
    .character-search-card > div:last-child > div:first-child {
      font-size: 0.8rem !important;
    }
  }
  
  @media (max-width: 480px) {
    #all-servers-result-list {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.4rem;
    }
  }

  /* 특정 너비 범위(640px~770px)에서만 세로 배치로 변경 */
  @media (min-width: 640px) and (max-width: 770px) {
    #equipment-two-column,
    #equipment-two-column.force-column-layout,
    #equipment-two-column[data-layout="column"] {
      grid-template-columns: 1fr !important;
      display: flex !important;
      flex-direction: column !important;
      gap: 2rem !important;
      align-items: stretch !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }

    #equipment-column {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      order: 1 !important;
      margin-bottom: 1rem !important;
      flex: none !important;
      min-width: 0 !important;
      position: relative !important;
      clear: both !important;
    }

    #accessories-column {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      order: 2 !important;
      margin-top: 1rem !important;
      flex: none !important;
      min-width: 0 !important;
      position: relative !important;
      clear: both !important;
    }

    #equipment-container,
    #accessories-container {
      display: flex !important;
      flex-direction: column !important;
      gap: 0.25rem !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      min-width: 0 !important;
      max-height: 600px !important;
      min-height: 200px !important;
      height: auto !important;
      overflow-y: scroll !important; /* 항상 스크롤바 표시 */
      overflow-x: hidden !important;
      padding-right: 0.25rem !important;
    }
  }
  
  /* 강제 세로 배치 클래스 */
  #equipment-two-column.force-column-layout,
  #equipment-two-column[data-layout="column"] {
    display: flex !important;
    flex-direction: column !important;
    gap: 2rem !important;
    align-items: stretch !important;
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
  }
  
  #equipment-two-column.force-column-layout #equipment-column,
  #equipment-two-column[data-layout="column"] #equipment-column {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    order: 1 !important;
    margin-bottom: 1rem !important;
    flex: none !important;
    min-width: 0 !important;
    position: relative !important;
    clear: both !important;
  }
  
  #equipment-two-column.force-column-layout #accessories-column,
  #equipment-two-column[data-layout="column"] #accessories-column {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    order: 2 !important;
    margin-top: 1rem !important;
    flex: none !important;
    min-width: 0 !important;
    position: relative !important;
    clear: both !important;
  }

  /* 등급에 따른 텍스트 색상 */
  .equipment-item-name.grade-normal {
    color: #a0a0a0; /* 회색 */
  }

  .equipment-item-name.grade-rare {
    color: #4a90e2; /* 파란색 */
  }

  .equipment-item-name.grade-heroic {
    color: #ff7a00; /* 주황색 */
  }

  .equipment-item-name.grade-legendary {
    color: #ff7a00; /* 주황색 */
  }

  .equipment-item-name.grade-mythic {
    color: #ff7a00; /* 주황색 */
  }

  .equipment-item-name.grade-epic {
    color: #FF6B35; /* 빨간색에 가까운 주황색 */
  }

  .equipment-item-name.grade-unknown {
    color: #ff7a00; /* 기본값: 주황색 */
  }

  /* 강화 수치는 JavaScript에서 직접 추가하므로 여기서는 제거 */

  /* 스킬 아이템 스타일 */
  .skill-item {
    position: relative;
    border-radius: 8px;
    overflow: visible;
    background: rgba(4, 7, 25, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: transform 0.2s ease, border-color 0.2s ease;
    display: flex;
    flex-direction: column;
  }
  
  .skill-item .skill-icon-wrapper {
    position: relative;
    width: 100%;
    aspect-ratio: 1;
    overflow: hidden;
    border-radius: 8px;
  }
  
  /* 스킬 우선순위 배지 */
  .skill-priority-badge {
    position: absolute;
    top: 4px;
    left: 4px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-size: 0.7rem;
    font-weight: 700;
    min-width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 4px;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
    z-index: 10;
    border: 1.5px solid rgba(255, 255, 255, 0.3);
  }
  
  .skill-priority-badge:hover {
    transform: scale(1.1);
    box-shadow: 0 3px 8px rgba(102, 126, 234, 0.6);
  }

  .skill-item:hover {
    transform: translateY(-2px);
    border-color: rgba(157, 140, 255, 0.5);
    box-shadow: 0 4px 12px rgba(157, 140, 255, 0.3);
  }
  
  .skill-item:hover .skill-name {
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.98), rgba(0, 0, 0, 0.85));
  }
  
  .skill-item:hover .skill-level {
    background: linear-gradient(to top, rgba(0, 0, 0, 0.98), rgba(0, 0, 0, 0.8));
    color: #ffed4e;
  }

  .skill-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .skill-item .skill-level {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.7));
    color: #ffd700;
    font-size: 0.75rem;
    font-weight: 700;
    padding: 0.3rem 0.4rem;
    text-align: center;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9), 
                 0 0 8px rgba(0, 0, 0, 0.8),
                 0 0 2px rgba(0, 0, 0, 1);
    letter-spacing: 0.02em;
  }

  /* 스킬 이름 표시 (아이콘 위에 오버레이) */
  .skill-item .skill-name {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.75));
    color: #ffffff;
    font-size: 0.7rem;
    font-weight: 700;
    padding: 0.25rem 0.35rem;
    text-align: center;
    line-height: 1.3;
    word-break: break-word;
    overflow: hidden;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.9), 
                 0 0 8px rgba(0, 0, 0, 0.8),
                 0 0 2px rgba(0, 0, 0, 1);
    letter-spacing: 0.01em;
  }

  /* 스킬 채용률 순위 배지 (별표) - 아이콘 위 별도 공간 */
  .skill-item .skill-rank-badge {
    position: absolute;
    top: -1.3rem;
    left: 50%;
    transform: translateX(-50%);
    color: #ffd700;
    font-size: 0.65rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(255, 215, 0, 0.6);
    pointer-events: none;
    line-height: 1;
    letter-spacing: 0.05em;
    height: 1.2rem;
    width: 100%;
  }
  
  /* 모바일 최적화 */
  @media (max-width: 768px) {
    .skill-item .skill-name {
      font-size: 0.65rem;
      padding: 0.2rem 0.3rem;
    }
    
    .skill-item .skill-level {
      font-size: 0.7rem;
      padding: 0.25rem 0.35rem;
    }
    
    .skill-item .skill-rank-badge {
      font-size: 0.6rem;
      top: -1.2rem;
    }
  }
  
  @media (max-width: 480px) {
    .skill-item .skill-name {
      font-size: 0.6rem;
      padding: 0.15rem 0.25rem;
      line-height: 1.2;
    }
    
    .skill-item .skill-level {
      font-size: 0.65rem;
      padding: 0.2rem 0.3rem;
    }
  }

  /* 스킬 툴팁 스타일 */
  .skill-tooltip {
    position: absolute;
    bottom: calc(100% + 10px);
    left: 50%;
    transform: translateX(-50%);
    background: rgba(9, 16, 37, 0.98);
    border: 1px solid rgba(157, 140, 255, 0.3);
    border-radius: 8px;
    padding: 0.75rem;
    min-width: 250px;
    max-width: 350px;
    z-index: 1000;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 0.85rem;
    line-height: 1.5;
    white-space: normal;
    word-wrap: break-word;
  }

  .skill-item:hover .skill-tooltip {
    opacity: 1;
  }

  /* 스킬 통계 탭 툴팁 */
  .skill-stats-item .skill-tooltip {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
    z-index: 1000;
  }

  .skill-stats-item:hover .skill-tooltip {
    opacity: 1;
  }

  .skill-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: rgba(157, 140, 255, 0.3);
  }

  .skill-tooltip::before {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 7px solid transparent;
    border-top-color: rgba(9, 16, 37, 0.98);
    margin-top: -1px;
  }

  .skill-tooltip-title {
    font-weight: 600;
    color: var(--accent);
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }

  .skill-tooltip-description {
    color: var(--text-primary);
    margin-bottom: 0.5rem;
  }

  .skill-tooltip-notes {
    color: var(--text-muted);
    font-size: 0.75rem;
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .skill-tooltip-level {
    color: var(--text-muted);
    font-size: 0.8rem;
    margin-bottom: 0.5rem;
  }

  .skill-tooltip-special-info {
    color: #ef4444;
    font-size: 0.85rem;
    margin-top: 0.5rem;
    line-height: 1.5;
  }

  /* 스킬 카테고리 카드 */
  .skill-category-card {
    background: rgba(4, 7, 25, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.4);
    border-radius: 12px;
    padding: 1rem;
    transition: border-color 0.2s ease, background 0.2s ease;
  }

  .skill-category-card:hover {
    border-color: rgba(157, 140, 255, 0.3);
    background: rgba(4, 7, 25, 0.4);
  }

  .skill-category-header {
    font-size: 0.95rem;
    color: var(--accent);
    margin-bottom: 1.5rem;
    font-weight: 600;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid rgba(157, 140, 255, 0.2);
  }

  /* 주신 스탯 컨테이너 기본 스타일 (데스크톱: 5열) */
  #stats-container {
    display: grid !important;
    grid-template-columns: repeat(5, 1fr) !important;
    grid-auto-rows: 1fr !important;
    gap: 0.4rem !important;
  }

  /* 스탯 카드 스타일 */
  .stat-card {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 8px;
    padding: 0.75rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: transform 0.2s ease, border-color 0.2s ease;
    width: 100% !important;
    min-width: 0 !important;
    box-sizing: border-box !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: center !important;
  }

  .stat-card:hover {
    transform: translateY(-2px);
    border-color: rgba(157, 140, 255, 0.3);
    background: rgba(255, 255, 255, 0.05);
  }

  .stat-card .stat-name {
    font-weight: 600;
    color: var(--accent);
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }

  .stat-card .stat-level {
    font-size: 0.75rem;
    color: rgba(157, 140, 255, 0.9);
    margin-bottom: 0.5rem;
    font-weight: 500;
  }

  .stat-card .stat-effects {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .stat-card .stat-effect-item {
    font-size: 0.75rem;
    color: var(--text-primary);
    line-height: 1.4;
  }

  /* 일반 스탯 카드 스타일 (3열 그리드) */
  .normal-stat-card {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 8px;
    padding: 0.75rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transition: transform 0.2s ease, border-color 0.2s ease;
    box-sizing: border-box;
  }

  .normal-stat-card:hover {
    transform: translateY(-2px);
    border-color: rgba(157, 140, 255, 0.3);
    background: rgba(255, 255, 255, 0.05);
  }

  /* 일반 스탯 카드 내부 요소 스타일 통일 */
  .normal-stat-card .stat-name {
    font-weight: 600;
    color: var(--accent);
    margin-bottom: 0.5rem;
    font-size: 0.9rem;
  }

  .normal-stat-card .stat-level {
    font-size: 0.75rem;
    color: rgba(157, 140, 255, 0.9);
    margin-bottom: 0.5rem;
    font-weight: 500;
  }

  .normal-stat-card .stat-effects {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .normal-stat-card .stat-effect-item {
    font-size: 0.75rem;
    color: var(--text-primary);
    line-height: 1.4;
  }

  /* 모바일 반응형 */
  @media (max-width: 768px) {
    .stat-card {
      width: 100% !important;
      max-width: none !important;
    }
    
    /* 주신 스탯 컨테이너 2열 강제 (모바일만) */
    #stats-container {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.4rem !important;
    }
    
    .stat-card {
      min-height: 120px !important;
      width: 100% !important;
      min-width: 0 !important;
    }
    
    #normal-stats-container {
      grid-template-columns: repeat(2, 1fr) !important; /* 모바일에서는 2열 */
    }
  }

  /* 전체 추천 스킬 보기 버튼 */
  .skill-recommend-button {
    padding: 0.5rem 1.1rem;
    background: linear-gradient(135deg, #6366f1 0%, #ec4899 100%);
    border: none;
    border-radius: 999px;
    color: #ffffff;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.18s ease;
    text-align: center;
    white-space: nowrap;
    box-shadow: 0 8px 20px rgba(79, 70, 229, 0.45);
  }

  /* 내 캐릭터랑 비교 버튼 */
  .compare-with-mine-button {
    padding: 0.6rem 1.4rem;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(226, 232, 240, 0.96) 100%);
    border: none;
    border-radius: 999px;
    color: #1e293b;
    font-size: 0.85rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.18s ease;
    text-align: center;
    white-space: nowrap;
    box-shadow: 0 10px 26px rgba(15, 23, 42, 0.55);
  }

  .compare-with-mine-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 14px 32px rgba(15, 23, 42, 0.7);
    opacity: 0.98;
  }

  .compare-with-mine-button:active {
    transform: translateY(0);
    box-shadow: 0 6px 18px rgba(15, 23, 42, 0.75);
  }

  .skill-recommend-button:hover {
    transform: translateY(-1px);
    box-shadow: 0 10px 26px rgba(79, 70, 229, 0.6);
    opacity: 0.95;
  }

  .skill-recommend-button:active {
    transform: translateY(0);
    box-shadow: 0 4px 14px rgba(15, 23, 42, 0.7);
  }

  /* 이미지가 없을 때 뱃지 위치 조정 */
  #result-avatar-container:not(:has(img[src])) .badge {
    position: static;
    transform: none;
    margin-bottom: 0.5rem;
  }

  @media (max-width: 768px) {
    .main-layout {
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .sidebar-banner {
      order: 3;
      width: 100%;
    }

    .main-content {
      order: 1;
    }

    .card-grid {
      grid-template-columns: minmax(0, 1fr);
    }

    .dashboard,
    .hero-card {
      padding: 1.5rem;
      border-radius: 20px;
    }

    .tab-controls {
      justify-content: flex-start;
      overflow-x: auto;
      padding-bottom: 0.25rem;
    }

    .tab-controls label {
      font-size: 0.85rem;
      padding: 0.5rem 1rem;
      flex: 0 0 auto;
    }

    .search-row,
    .search-row-first,
    .search-row-second {
      flex-direction: column;
      width: 100%;
    }

    /* ===== 모바일 입력 필드 및 버튼 개선 ===== */
    .search-select,
    .search-input {
      width: 100%;
      min-width: 0;
      font-size: 1rem !important;
      padding: 1rem 1.2rem !important;
      border-width: 2px !important;
    }
    
    .search-button {
      width: 100%;
      min-width: 0;
      font-size: 1.1rem !important;
      padding: 1.1rem 2rem !important;
      font-weight: 700 !important;
    }

    .ranking-filters {
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .character-tab-controls {
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 0.5rem;
      padding-bottom: 0.5rem;
    }
    
    .character-tab-btn {
      flex: 0 0 auto;
      white-space: nowrap;
      min-width: fit-content;
    }
    
    .daevanion-subtabs {
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .ranking-filters {
      overflow: visible;
      padding-bottom: 0;
      width: 100%;
    }

    .ranking-filter-btn {
      flex: 0 0 auto;
      min-width: 0;
      text-align: center;
      padding: 0.7rem 1rem !important;
      font-size: 0.9rem !important;
      font-weight: 600 !important;
    }
    
    /* 모바일 badge 개선 */
    .badge {
      font-size: 1.05rem !important;
      padding: 0.7rem 1.2rem !important;
    }
    
    /* 모바일 hero-card 개선 */
    .hero-card {
      padding: 1.2rem !important;
    }

    /* 직업 필터는 최대 2줄로 제한 */
    #ranking-job-filters {
      max-height: none;
      overflow: visible;
    }

    /* 통계 탭 모바일 최적화 - 스크롤 허용 */
    #panel-statistics {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      overflow-y: visible !important;
      box-sizing: border-box !important;
      position: relative !important;
      top: 0 !important;
      left: 0 !important;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      transform: none !important;
      z-index: auto !important;
    }

    #panel-statistics .card-grid {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      overflow-y: visible !important;
      box-sizing: border-box !important;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      position: relative !important;
      top: 0 !important;
      transform: none !important;
    }

    #panel-statistics .hero-card {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      overflow-y: visible !important;
      box-sizing: border-box !important;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      position: relative !important;
      top: 0 !important;
      transform: none !important;
    }

    #panel-statistics .hero-card > div {
      overflow-y: visible !important;
      overflow-x: visible !important;
      position: relative !important;
      top: 0 !important;
      transform: none !important;
      margin-top: 0 !important;
      padding-top: 0 !important;
      min-height: auto !important;
      height: auto !important;
      max-height: none !important;
    }
    
    /* 아이템 통계 컨텐츠 모바일에서도 잘리지 않도록 */
    #item-statistics-content {
      overflow: visible !important;
      min-height: auto !important;
      height: auto !important;
      max-height: none !important;
      display: block !important;
    }
    
    /* 통계 서브탭 버튼 모바일에서도 잘리지 않도록 */
    .statistics-sub-tabs {
      overflow: visible !important;
      flex-wrap: wrap !important;
      display: flex !important;
    }
    
    /* 아이템 통계 컨테이너 모바일에서도 잘리지 않도록 */
    #item-statistics-container {
      overflow: visible !important;
      min-height: auto !important;
      height: auto !important;
      max-height: none !important;
    }
    
    /* 모바일에서 통계 탭의 비활성화된 서브탭 내용 숨김 */
    #panel-statistics #skill-statistics-content[style*="display: none"],
    #panel-statistics #item-statistics-content[style*="display: none"] {
      display: none !important;
    }
    
    /* 모바일에서 랭킹 탭의 비활성화된 서브탭 내용 숨김 */
    #panel-ranking #internal-ranking-content[style*="display: none"],
    #panel-ranking #contents-ranking-content[style*="display: none"],
    #panel-ranking #region-ranking-content[style*="display: none"] {
      display: none !important;
    }
    
    /* 모바일에서 통계 탭: 스킬 통계와 아이템 통계는 기본적으로 숨김 */
    #panel-statistics #skill-statistics-content:not([style*="display: block"]):not([style*="display:block"]),
    #panel-statistics #item-statistics-content:not([style*="display: block"]):not([style*="display:block"]) {
      display: none !important;
    }

    /* 랭킹 테이블 모바일 최적화 - 1행으로 표시 */
    #panel-ranking {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      box-sizing: border-box !important;
      position: relative;
    }

    #panel-ranking * {
      max-width: 100%;
      box-sizing: border-box;
    }

    #panel-ranking .card-grid {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      overflow-x: hidden !important;
    }

    #panel-ranking .hero-card {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      overflow-x: hidden !important;
      padding: 1rem;
    }

    #panel-ranking .hero-card > div {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      box-sizing: border-box !important;
    }

    #ranking-container {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      box-sizing: border-box !important;
      margin: 0 !important;
      padding: 0 !important;
      position: relative;
    }

    /* ===== 모바일 테이블 가시성 개선 ===== */
    .ranking-list {
      font-size: 0.85rem;
      width: 100% !important;
      min-width: 100% !important;
      max-width: 100% !important;
      table-layout: fixed !important;
      border-collapse: collapse;
      margin: 0 !important;
      padding: 0 !important;
      box-sizing: border-box !important;
    }

    .ranking-list thead {
      display: table-header-group !important;
      width: 100% !important;
      max-width: 100% !important;
    }

    .ranking-list tbody {
      display: table-row-group !important;
      width: 100% !important;
      max-width: 100% !important;
    }

    .ranking-list tbody tr {
      display: table-row !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    .ranking-list thead tr {
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }

    .ranking-list tbody tr:nth-child(even) {
      background: rgba(255, 255, 255, 0.02);
    }

    .ranking-list th,
    .ranking-list td {
      padding: 0.4rem 0.3rem !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
      box-sizing: border-box !important;
      word-wrap: break-word !important;
    }

    .ranking-list th.col-rank,
    .ranking-list td.col-rank {
      width: 15% !important;
      min-width: 15% !important;
      max-width: 15% !important;
      font-weight: 600;
      color: var(--accent);
      text-align: center;
      box-sizing: border-box !important;
    }

    .ranking-list th.col-nickname,
    .ranking-list td.col-nickname {
      width: 40% !important;
      min-width: 40% !important;
      max-width: 40% !important;
      color: #ffffff;
      font-weight: 500;
      text-align: left;
      box-sizing: border-box !important;
    }

    .ranking-list th.col-job,
    .ranking-list td.col-job,
    .ranking-list th.col-race,
    .ranking-list td.col-race,
    .ranking-list th.col-guild,
    .ranking-list td.col-guild {
      display: none !important;
      width: 0 !important;
      min-width: 0 !important;
      max-width: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    /* 서버 컬럼은 표시 */
    .ranking-list th.col-server,
    .ranking-list td.col-server {
      display: table-cell !important;
      width: 20% !important;
      min-width: 20% !important;
      max-width: 20% !important;
      text-align: left;
      box-sizing: border-box !important;
    }

    .ranking-list th.col-power,
    .ranking-list td.col-power {
      width: 25% !important;
      min-width: 25% !important;
      max-width: 25% !important;
      text-align: right;
      font-weight: 600;
      color: var(--accent);
      box-sizing: border-box !important;
    }

    .stat-filter-row {
      flex-direction: column;
      align-items: stretch;
    }

    .stat-range-input,
    .stat-apply-button {
      width: 100%;
    }

    .dual-range {
      width: 100%;
      min-width: 0;
    }

    .character-tab-btn,
    .daevanion-subtab-btn {
      flex: 1 1 140px;
    }

    #equipment-two-column {
      grid-template-columns: 1fr;
    }

    /* 이 부분은 아래 랭킹 테이블 모바일 최적화 섹션에서 처리 */

    /* 모바일에서 아바타 이미지 크기 조정 */
    #result-avatar {
      width: 80px !important;
      height: 80px !important;
    }

    /* 모바일에서 아바타와 닉네임 세로 배치 */
    #character-result .hero-card > div:first-child {
      flex-direction: column;
      align-items: flex-start;
      gap: 1rem;
    }

    /* 모바일에서 뱃지 위치 조정 */
    #result-avatar-container .badge {
      position: static;
      transform: none;
      margin-bottom: 0.5rem;
    }

    /* 모바일에서 스탯 카드 레이아웃 */
    #character-result .hero-stats {
      grid-template-columns: 1fr !important;
    }

    /* 모바일에서 캐릭터 검색 결과 영역 overflow 방지 - 모든 하위 요소 포함 */
    #character-result,
    #character-result *,
    #character-result .hero-card,
    #character-result .hero-card * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
    }

    /* 캐릭터 정보 탭 전체 영역 */
    .character-info-tabs,
    .character-info-tabs *,
    .character-tab-controls,
    .character-tab-controls *,
    .character-tab-panel,
    .character-tab-panel * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
    }

    /* 데바니온 탭 모바일 최적화 - 모든 하위 요소 포함 */
    #panel-daevanion,
    #panel-daevanion *,
    #daevanion-content,
    #daevanion-content *,
    .daevanion-subtabs,
    .daevanion-subtabs * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
      word-wrap: break-word !important;
      word-break: break-word !important;
    }

    /* 데바니온 보드 컨테이너 모바일 최적화 */
    .daevanion-board-container {
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 95vw !important;
      width: fit-content !important;
      box-sizing: border-box !important;
      -webkit-overflow-scrolling: touch;
      justify-content: flex-start !important;
      margin: 0 auto !important;
    }

    /* 모바일에서 데바니온 보드 내부 요소 flex 제거 */
    .daevanion-board-container > div {
      display: block !important;
      flex: none !important;
    }

    .daevanion-board-container > div > div {
      display: block !important;
      flex: none !important;
    }

    /* 작은 모바일에서 추가 최적화 */
    @media (max-width: 480px) {
      .daevanion-board-container {
        padding: 0.25rem !important;
        gap: 1px !important;
        max-width: 98vw !important;
      }

      .daevanion-board-container > div {
        font-size: 6px !important;
        line-height: 1.1 !important;
        padding: 1px !important;
      }

      .daevanion-board-container > div > div {
        font-size: 6px !important;
        line-height: 1.1 !important;
        padding: 0 !important;
      }

      /* 모바일에서 포인트 정보 스타일 */
      #daevanion-points-info {
        padding: 0.75rem !important;
        margin-top: 0.75rem !important;
        font-size: 0.8rem !important;
      }

      #daevanion-points-info > div:first-child {
        font-size: 0.85rem !important;
        margin-bottom: 0.5rem !important;
      }

      #daevanion-points-info > div:last-child > div {
        font-size: 0.8rem !important;
        padding: 0.25rem 0 !important;
      }
    }

    /* 모바일에서 데바니온 보드 전체 최적화 */
    @media (max-width: 768px) {
      .daevanion-board-container {
        padding: 0.5rem !important;
        gap: 1px !important;
        max-width: 95vw !important;
      }

      .daevanion-board-container > div {
        font-size: 7px !important;
        line-height: 1.2 !important;
        padding: 1px !important;
      }

      .daevanion-board-container > div > div {
        font-size: 7px !important;
        line-height: 1.2 !important;
        padding: 0 !important;
      }

      /* 모바일에서 포인트 정보 스타일 */
      #daevanion-points-info {
        display: block !important;
        width: 100% !important;
        max-width: 100% !important;
        padding: 1rem !important;
        margin-top: 1rem !important;
        box-sizing: border-box !important;
        overflow: visible !important;
      }

      #daevanion-points-info > div:first-child {
        font-size: 0.9rem !important;
        margin-bottom: 0.75rem !important;
        text-align: center !important;
      }

      #daevanion-points-info > div:last-child {
        display: flex !important;
        flex-direction: column !important;
        gap: 0.5rem !important;
      }

      #daevanion-points-info > div:last-child > div {
        font-size: 0.85rem !important;
        text-align: center !important;
        padding: 0.25rem 0 !important;
      }

      /* 데스크톱 스타일 제거 (모바일에서는 서브탭 옆에 표시 안 함) */
      .daevanion-subtabs #daevanion-points-info {
        display: none !important;
      }
    }

    /* 장비/액세서리 컨테이너 모바일 최적화 - 모든 하위 요소 포함 */
    /* 640px 이하에서도 스크롤은 유지 (컨테이너 자체는 스크롤 가능) */
    @media (max-width: 639px) {
      /* 자식 요소들은 overflow visible (컨테이너가 스크롤 처리) */
      #equipment-container > *,
      #accessories-container > *,
      #equipment-two-column * {
        overflow: visible !important;
        overflow-x: visible !important;
        overflow-y: visible !important;
        max-width: 100% !important;
        width: auto !important;
        box-sizing: border-box !important;
      }
      
      /* 컨테이너 자체는 스크롤 가능하도록 (640~770px와 동일하게) - 더 높은 우선순위, 항상 스크롤바 표시 */
      #equipment-container,
      #accessories-container {
        display: flex !important;
        flex-direction: column !important;
        max-height: 600px !important;
        min-height: 200px !important;
        height: auto !important;
        overflow-y: scroll !important; /* 항상 스크롤바 표시 */
        overflow-x: hidden !important;
        padding-right: 0.25rem !important;
        width: 100% !important;
        max-width: 100% !important;
        box-sizing: border-box !important;
      }
    }

    /* 스킬/스티그마 컨테이너 모바일 최적화 - 모든 하위 요소 포함 */
    #skills-container,
    #skills-container *,
    #stigmas-container,
    #stigmas-container * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
    }

    /* 컨텐츠 랭킹 영역 모바일 최적화 */
    #content-rankings,
    #content-rankings *,
    .content-rankings,
    .content-rankings *,
    .content-rankings-grid,
    .content-rankings-grid * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
    }

    /* 컨텐츠 랭킹 그리드 모바일 최적화 */
    .content-rankings-grid {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.5rem !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
    }
    
    .content-rankings-grid > div {
      min-height: 100px !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
      box-sizing: border-box !important;
    }

    /* 메인 레이아웃과 콘텐츠 영역 */
    .main-layout.show-character-result,
    .main-layout.show-character-result *,
    .main-content,
    .main-content * {
      overflow-x: visible !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }

    /* dashboard와 hero-card 패딩 조정 */
    .dashboard,
    .hero-card {
      padding: 1rem !important;
    }

    /* 텍스트가 잘리지 않도록 */
    * {
      word-wrap: break-word !important;
      word-break: break-word !important;
    }
  }

  @media (max-width: 640px) {
    .search-container {
      padding: 1.25rem;
    }

    .hero-card h3 {
      font-size: 1.15rem;
    }

    .hero-stats {
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
    }

    .stat-chip {
      padding: 0.7rem;
    }

    .card-grid {
      grid-template-columns: minmax(0, 1fr);
    }

    #equipment-container,
    #accessories-container {
      max-height: 600px !important;
      min-height: 200px !important;
      height: auto !important;
      overflow-y: scroll !important; /* 항상 스크롤바 표시 */
      overflow-x: hidden !important;
      padding-right: 0.25rem !important;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
      display: flex !important;
      flex-direction: column !important;
      gap: 0 !important;
      padding-right: 0.5rem !important;
    }

    .equipment-item {
      margin-bottom: 1rem !important;
      position: relative !important;
      clear: both !important;
      overflow: visible !important;
      width: 100% !important;
      max-width: 100% !important;
    }

    #skills-container,
    #stigmas-container {
      grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
      overflow: visible !important;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }

    #arcana-container {
      gap: 0.4rem;
      justify-content: flex-start;
      overflow: visible !important;
      max-width: 100% !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }

    .ranking-stat-item {
      padding: 0.85rem;
    }

    #server-stats {
      max-height: none;
    }

    /* 캐릭터 검색 결과 영역 추가 최적화 - 모든 하위 요소 포함 */
    #character-result,
    #character-result *,
    #character-result .hero-card,
    #character-result .hero-card *,
    .character-info-tabs,
    .character-info-tabs *,
    .character-tab-panel,
    .character-tab-panel *,
    #panel-daevanion,
    #panel-daevanion *,
    #daevanion-content,
    #daevanion-content * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
      word-wrap: break-word !important;
      word-break: break-word !important;
    }

    /* 컨텐츠 랭킹 영역 */
    #content-rankings,
    #content-rankings * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
    }

    /* dashboard와 hero-card 패딩 조정 */
    .dashboard,
    .hero-card {
      padding: 1rem !important;
    }
  }

  @media (max-width: 480px) {
    .dashboard,
    .hero-card {
      padding: 1rem !important;
    }

    .character-tab-btn,
    .daevanion-subtab-btn {
      flex: 1 1 100%;
    }

    .ranking-filters {
      gap: 0.4rem;
    }

    .search-row,
    .search-row-first,
    .search-row-second {
      gap: 0.5rem;
    }

    .search-button {
      font-size: 0.95rem;
    }

    /* 작은 화면에서도 모든 요소가 잘 보이도록 */
    #character-result,
    #character-result *,
    .character-info-tabs,
    .character-info-tabs *,
    .character-tab-panel,
    .character-tab-panel *,
    #panel-daevanion,
    #panel-daevanion *,
    #daevanion-content,
    #daevanion-content *,
    #content-rankings,
    #content-rankings * {
      overflow: visible !important;
      overflow-x: visible !important;
      overflow-y: visible !important;
      max-width: 100% !important;
      width: auto !important;
      box-sizing: border-box !important;
      word-wrap: break-word !important;
      word-break: break-word !important;
    }
  }

  /* 모바일에서 컨텐츠 랭킹, 장비, 스킬 정보 크기 축소 */
  @media (max-width: 768px) {
    /* 주신 스탯 컨테이너 2열 강제 (768px 이하) */
    #stats-container {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.4rem !important;
    }
    
    .stat-card {
      min-height: 115px !important;
      width: 100% !important;
      min-width: 0 !important;
    }
    
    /* 컨텐츠 랭킹 2열 강제 (768px 이하) - 최우선 적용 */
    #panel-basic-info .content-rankings-grid,
    .character-tab-panel .content-rankings-grid,
    .content-rankings .content-rankings-grid {
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      grid-auto-rows: 1fr !important;
      gap: 0.4rem !important;
    }
    
    /* 컨텐츠 랭킹 크기 축소 */
    #panel-basic-info .content-rankings-grid > div,
    .character-tab-panel .content-rankings-grid > div,
    .content-rankings .content-rankings-grid > div {
      padding: 0.5rem !important;
      gap: 0.3rem !important;
      min-height: 95px !important;
      box-sizing: border-box !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:first-child,
    .character-tab-panel .content-rankings-grid > div > div:first-child,
    .content-rankings .content-rankings-grid > div > div:first-child {
      font-size: 0.65rem !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:nth-child(2),
    .character-tab-panel .content-rankings-grid > div > div:nth-child(2),
    .content-rankings .content-rankings-grid > div > div:nth-child(2) {
      font-size: 0.9rem !important;
    }
    
    #panel-basic-info .content-rankings-grid > div > div:nth-child(3),
    .character-tab-panel .content-rankings-grid > div > div:nth-child(3),
    .content-rankings .content-rankings-grid > div > div:nth-child(3) {
      font-size: 0.7rem !important;
    }

    /* 장비 정보 크기 축소 */
    .equipment-item-icon {
      width: 48px !important;
      height: 48px !important;
    }
    
    /* 장비/장신구 이름 텍스트 줄바꿈 및 크기 조정 */
    .equipment-item-name,
    .accessory-item-name {
      white-space: normal !important;
      overflow: visible !important;
      text-overflow: clip !important;
      word-wrap: break-word !important;
      word-break: break-word !important;
      line-height: 1.3 !important;
      max-width: 100% !important;
      font-size: 0.85rem !important;
    }
    
    /* 타이틀 텍스트 줄바꿈 및 컨테이너 수정 */
    .title-item-name,
    #result-title {
      white-space: normal !important;
      overflow: visible !important;
      text-overflow: clip !important;
      word-wrap: break-word !important;
      word-break: break-word !important;
      line-height: 1.3 !important;
      max-width: 100% !important;
      font-size: 0.9rem !important;
    }
    
    /* 타이틀 컨테이너가 튀어나오지 않도록 */
    .title-item-extra,
    .title-item {
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
      box-sizing: border-box !important;
    }
    
    /* 타이틀 섹션 전체 */
    #title-info {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      box-sizing: border-box !important;
    }

    /* 타이틀 컨테이너 */
    #title-container {
      width: 100% !important;
      max-width: 100% !important;
      overflow-x: hidden !important;
      box-sizing: border-box !important;
    }
    
    /* 타이틀 카드 */
    #title-container > div {
      min-width: 0 !important;
      max-width: 100% !important;
      flex: 1 1 100% !important;
      box-sizing: border-box !important;
    }
    
    /* 타이틀 내부 요소들도 제한 */
    .title-item-extra > *,
    .title-item > * {
      max-width: 100% !important;
      box-sizing: border-box !important;
    }

    .equipment-item-stats {
      flex-direction: column !important;
      gap: 0.5rem !important;
      margin-top: 0.5rem !important;
      max-width: 100% !important;
      overflow: visible !important;
    }

    .equipment-item-stats > div {
      flex: none !important;
      flex-shrink: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 0 !important;
      padding: 0.5rem !important;
      gap: 0.25rem !important;
      box-sizing: border-box !important;
      overflow: visible !important;
    }

    .equipment-item-stats > div > div {
      max-width: 100% !important;
      overflow: visible !important;
      word-wrap: break-word !important;
    }

    .equipment-item-stats > div > div:first-child {
      font-size: 0.7rem !important;
      margin-bottom: 0.35rem !important;
    }

    .equipment-stat-line {
      font-size: 0.65rem !important;
      gap: 0.35rem !important;
    }

    .equipment-stat-label,
    .equipment-stat-value {
      font-size: 0.65rem !important;
    }

    /* 신석 아이콘 크기 축소 */
    .equipment-item-stats ~ div img[alt*="신석"],
    .equipment-item-stats ~ div img[alt*="신석"] {
      width: 24px !important;
      height: 24px !important;
    }

    /* 스킬 정보 크기 축소 (80% 수준) */
    #skills-container,
    #stigmas-container {
      grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)) !important;
      gap: 0.6rem !important;
    }

    #skills-active-container,
    #skills-passive-container,
    #stigmas-container {
      grid-template-columns: repeat(auto-fill, minmax(48px, 1fr)) !important;
      gap: 0.6rem !important;
    }
  }
</style>

    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2533750496800346"
     crossorigin="anonymous"></script>
    <!-- Schema.org 구조화된 데이터 -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "아툴",
      "url": "https://aion2tool.com",
      "potentialAction": {
        "@type": "SearchAction",
        "target": "https://aion2tool.com/?q={search_term_string}",
        "query-input": "required name=search_term_string"
      },
      "hasPart": [
        {
          "@type": "WebPage",
          "name": "캐릭터 검색",
          "url": "https://aion2tool.com/"
        },
        {
          "@type": "WebPage",
          "name": "랭킹",
          "url": "https://aion2tool.com/ranking"
        },
        {
          "@type": "WebPage",
          "name": "통계",
          "url": "https://aion2tool.com/statistics"
        },
        {
          "@type": "WebPage",
          "name": "티어표",
          "url": "https://aion2tool.com/tier"
        },
        
        {
          "@type": "WebPage",
          "name": "스펙 비교",
          "url": "https://aion2tool.com/compare"
        },
        {
          "@type": "WebPage",
          "name": "서버 비교",
          "url": "https://aion2tool.com/server-comparison"
        }
      ]
    }
    </script>
  </head>
  <body>
    
    <!-- 로딩 오버레이 -->
    <div id="fullscreen-loading-overlay" style="display: none;">
      <div class="loading-spinner"></div>
      <div class="loading-text">로딩 중...</div>
    </div>
    
    <div class="glow" aria-hidden="true"></div>

    
    <!-- <div class="page-container"> -->
      <!-- 왼쪽 사이드 광고 -->
      <div class="side-ad side-ad-left">
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2533750496800346"
             crossorigin="anonymous"></script>
             <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-2533750496800346"
             data-ad-slot="1712192366"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      </div> 

      <div class="shell">
<input type="radio" name="hub-tabs" id="tab-character" checked style="display: none;">
<input type="radio" name="hub-tabs" id="tab-ranking"  style="display: none;">
<input type="radio" name="hub-tabs" id="tab-statistics"  style="display: none;">
<div class="site-header">
        <a class="brand-block" href="/">
          <img src="/images/A2TOOL_LOGO.png" alt="AION2 TOOL" class="site-logo">
          <span class="brand-emblem">아툴</span>
        </a>
        <nav class="header-actions" aria-label="메인 메뉴">
          
<div class="tabs">
    <ul class="tab-controls" style="list-style: none; margin: 0; padding: 0; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
      <li>
        <a href="/" class="tab-link">
          <span class="title">캐릭터 검색</span>
          <span class="meta">닉네임 · 레벨 · 클래스 한 glance</span>
        </a>
      </li>
      <li>
        <a href="/ranking" class="tab-link">
          <span class="title">랭킹</span>
          <span class="meta">닉네임 검색 기록 기반</span>
        </a>
      </li>
      <li>
        <a href="/statistics" class="tab-link">
          <span class="title">통계</span>
          <span class="meta">직업 · 전투력 분포</span>
        </a>
      </li>
      <li>
        <a href="/tier" class="tab-link">
          <span class="title">티어</span>
          <span class="meta">직업별 컨텐츠 티어</span>
        </a>
      </li>
      <!-- 큐나 차트 탭 임시 숨김 -->
      <!--
      <li>
        <a href="/quna-chart" class="tab-link">
          <span class="title">큐나 차트</span>
          <span class="meta">큐나 시세 차트</span>
        </a>
      </li>
      -->
      <li>
        <a href="/compare" class="tab-link">
          <span class="title">스펙 비교</span>
          <span class="meta">두 캐릭터 스펙 비교</span>
        </a>
      </li>
      <li>
        <a href="/server-comparison" class="tab-link">
          <span class="title">서버 비교</span>
          <span class="meta">매칭 서버 우세 현황</span>
        </a>
      </li>
      <li>
        <a href="/homework" class="tab-link" style="position: relative;">
          <span class="title">숙제</span>
          <span class="meta">컨텐츠 체크 관리</span>
        </a>
      </li>
    </ul>
</div>

        </nav>
      </div>

      
    <!-- AdSense 광고 컨테이너 -->
     <!-- 수평형 디스플레이 -->

     
      <div style="text-align: center; width: 100%; margin: 0rem 0;">
        <ins class="adsbygoogle"
             style="display:block; margin: 0 auto;"
             data-ad-client="ca-pub-2533750496800346"
             data-ad-slot="1854898252"
             data-ad-format="auto"
             data-full-width-responsive="true"></ins>
        <script>
             (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      </div>
      

    
    <div class="side-ad side-ad-right">
      <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2533750496800346"
     crossorigin="anonymous"></script>
        <!-- 우측 배너 -->
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-client="ca-pub-2533750496800346"
            data-ad-slot="6978877201"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>

    </div> 

    
    

      <main>
        
<!-- 좌우 배너 + 중앙 메인 컨테이너 -->
<div class="main-layout">
  <!-- 좌측 배너: 일일 검색 랭킹 + 공지사항 -->
  <aside class="sidebar-banner sidebar-left">
    <p class="badge" style="margin-bottom: 0.5rem; margin-top: 0 !important; padding-top: 0 !important;">🔍 일일 검색 랭킹</p>
    <article class="hero-card" style="margin: 0; margin-bottom: 1.5rem; position: relative;">
      <div style="padding: 0;">
        <div id="daily-search-ranking" style="min-height: 40px; max-height: 40px; overflow: hidden; position: relative;">
          <p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>
        </div>
        <!-- 마우스 오버 시 표시될 오버레이 박스 -->
        <div id="daily-ranking-overlay" style="display: none; position: absolute; top: 100%; left: 0; right: 0; margin-top: 0.5rem; z-index: 1000; background: rgba(9, 16, 37, 1); border: 1px solid var(--card-border); border-radius: 24px; padding: 1rem; box-shadow: 0 25px 80px rgba(3, 6, 18, 0.85); max-height: 500px; overflow-y: auto; overflow-x: hidden; backdrop-filter: none;">
          <style>
            #daily-ranking-overlay::-webkit-scrollbar {
              display: none;
            }
            #daily-ranking-overlay {
              -ms-overflow-style: none;
              scrollbar-width: none;
            }
          </style>
          <div id="daily-ranking-overlay-content"></div>
        </div>
      </div>
    </article>
    <!-- 전투력 TOP 5 카드 -->
    <p class="badge" style="margin-bottom: 0.5rem; margin-top: 0;">⚔️ 아툴 전투 점수 TOP 5</p>
    <article class="hero-card" style="margin: 0; margin-bottom: 1.5rem;">
      <div id="power-top5-wrapper" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; align-items: stretch;">
        <!-- 천족 TOP 5 -->
        <div class="power-top5-section" style="display: flex; flex-direction: column;">
          <div style="font-size: 0.87rem; font-weight: 600; color: #3b82f6; margin-bottom: 0.75rem;">천족</div>
          <div id="power-top5-elyos" style="display: flex; flex-direction: column; gap: 0.5rem; flex: 1;">
            <p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">로딩 중...</p>
          </div>
        </div>
        <!-- 마족 TOP 5 -->
        <div class="power-top5-section" style="display: flex; flex-direction: column;">
          <div style="font-size: 0.87rem; font-weight: 600; color: #ef4444; margin-bottom: 0.75rem;">마족</div>
          <div id="power-top5-asmodian" style="display: flex; flex-direction: column; gap: 0.5rem; flex: 1;">
            <p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">로딩 중...</p>
          </div>
        </div>
      </div>
    </article>
    
    <!-- 공지사항 카드 -->
    <p class="badge" style="margin-bottom: 0.75rem;">📝 아툴 업데이트 내역</p>
    <article class="hero-card" style="margin: 0;">
      <div>
        <div id="announcements-container" style="max-height: 200px; overflow-y: auto; overflow-x: hidden; min-width: 0; width: 100%; max-width: 100%; box-sizing: border-box;">
          <div class="announcement-list">
            <div class="announcement-item" data-id="22">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-31</span>
                <span class="announcement-title">
                  <span>전투 점수 업데이트 v1.4</span>
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>스킬로 인한 점수 계산 방식 개편</strong><br>이제 각 직업 초월 1~100 랭커의 스킬 평균 레벨 대비 비율 기반으로 점수가 계산됩니다. 각 직업 랭커들의 스킬 레벨 분포에 따라, 스킬 중요도를 계산합니다. 
                    <br><br>이에 따라 점수가 변동 되었으며, 향후 초월 랭커들의 채용 스킬이 변하는 경우 전투 점수 변동이 생길 수 있습니다.</li>
                
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="21">
              <div class="announcement-header">
                <span class="announcement-date">2024-12-23</span>
                <span class="announcement-title">
                  <span>전투 점수 업데이트 v1.3</span>
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>패시브 스킬 계산 방식 변경</strong><br>패시브 스킬 계산이 전체 10개에서 레벨이 높은 상위 8개만 선택하여 계산하도록 변경되었습니다. </li>
                  <li><strong>액티브 스킬 보너스 상향</strong><br>액티브 스킬의 레벨 보너스가 상향되었습니다. Lv.16 보너스 (최종 특화 선택 가능): 10% → 15%, Lv.20 보너스 (특화 1개 추가 선택 가능): 5% → 10% 로 증가했습니다.</li>
                  <li><strong>스티그마 스킬 보너스 상향</strong><br>스티그마 스킬의 레벨 보너스가 상향되었습니다. Lv.15 보너스: 20% → 25%, Lv.20 보너스: 25% → 40%로 증가했습니다.</li>
                  <li><strong>치명타 확률 계산 방식 변경</strong><br> 기존 계산식인 (치명타 스탯 ÷ 10) 은 실제 치명타 확률보다 확연히 높게 나오는 경향이 있었습니다. (치명타 스탯 × 0.7 ÷ 10)으로 변경되었습니다. </li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="20">
              <div class="announcement-header">
                <span class="announcement-date">2024-12-17</span>
                <span class="announcement-title">
                  <span>숙제 관리 탭 추가</span>
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li>숙제 관리탭이 추가되었습니다. 아이온2 여러 캐릭터의 숙제를 관리할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="19">
              <div class="announcement-header">
                <span class="announcement-date">2024-12-17</span>
                <span class="announcement-title">
                  <span>위력 스탯 반영 관련</span>
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li>아이온2 12월17일자 업데이트로 영혼각인에 있는 위력스탯이 스탯 수치에 반영 되어 합쳐짐에 따라, 해당 부분이 적용되도록 수정하였습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="18">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-14</span>
                <span class="announcement-title">
                  전투 점수 업데이트 v1.2/서버 검색
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>세부 계산식 수정 및 공개</strong><br>계산식 조정으로 인해 점수가 떨어졌을 수 있습니다. 전투 점수 계산의 세부 계산식을 수정하여 공개했습니다. 각 스탯별 breakdown을 통해 계산 과정을 확인할 수 있습니다.</li>
                  <li><strong>전서버 검색 기능 추가</strong><br>전서버 검색 기능을 추가하여 한 번에 모든 서버에서 캐릭터를 검색할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="17">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-12</span>
                <span class="announcement-title">
                  전투 점수 업데이트 v1.1
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>다단 히트 적중으로 인한 딜증 계산 추가</strong><br>다단 히트 적중 스탯이 전투 점수 계산에 반영됩니다. 다단 히트 적중은 최대 4타 확률 연쇄 발동으로 인한 딜증을 계산식에 따라 반영합니다.</li>
                  <li><strong>구간 전투 점수 상위 몇 % 인지 표시 추가</strong><br>전투력 ±300 구간 내에서 전투 점수 기준 상위 몇 %인지 표시됩니다. 예: "3100~3700 구간 대비 전투 점수 상위 18.31%"</li>
                  <li><strong>데바니온 - 아리엘에 따른 딜증 추가</strong><br>데바니온 아리엘 보드의 PVE 공격력, 보스 공격력이 공격력에 합산되고, PVE 피해 증폭, 보스 피해 증폭이 피해 증폭에 합산됩니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="16">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-11</span>
                <span class="announcement-title">
                  서비스 안정화 작업 중
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>현재 접속자가 많아 로딩이 느린 상황 발생 중</strong><br>현재 많은 사용자가 동시에 접속하여 로딩 속도가 느려지는 현상이 발생하고 있습니다. 문제를 파악하고 이슈를 해결 중입니다. 불편을 드려 죄송합니다.</li>
                  <li><strong>해결 작업 진행 중</strong><br>DB 병목 현상 분석 및 최적화 작업을 진행하고 있으며, 빠른 시일 내에 개선하겠습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="15">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-09</span>
                <span class="announcement-title">
                  아툴 전투 점수 출시
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>아툴 전투 점수 출시</strong><br>캐릭터 검색 시 아툴 전투 점수를 확인할 수 있습니다. 공격력, 전투 속도, 피해 증폭, 스킬, 재사용 대기 시간 감소를 종합하여 계산된 예상 DPS 점수입니다.</li>
                  <li><strong>딜 스탯 상세 정보</strong><br>각 스탯(공격력, 전투 속도, 피해 증폭, 스킬, 재사용 대기 시간 감소)의 상세 breakdown을 마우스 오버로 확인할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="14">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-08</span>
                <span class="announcement-title">
                  스킬 breakdown 및 즐겨찾기 기능
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>스킬 breakdown 기능 추가</strong><br>액티브/패시브 스킬에 마우스 오버 시 스킬 레벨이 아르카나와 장비/장신구로 인해 얼마나 올랐는지 breakdown을 확인할 수 있습니다.</li>
                  <li><strong>캐릭터 즐겨찾기 기능 추가</strong><br>자주 검색하는 캐릭터를 즐겨찾기로 등록하여 빠르게 검색할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="13">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-07</span>
                <span class="announcement-title">
                  내실 랭킹 기능 추가
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>내실 랭킹 기능 추가</strong><br>랭킹 탭에 내실 랭킹 기능을 추가했습니다. 타이틀, 스티그마 샤드, 주신스탯합 랭킹을 직업별·서버별로 확인할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="12">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-04</span>
                <span class="announcement-title">
                  캐릭터 검색 기능 개선
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>내실 관련 순위 및 PVE 영혼 각인 세팅 점수 추가</strong><br>캐릭터 검색 시 내실 관련 순위 및 PVE 기준 영혼 각인 세팅 점수를 확인할 수 있습니다. </li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="11">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-03</span>
                <span class="announcement-title">
                  아이템 통계 신규 기능 추가
                </span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>아이템 통계 기능 추가</strong><br>통계 탭에 아이템 통계 서브탭을 추가했습니다. 아르카나 세트 옵션, 메인 무기, 가더, 방어구, 장신구 통계를 직업별·전투력 구간별로 확인할 수 있습니다.</li>
                  <li><strong>일부 UI 수정</strong><br>통계 탭의 UI를 개선하고 모바일 반응형을 최적화했습니다.</li>
                  <li><strong>키나 박스 가성비 내용 추가</strong><br>큐나 시세 탭에 키나 박스 가성비 정보를 추가했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="10">
              <div class="announcement-header">
                <span class="announcement-date">2025-12-02</span>
                <span class="announcement-title">레기온 랭킹 및 기능 개선</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>레기온 랭킹 기능 추가</strong><br>랭킹 탭에 레기온(길드) 랭킹 기능을 추가했습니다. 서버별, 종족별 필터링 및 레기온 검색이 가능합니다.</li>
                  <li><strong>전투력 구간별 티어 기능 추가</strong><br>티어 탭에 전투력 구간별 티어 분석 기능을 추가했습니다.</li>
                  <li><strong>레기온 수 오류 수정</strong><br>서버 정보의 등록된 레기온 수 계산 알고리즘을 수정하여 정확한 수치를 표시하도록 개선했습니다.</li>
                  <li><strong>랭킹탭 전투력 구간 조회 오류 수정</strong><br>랭킹 탭에서 전투력 구간별 조회 시 발생하던 오류를 수정했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="9">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-30</span>
                <span class="announcement-title">서버 우세 현황 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>서버 우세 현황 기능 추가</strong><br>매칭 그룹별 서버 우세도를 확인할 수 있는 <strong>서버 우세 현황</strong> 기능을 추가했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="8">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-29</span>
                <span class="announcement-title">큐나 시세 차트 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>큐나 시세 차트 탭 추가</strong><br>큐나 시세를 일봉 캔들차트로 확인할 수 있는 <strong>큐나 차트</strong> 기능을 추가했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="7">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-27</span>
                <span class="announcement-title">스펙 비교 기능 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>스펙 비교 탭 추가</strong><br>상단 탭에서 두 캐릭터의 전투력·랭킹·장비·스킬을 한 화면에서 비교할 수 있는 <strong>스펙 비교</strong> 기능을 추가했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="6">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-26</span>
                <span class="announcement-title">랭커 스킬 통계 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>랭커 스킬 통계 추가</strong><br>1~100위 랭커들의 고투자 스킬 채용률을 확인할 수 있는 스킬 통계 기능을 추가했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="5">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-25</span>
                <span class="announcement-title">전투력 성장 도표 시스템 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>전투력 성장 도표 시스템 추가</strong><br>캐릭터의 전투력 성장 추이를 시각적으로 확인할 수 있는 도표 시스템을 추가했습니다.</li>
                  <li><strong>장비 타이틀 UI 개선</strong><br>장비 및 타이틀 정보 표시 UI를 개선했습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="4">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-24</span>
                <span class="announcement-title">모바일 · 통계 개선</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>모바일 호환성 업데이트</strong><br>헤더, 탭, 랭킹 테이블, 부가 카드가 다양한 해상도에서 자연스럽게 표시되도록 레이아웃과 스타일을 재정비했습니다.</li>
                  <li><strong>통계 탭 개편</strong><br>전투력 구간 슬라이더와 '적용' 버튼을 추가해 원하는 전투력 범위의 직업 통계를 한 번에 조회할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="3">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-23</span>
                <span class="announcement-title">데바니온/장비 정보 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>데바니온 기능 추가</strong><br>캐릭터 정보에서 데바니온 정보를 확인할 수 있습니다.</li>
                  <li><strong>아이템 정보 추가</strong><br>캐릭터 장비 및 악세사리 상세 정보를 확인할 수 있습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="2">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-22</span>
                <span class="announcement-title">티어탭 추가</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>티어 탭 추가</strong><br>티어 탭을 추가하였습니다.</li>
                  <li><strong>각 컨텐츠별 직업 boxplot 추가</strong><br>각 컨텐츠별 직업 boxplot을 추가하였습니다.</li>
                </ul>
              </div>
            </div>
            <div class="announcement-item" data-id="1">
              <div class="announcement-header">
                <span class="announcement-date">2025-11-21</span>
                <span class="announcement-title">업데이트 안내</span>
                <span class="announcement-toggle">▼</span>
              </div>
              <div class="announcement-content">
                <ul>
                  <li><strong>캐릭터 검색 및 랭킹 업데이트</strong><br>캐릭터 검색, 전투력 랭킹, 통계를 추가하였습니다.</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </article>
    
    <!-- 아이온2 업데이트 내역 -->
    <p class="badge" style="margin-bottom: 0.75rem; margin-top: 0.75rem;">🎮 아이온2 업데이트 내역</p>
    <article class="hero-card" style="margin: 0;">
      <div>
        <div id="aion2-updates-container" style="max-height: 200px; overflow-y: auto; overflow-x: hidden; min-width: 0; width: 100%; max-width: 100%; box-sizing: border-box;">
          <div class="announcement-list">
            <p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>
          </div>
        </div>
      </div>
    </article>
  </aside>

  <!-- 중앙 메인: 검색 카드 -->
  <section class="main-content">
    <!-- 캐릭터 검색 제목과 폼 (dashboard 밖) -->
    <div id="character-search-wrapper" style="display: none;">
      <p class="badge" style="margin-bottom: 0.75rem; margin-top: 0; padding-top: 0;">🔍 캐릭터 검색</p>
      <div class="character-search-form" style="margin-bottom: 1.5rem; background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 20px; padding: 0.75rem clamp(0.5rem, 2vw, 1rem);">
        <div class="search-container">
          <div class="search-row-first">
            <div id="race-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
              <button id="race-all" class="race-button active" data-race="">전체</button>
              <button id="race-elyos" class="race-button" data-race="1">천족</button>
              <button id="race-asmodian" class="race-button" data-race="2">마족</button>
            </div>
            <select id="server-select" class="search-select">
              <option value="all">전체 서버 검색</option>
            </select>
          </div>
          <div class="search-row-second">
            <input type="text" id="character-keyword" class="search-input" placeholder="캐릭터 닉네임 입력" />
            <button id="search-button" class="search-button">검색</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 전체 서버 검색 결과 카드 영역 -->
    <div id="character-all-servers-result" class="card-grid" style="display: none; margin-bottom: 1rem;">
      <article class="hero-card" style="grid-column: 1 / -1; padding: 0.75rem;">
        <div id="all-servers-result-list">
          <!-- 동적으로 생성됨 -->
        </div>
      </article>
    </div>
    
    <!-- 즐겨찾기한 캐릭터 섹션 -->
    <p id="favorites-title" class="badge" style="margin-bottom: 0.75rem; margin-top: 0; padding-top: 0; display: none;">
      ⭐ 즐겨찾기한 캐릭터
    </p>
    <div id="favorites-section" class="card-grid" style="grid-column: 1 / -1; margin-bottom: 1rem; display: none;">
      <article class="hero-card" style="grid-column: 1 / -1; padding: 1rem;">
        <div id="favorites-container" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem;">
          <!-- 동적으로 생성됨 -->
        </div>
        <div id="favorites-empty" style="text-align: center; color: var(--text-muted); padding: 2rem; display: none;">
          즐겨찾는 캐릭터를 등록해보세요
        </div>
        <div id="favorites-pagination" style="display: none; justify-content: center; align-items: center; gap: 0.5rem; margin-top: 0.5rem; padding: 0.25rem;">
          <button id="favorites-prev-btn" style="background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); border-radius: 4px; color: var(--accent); padding: 0.3rem 0.6rem; cursor: pointer; transition: all 0.2s ease; font-size: 0.75rem;" onmouseover="this.style.background='rgba(157, 140, 255, 0.3)';" onmouseout="this.style.background='rgba(157, 140, 255, 0.2)';">&lt; 이전</button>
          <span id="favorites-page-info" style="color: var(--text-muted); font-size: 0.75rem;"></span>
          <button id="favorites-next-btn" style="background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); border-radius: 4px; color: var(--accent); padding: 0.3rem 0.6rem; cursor: pointer; transition: all 0.2s ease; font-size: 0.75rem;" onmouseover="this.style.background='rgba(157, 140, 255, 0.3)';" onmouseout="this.style.background='rgba(157, 140, 255, 0.2)';">다음 &gt;</button>
        </div>
      </article>
    </div>
    
    <!-- 스트리머 방송 섹션 (검색 폼 아래, 홈 화면에 항상 표시) -->
    <p id="streamer-title" class="badge" style="margin-bottom: 0.75rem; margin-top: 0 !important; padding-top: 0 !important;">
      📺 아이온2 LIVE
      <span id="streamer-update-time" style="font-size: 0.7rem; color: var(--text-muted); font-weight: 400; margin-left: 0.5rem;"></span>
    </p>
    <div id="streamer-section" class="card-grid" style="grid-column: 1 / -1; margin-bottom: 1.5rem;">
      <article class="hero-card" style="grid-column: 1 / -1;">
        <div id="streamer-race-wrapper" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
          <!-- 왼쪽: 천족 (파란색) -->
          <div class="streamer-race-column" data-race="천족" style="border-left: 3px solid #3b82f6;">
            <div style="font-size: 1.1rem; font-weight: 600; color: #3b82f6; margin-bottom: 1rem;">천족</div>
            <div id="streamer-container-elyos" class="streamer-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem 0.5rem; row-gap: 0.4rem; min-height: 200px; align-items: start; align-content: start;">
              <p style="text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">로딩 중...</p>
            </div>
          </div>
          
          <!-- 우측: 마족 (빨간색) -->
          <div class="streamer-race-column" data-race="마족" style="border-left: 3px solid #ef4444;">
            <div style="font-size: 1.1rem; font-weight: 600; color: #ef4444; margin-bottom: 1rem;">마족</div>
            <div id="streamer-container-asmodian" class="streamer-container" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem 0.5rem; row-gap: 0.4rem; min-height: 200px; align-items: start; align-content: start;">
              <p style="text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">로딩 중...</p>
            </div>
          </div>
        </div>
      </article>
    </div>
    
    <section class="dashboard" id="main-dashboard">
      <div class="tab-panels">
        <section id="panel-character" class="tab-panel">
          <!-- 검색 결과 표시 영역 -->
        <div id="character-result" class="card-grid" style="display: none;">
        <article class="hero-card" style="grid-column: 1 / -1; border: none;">
          <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: 1.5rem;">
            <!-- 캐릭터 아바타 이미지 -->
            <div id="result-avatar-container" style="display: none; flex-shrink: 0; min-width: 156px;">
              <img id="result-avatar" src="" alt="" style="width: 156px; height: 260px; border-radius: 16px; border: 2px solid rgba(157, 140, 255, 0.3); object-fit: cover; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3); display: none;">
            </div>
            <!-- 닉네임과 스탯 -->
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
                <h3 id="result-nickname" style="margin: 0; color: #ffffff; font-weight: 700; font-size: 1.5rem;"></h3>
                <button id="favorite-star-btn" style="background: none; border: none; cursor: pointer; padding: 0.25rem; display: flex; align-items: center; font-size: 1.5rem; color: rgba(255, 255, 255, 0.3); transition: all 0.2s ease;" title="즐겨찾기" onmouseover="this.style.transform='scale(1.2)'; this.style.color='#ffd700';" onmouseout="const icon = document.getElementById('favorite-star-icon'); if (icon && icon.textContent === '☆') { this.style.color='rgba(255, 255, 255, 0.3)'; } this.style.transform='';">
                  <span id="favorite-star-icon">☆</span>
                </button>
                <div id="streamer-badge-container" style="display: none;"></div>
              </div>
              <!-- 업데이트 시간 및 갱신 버튼 -->
              <div id="character-update-info" style="display: none; margin-bottom: 0.3rem; display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                <span id="character-update-time" style="font-size: 0.8rem; color: var(--text-muted);"></span>
                <button id="character-refresh-btn" style="padding: 0.25rem 0.6rem; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); border-radius: 6px; color: var(--accent); font-size: 0.8rem; cursor: pointer; transition: all 0.2s ease;">갱신하기</button>
                <span id="character-refresh-cooldown" style="font-size: 0.7rem; color: var(--text-muted); display: none;"></span>
              </div>
              <div class="companion-badge-row" id="companion-badges" style="display: none;">
                <div class="companion-badge" id="pet-badge" style="display: none;">
                  <img id="pet-icon" alt="펫 아이콘" />
                  <div>
                    <div class="companion-badge-name" id="pet-name"></div>
                  </div>
                </div>
                <div class="companion-badge" id="wing-badge" style="display: none;">
                  <img id="wing-icon" alt="날개 아이콘" />
                  <div>
                    <div class="companion-badge-name" id="wing-name"></div>
                  </div>
                </div>
              </div>
              <p class="subtitle" id="result-subtitle" style="display: none;"></p>
              
              <!-- 첫 번째 줄: 종족, 서버, 직업 (3개) -->
              <div class="hero-stats hero-stats-first" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 0.4rem;">
                <div class="stat-chip">
                  <span class="label">종족</span>
                  <span class="value" id="result-race" style="font-weight: 600;"></span>
                </div>
                <div class="stat-chip">
                  <span class="label">서버</span>
                  <span class="value" id="result-server"></span>
                </div>
                <div class="stat-chip">
                  <span class="label">직업</span>
                  <span class="value" id="result-job-container" style="display: flex; align-items: center; gap: 0.3rem;">
                    <img id="result-job-image" src="" alt="" style="width: 24px; height: 24px; display: none; flex-shrink: 0;">
                    <span id="result-job"></span>
                  </span>
                </div>
              </div>
              
              <!-- 두 번째 줄: 레기온, 전투력 (2개) -->
              <div class="hero-stats hero-stats-second" style="grid-template-columns: repeat(2, 1fr);">
                <div class="stat-chip" style="position: relative;">
                  <span class="label">레기온</span>
                  <span class="value" id="result-guild">-</span>
                  <div id="result-guild-rank" style="font-size: 0.65rem; color: var(--text-muted); margin-top: 0.15rem;"></div>
                  <a id="region-search-link" class="region-search-desktop" href="#" style="display: none; position: absolute; bottom: 0.2rem; right: 0.3rem; font-size: 0.65rem; color: var(--accent); text-decoration: none; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.7'" onmouseout="this.style.opacity='1'">레기온 검색 >></a>
                </div>
                <div class="stat-chip">
                  <span class="label">전투력</span>
                  <span class="value" id="result-combat-power"></span>
                </div>
              </div>
              <!-- 레기온 검색 링크 (모바일용) -->
              <div class="region-search-mobile" style="display: none; text-align: center; margin-top: 0.3rem;">
                <a id="region-search-link-mobile" href="#" style="display: none; font-size: 0.75rem; color: var(--accent); text-decoration: none; cursor: pointer; transition: opacity 0.2s;" onmouseover="this.style.opacity='0.7'" onmouseout="this.style.opacity='1'">레기온 검색 >></a>
              </div>
            </div>
            <!-- 우측 상단 액션 영역 -->
            <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.75rem;">
              <a id="compare-with-mine-button" class="compare-with-mine-button" href="#" style="display: none; padding: 0.4rem 0.8rem; background: transparent; color: var(--accent); border: 1px solid var(--accent); border-radius: 8px; font-size: 0.75rem; font-weight: 600; text-decoration: none; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer;" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(157, 140, 255, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
                내 캐릭터랑 비교 >
              </a>
            </div>
          </div>
          
          <!-- 아툴 전투 점수 및 딜 스탯 정보 표시 -->
          <div class="dps-stats-info" id="dps-stats-info" style="display: none; margin-top: 1.5rem; margin-bottom: 1.5rem; padding: 1.5rem; background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(148, 163, 184, 0.35); border-radius: 14px;">
            <!-- 아툴 전투 점수 표시 -->
            <div style="text-align: center; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
              
              <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                <span>아툴 전투 점수 (PVE 딜 세팅 점수)</span>
                <!-- <button id="dps-calculation-info-btn" style="width: 20px; height: 20px; border-radius: 50%; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); color: #a78bfa; font-size: 0.75rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; padding: 0;" title="전투 점수 계산 방식 보기" onclick="showDpsCalculationModal();">?</button> -->
              </div>
              <!-- 달성 최고 점수 -->
              <div id="combat-score-max-info" style="display: none; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem; text-align: center;"></div>
              <div style="font-size: 3rem; font-weight: 700; color: #a78bfa; line-height: 1.2; margin-bottom: 0.5rem;" id="dps-score-value">-</div>
              <!-- 전투력 구간 대비 전투 점수 상위% 정보 -->
              <div id="combat-score-power-range-info" style="display: none; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem; text-align: center;"></div>
              <!-- 랭킹 정보 컨테이너 -->
              <div id="combat-score-rankings-info" style="display: none; padding: 0.75rem; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.2); border-radius: 8px; font-size: 0.85rem;">
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.75rem; text-align: center;">
                  <div>
                    <div style="color: var(--text-muted); margin-bottom: 0.25rem;">전체 랭킹</div>
                    <div style="color: #fbbf24; font-weight: 600;" id="combat-score-overall-percentile">-</div>
                  </div>
                  <div>
                    <div style="color: var(--text-muted); margin-bottom: 0.25rem;">직업 랭킹</div>
                    <div style="color: #fbbf24; font-weight: 600;" id="combat-score-job-rank">-</div>
                  </div>
                  <div>
                    <div style="color: var(--text-muted); margin-bottom: 0.25rem;">서버 랭킹</div>
                    <div style="color: #fbbf24; font-weight: 600;" id="combat-score-server-rank">-</div>
                  </div>
                </div>
              </div>
              <!-- 랭킹 기준 안내 메시지 -->
              <div id="combat-score-ranking-notice" style="display: none; text-align: right; font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                달성 최고 점수 기준 랭킹입니다
              </div>
            </div>
            <div class="ranking-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
              <div class="ranking-stat-item" id="attack-power-container">
                <div class="damage-increase-badge attack-power-cap-badge" id="attack-power-cap-badge" style="display: none; cursor: pointer;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>공격력</span>
                  <button class="attack-power-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="attack-power-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 300px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비/장신구</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-equipment-base">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비/장신구 (초월 정수)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-equipment-transcend-integer">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비/장신구 (초월 퍼센트)</span>
                          <span style="color: #a78bfa; font-weight: 500;" id="tooltip-equipment-transcend-percent">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>주신 스탯 (파괴)</span>
                          <span style="color: #a78bfa; font-weight: 500;" id="tooltip-destruction">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>일반스탯 (위력)</span>
                          <span style="color: #a78bfa; font-weight: 500;" id="tooltip-power">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 - 아리엘 (PVE)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-ariel">+0</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #4ade80; line-height: 1.4; word-wrap: break-word;">
                        패시브 스킬 및 수집 효과 등으로 인한 격차로 인게임보다 낮게 출력 됩니다
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="attack-power-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="attack-power-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="critical-hit-container" style="display: none;">
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>치명타</span>
                  <button class="critical-hit-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="critical-hit-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); opacity: 0; pointer-events: none; word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-base-critical">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>영혼 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-soul-critical">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>마석 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-stone-critical">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-critical">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>주신 스탯 (죽음)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-death-critical">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>일반 스탯 (정확)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-accuracy-critical">+0%</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #ff4444; line-height: 1.4;">
                        <strong>주의:</strong> 상대의 치명타 저항에 따라 실제 치명타 확률이 달라질 수 있습니다. 위 수치는 추정값입니다.
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="critical-hit-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem; display: none;" id="critical-hit-percentile">-</div>
                </div>
              </div>

              

              <div class="ranking-stat-item" id="combat-speed-container">
                <div class="damage-increase-badge" id="combat-speed-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>전투 속도</span>
                  <button class="combat-speed-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="combat-speed-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 영혼 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-soul-combat-speed">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장신구 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-accessory-combat-speed">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>주신 스탯 (시간)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-time-combat-speed">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 (네자칸)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-combat-speed">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-combat-speed">+0%</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #4ade80; line-height: 1.4; word-wrap: break-word;">
                        공격력 다음으로 dps에 많은 영향을 주는 수치입니다
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="combat-speed-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="combat-speed-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="weapon-damage-amplification-container">
                <div class="damage-increase-badge" id="weapon-damage-amplification-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>무기 피해 증폭</span>
                  <button class="weapon-damage-amplification-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="weapon-damage-amplification-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 영혼 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-soul-weapon-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-equipment-base-weapon-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>마석 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-stone-weapon-damage-amp">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 (지켈/바이젤)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-weapon-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀 장착 효과</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-weapon-damage-amp">+0%</span>
                        </div>
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="weapon-damage-amplification-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="weapon-damage-amplification-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="damage-amplification-container">
                <div class="damage-increase-badge" id="damage-amplification-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>피해 증폭</span>
                  <button class="damage-amplification-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="damage-amplification-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 영혼 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-soul-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-equipment-base-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>마석 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-stone-damage-amp">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 (지켈)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 - 아리엘</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-ariel-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀 장착 효과</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-damage-amp">+0%</span>
                        </div>
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="damage-amplification-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="damage-amplification-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="critical-damage-amplification-container">
                <div class="damage-increase-badge" id="critical-damage-amplification-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>치명타 피해 증폭</span>
                  <button class="critical-damage-amplification-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="critical-damage-amplification-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 영혼 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-soul-critical-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-equipment-base-critical-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>마석 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-stone-critical-damage-amp">+0</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 (바이젤)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-critical-damage-amp">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀 장착 효과</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-critical-damage-amp">+0%</span>
                        </div>
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="critical-damage-amplification-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="critical-damage-amplification-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="skill-damage-container">
                <div class="damage-increase-badge" id="skill-damage-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>스킬</span>
                  <button class="skill-damage-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="skill-damage-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 300px; max-width: 400px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); opacity: 0; pointer-events: none; word-wrap: break-word;">
                      <div style="font-weight: 600; margin-bottom: 0.5rem; color: #a78bfa;">스킬 점수 계산식</div>
                      <div style="font-size: 0.75rem; color: #d1d5db; line-height: 1.6; margin-bottom: 0.5rem;">
                        컨텐츠 랭킹 - 초월 탭의 직업별 1~100위 캐릭터들의 스킬 트리를 기반으로 계산됩니다.
                      </div>
                      <div style="font-size: 0.75rem; color: #d1d5db; line-height: 1.6; margin-bottom: 0.5rem;">
                        <strong style="color: #60a5fa;">액티브 스킬 (12개)</strong><br>
                        <strong style="color: #f472b6;">패시브 스킬 (10개)</strong><br>
                        <strong style="color: #fb923c;">스티그마 스킬 (11개)</strong>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #4ade80; line-height: 1.4;">
                        각 스킬은 우선순위와 레벨에 따라 점수가 부여되며, 우선순위가 높고 레벨이 높을수록 더 많은 점수를 받습니다.
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="skill-damage-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="skill-damage-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="cooldown-reduction-container">
                <div class="damage-increase-badge" id="cooldown-reduction-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>재사용 대기 시간 감소</span>
                  <button class="cooldown-reduction-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="cooldown-reduction-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); opacity: 0; pointer-events: none; word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-cooldown">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>주신 스탯 (환상)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-illusion-cooldown">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 (네자칸)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-cooldown">+0%</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #4ade80; line-height: 1.4; word-wrap: break-word;">
                        현재로선 모든 클래스에서서 동일 효율을 가정 합니다. 클래스별 쿨감효율 연구가 진행됨에 따라, dps에 기여하는 정도를 조정할 예정입니다.
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="cooldown-reduction-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="cooldown-reduction-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="stun-hit-container" style="display: none;">
                <div class="damage-increase-badge" id="stun-hit-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>강타</span>
                  <button class="stun-hit-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="stun-hit-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); opacity: 0; pointer-events: none; word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-stun">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>주신 스탯 (지혜)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-wisdom-stun">+0%</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #ff4444; line-height: 1.4;">
                        <strong>주의:</strong> 강타/완벽/치명은 독립적으로 발동됩니다 (동시발동도 가능). 강타는 최종 피해량 기반 강화된 딜링을 가합니다.
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="stun-hit-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="stun-hit-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="perfect-container" style="display: none;">
                <div class="damage-increase-badge" id="perfect-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>완벽</span>
                  <button class="perfect-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="perfect-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); opacity: 0; pointer-events: none; word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>타이틀</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-title-perfect">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>주신 스탯 (정의)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-justice-perfect">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장신구 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-accessory-perfect">+0%</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #ff4444; line-height: 1.4;">
                        <strong>주의:</strong> 강타/완벽/치명은 독립적으로 발동됩니다 (동시발동도 가능). 완벽은 무기 최대 공격력 대비 강화된 딜량을 가합니다.
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="perfect-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="perfect-percentile">-</div>
                </div>
              </div>
              <div class="ranking-stat-item" id="multi-hit-container" style="display: block;">
                <div class="damage-increase-badge" id="multi-hit-damage-badge" style="display: none;"></div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.25rem;">
                  <span>다단 히트 적중</span>
                  <button class="multi-hit-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">
                    i
                    <div class="multi-hit-tooltip" style="position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); margin-bottom: 8px; padding: 0.75rem; background: rgba(0, 0, 0, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; min-width: 250px; max-width: 350px; font-size: 0.8rem; color: var(--text-primary); line-height: 1.5; z-index: 10000; transition: opacity 0.2s ease; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); opacity: 0; pointer-events: none; word-wrap: break-word;">
                      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">Breakdown</div>
                      <div style="display: flex; flex-direction: column; gap: 0.4rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비/장신구 영혼 각인</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-soul-multi-hit">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>장비/장신구 기본 옵션</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-base-multi-hit">+0%</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                          <span>데바니온 (트리니엘)</span>
                          <span style="color: #60a5fa; font-weight: 500;" id="tooltip-daevanion-multi-hit">+0%</span>
                        </div>
                      </div>
                      <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.75rem; color: #4ade80; line-height: 1.4; word-wrap: break-word;">
                        최대 4타 확률 연쇄 발동. 효율 = <span style="font-size: 0.9rem; font-weight: 600;">∑</span>(n타확률×n타딜증). 인던 기준 타수별 11%, 25%, 43%, 67% 추가 피해.
                      </div>
                      <div style="position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid rgba(0, 0, 0, 0.95);"></div>
                    </div>
                  </button>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <div class="combat-stat-value" id="multi-hit-value">-</div>
                  <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 0.2rem;" id="multi-hit-percentile">-</div>
                </div>
              </div>
            </div>
            
            <div style="margin-top: 1rem; padding: 0.75rem 1rem; text-align: center; background: rgba(68, 255, 68, 0.15); border: 1px solid rgba(68, 255, 68, 0.3); border-radius: 8px; font-size: 0.85rem; line-height: 1.4; color: white;">
              펫작: 펫작으로 인한 위력,정확 등 스탯 역시 전투점수 계산에 포함됩니다.
            </div>
            <div style="margin-top: 1rem; padding: 0.75rem 1rem; text-align: center; background: rgba(255, 68, 68, 0.15); border: 1px solid rgba(255, 68, 68, 0.3); border-radius: 8px; font-size: 0.85rem; line-height: 1.4; color: white;">
              다른 직업간 단순 점수로 비교시 정확하지 않을 수 있습니다.<br>아직 계산에 포함할 수 않는 것들: 날개효과, 일부 펫작/펫이해도 스탯, 옷장 내실.
            </div>
          </div>
          
          <!-- 캐릭터 검색 내 수평 광고 -->
          <div id="character-search-ad" style="display: none; margin-top: 0rem; margin-bottom: 0rem; text-align: center; width: 100%; max-width: 728px; margin-left: auto; margin-right: auto; min-height: 90px;">
            <ins class="adsbygoogle"
                 style="display:block; width: 100%; max-width: 728px; height: 90px;"
                 data-ad-client="ca-pub-2533750496800346"
                 data-ad-slot="7213012627"
                 data-ad-format="horizontal"></ins>
          </div>
          
          <!-- 스탯 정보 모달 -->
          <div id="stat-info-modal" class="stat-info-modal">
            <div class="stat-info-modal-content">
              <div class="stat-info-modal-header">
                <div class="stat-info-modal-title">스탯 정보</div>
                <button class="stat-info-modal-close">×</button>
              </div>
              <div class="stat-info-breakdown-section"></div>
              <div class="stat-info-description-section"></div>
            </div>
          </div>
          
          <!-- 장비/장신구 요약 모달 -->
          <div id="equipment-summary-modal" class="stat-info-modal">
            <div class="stat-info-modal-content">
              <div class="stat-info-modal-header">
                <div class="stat-info-modal-title">장비/장신구 요약</div>
                <button class="stat-info-modal-close" onclick="closeEquipmentSummaryModal()">×</button>
              </div>
              <div style="padding: 1.5rem;">
                <div class="equipment-summary-grid">
                  <!-- 왼쪽: 장비 -->
                  <div>
                    <h5 style="margin: 0 0 1rem 0; font-size: 0.95rem; color: var(--accent); font-weight: 600;">장비</h5>
                    <div id="equipment-summary-list" style="display: flex; flex-direction: column; gap: 0.5rem;">
                      <!-- 장비 요약 리스트 -->
                    </div>
                  </div>
                  <!-- 오른쪽: 장신구 -->
                  <div>
                    <h5 style="margin: 0 0 1rem 0; font-size: 0.95rem; color: var(--accent); font-weight: 600;">장신구</h5>
                    <div id="accessories-summary-list" style="display: flex; flex-direction: column; gap: 0.5rem;">
                      <!-- 장신구 요약 리스트 -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- 영혼각인 등급 설명 모달 -->
          <div id="soul-engraving-grade-modal" class="stat-info-modal">
            <div class="stat-info-modal-content" style="max-width: 500px;">
              <div class="stat-info-modal-header">
                <div class="stat-info-modal-title">영혼각인 등급 설명</div>
                <button class="stat-info-modal-close">×</button>
              </div>
              <div style="padding: 1.5rem;">
                <div style="display: flex; flex-direction: column; gap: 1.5rem;">
                  <!-- S 등급 -->
                  <div style="display: flex; align-items: flex-start; gap: 1rem;">
                    <div style="display: inline-flex; align-items: center; justify-content: center; width: 22px; height: 22px; aspect-ratio: 1; border-radius: 50%; background: linear-gradient(135deg, #FFEB3B 0%, #FFD700 25%, #FFC107 50%, #FFD700 75%, #FFEB3B 100%); color: #FFFFFF; font-size: 0.75rem; font-weight: 900; margin-right: 0.4rem; flex-shrink: 0; line-height: 1; border: 1.5px solid rgba(255, 235, 59, 0.9); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6); position: relative; overflow: hidden;">S</div>
                    <div style="flex: 1;">
                      <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">S 등급</div>
                      <div style="font-size: 0.9rem; color: var(--text-muted); line-height: 1.6;">딜에 가장 크게 영향 미치는 옵션들</div>
                    </div>
                  </div>
                  
                  <!-- A 등급 -->
                  <div style="display: flex; align-items: flex-start; gap: 1rem;">
                    <div style="display: inline-flex; align-items: center; justify-content: center; width: 21px; height: 21px; aspect-ratio: 1; border-radius: 50%; background: linear-gradient(135deg, #42A5F5 0%, #2196F3 25%, #1976D2 50%, #2196F3 75%, #42A5F5 100%); color: #FFFFFF; font-size: 0.72rem; font-weight: 900; margin-right: 0.4rem; flex-shrink: 0; line-height: 1; border: 1.5px solid rgba(66, 165, 245, 0.8); box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3); text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5); position: relative; overflow: hidden;">A</div>
                    <div style="flex: 1;">
                      <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">A 등급</div>
                      <div style="font-size: 0.9rem; color: var(--text-muted); line-height: 1.6;">S만큼 크진 않지만 딜에 많은 영향을 주는 옵션들</div>
                    </div>
                  </div>
                  
                  <!-- B 등급 -->
                  <div style="display: flex; align-items: flex-start; gap: 1rem;">
                    <div style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; aspect-ratio: 1; border-radius: 50%; background: linear-gradient(135deg, #66BB6A 0%, #4CAF50 25%, #388E3C 50%, #4CAF50 75%, #66BB6A 100%); color: #FFFFFF; font-size: 0.7rem; font-weight: 900; margin-right: 0.4rem; flex-shrink: 0; line-height: 1; border: 1.5px solid rgba(102, 187, 106, 0.7); box-shadow: 0 2px 2px rgba(0, 0, 0, 0.3); text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4); position: relative; overflow: hidden;">B</div>
                    <div style="flex: 1;">
                      <div style="font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem;">B 등급</div>
                      <div style="font-size: 0.9rem; color: var(--text-muted); line-height: 1.6;">PVE에서 딜에 영향을 주지 않거나, 줄 수도 있지만 A만큼은 크지 않은 옵션들</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- 캐릭터 정보 탭 -->
          <div class="character-info-tabs">
            <div class="character-tab-controls">
              <button class="character-tab-btn active" data-tab="basic-info">
                기본 정보
              </button>
              <button class="character-tab-btn" data-tab="daevanion">
                데바니온
              </button>
              <button class="character-tab-btn" data-tab="growth-history">
                성장도표
              </button>
            </div>
            
            <!-- 기본 정보 탭 패널 -->
            <div class="character-tab-card character-tab-panel active" id="panel-basic-info">
              <!-- 컨텐츠 랭킹 정보 표시 -->
              <div class="content-rankings" id="content-rankings" style="display: none; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                <h4 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; color: var(--accent);">컨텐츠 랭킹 (서버)</h4>
                <div class="content-rankings-legend" style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 1rem; font-size: 0.85rem;">
                  <div style="display: flex; align-items: center; gap: 0.5rem; color: #f87171;">
                    <span style="width: 12px; height: 12px; border-radius: 50%; background-color: #f87171; display: inline-block;"></span>
                    <span>PvP</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: 0.5rem; color: #60a5fa;">
                    <span style="width: 12px; height: 12px; border-radius: 50%; background-color: #60a5fa; display: inline-block;"></span>
                    <span>PvE</span>
                  </div>
                </div>
                <div class="content-rankings-grid">
                  <!-- 컨텐츠 랭킹 카드들이 여기에 동적으로 추가됨 -->
                </div>
              </div>
              
              <!-- 랭킹 정보 표시 -->
              <div class="ranking-info" id="ranking-info" style="display: none; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <h4 style="margin: 0 0 1rem 0; font-size: 1.1rem; color: var(--accent);">전투력 랭킹</h4>
              <div class="ranking-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
                <div class="ranking-stat-item">
                  <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">전체 랭킹</div>
                  <div style="font-size: 1.3rem; font-weight: 600; color: var(--text-primary);" id="result-overall-rank">-</div>
                  <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.25rem;" id="result-overall-percentage">-</div>
                </div>
                <div class="ranking-stat-item">
                  <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">직업 랭킹</div>
                  <div style="font-size: 1.3rem; font-weight: 600; color: var(--text-primary);" id="result-job-rank">-</div>
                  <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.25rem;" id="result-job-percentage">-</div>
                </div>
                <div class="ranking-stat-item">
                  <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 랭킹</div>
                  <div style="font-size: 1.3rem; font-weight: 600; color: var(--text-primary);" id="result-server-rank">-</div>
                  <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 0.25rem;" id="result-server-percentage">-</div>
                </div>
              </div>
            </div>
            
            <!-- 장비 정보 표시 -->
            <div class="equipment-info" id="equipment-info" style="display: none; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <h4 style="margin: 0 0 1rem 0; font-size: 1.1rem; color: var(--accent); display: flex; align-items: center; gap: 0.5rem;">
                <span>장비</span>
                <button class="soul-engraving-grade-help-btn attack-power-info-icon" style="position: relative; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; background: rgba(157, 140, 255, 0.2); border: 1px solid rgba(157, 140, 255, 0.4); cursor: pointer; font-size: 11px; color: #a78bfa; font-weight: 600; line-height: 1; z-index: 10001; padding: 0; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle;">?</button>
                <button class="equipment-summary-btn" style="position: relative; display: inline-flex; align-items: center; justify-content: center; height: 24px; border-radius: 4px; background: rgba(68, 255, 68, 0.2); border: 1px solid rgba(68, 255, 68, 0.4); cursor: pointer; font-size: 0.75rem; color: #4ade80; font-weight: 600; line-height: 1; z-index: 10001; padding: 0.25rem 0.5rem; transition: all 0.2s ease; flex-shrink: 0; vertical-align: middle; white-space: nowrap;">장비 한눈에 보기</button>
              </h4>
              
              <!-- 장비와 장신구를 2컬럼으로 배치 (데스크톱) / 1컬럼으로 배치 (모바일) -->
              <div id="equipment-two-column" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                <!-- 왼쪽 컬럼: 장비 -->
                <div id="equipment-column">
                  <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">장비</div>
                  <div id="equipment-container" style="display: flex; flex-direction: column; gap: 0.25rem;">
                    <!-- 장비 아이템들이 여기에 동적으로 추가됨 -->
                  </div>
                </div>
                
                <!-- 오른쪽 컬럼: 장신구 -->
                <div id="accessories-column">
                  <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;">장신구</div>
                  <div id="accessories-container" style="display: flex; flex-direction: column; gap: 0.25rem;">
                    <!-- 악세사리 아이템들이 여기에 동적으로 추가됨 -->
                  </div>
                </div>
              </div>
            </div>
            
            <!-- 아르카나 정보 표시 -->
            <div class="arcana-info" id="arcana-info" style="display: none; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <h4 style="margin: 0 0 1rem 0; font-size: 1.1rem; color: var(--accent);">아르카나</h4>
              <div id="arcana-container" style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 0.5rem;">
                <!-- 아르카나 아이템들이 여기에 동적으로 추가됨 -->
              </div>
            </div>
            
            <!-- 타이틀 정보 표시 -->
            <div class="title-info" id="title-info" style="display: none; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
                <h4 style="margin: 0; font-size: 1.1rem; color: var(--accent);">타이틀</h4>
                <div id="title-summary" style="font-size: 0.9rem; color: var(--text-muted);"></div>
              </div>
              <div id="title-container" style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 1rem;">
                <!-- 타이틀 카드들이 여기에 동적으로 추가됨 -->
              </div>
            </div>
            
            <!-- 스킬 정보 표시 -->
            <div class="skill-info" id="skill-info" style="display: none; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
              <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.75rem; margin-bottom: 1rem; flex-wrap: wrap;">
                <div style="display: flex; flex-direction: column; gap: 0.35rem; min-width: 0;">
                  <div style="display: flex; align-items: center; gap: 0.6rem; flex-wrap: wrap;">
                    <h4 style="margin: 0; font-size: 1.1rem; color: var(--accent);">스킬</h4>
                    <span style="font-size: 0.8rem; color: var(--text-muted);">
                      아이콘 위 <span style="color: #facc15;">★</span> 표시는 랭커들이 많이 사용하는 스킬 순위입니다.
                      <span style="color: #facc15;">★★★</span> 1위 · <span style="color: #facc15;">★★</span> 2위 · <span style="color: #facc15;">★</span> 3위
                    </span>
                  </div>
                </div>
                <a id="skill-recommend-button" class="skill-recommend-button" href="#" style="display: none; padding: 0.4rem 0.8rem; background: transparent; color: var(--accent); border: 1px solid var(--accent); border-radius: 8px; font-size: 0.75rem; font-weight: 600; text-decoration: none; transition: transform 0.2s ease, box-shadow 0.2s ease; cursor: pointer;" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(157, 140, 255, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
                  랭커 추천 스킬 보기 >
                </a>
              </div>

              <div id="skills-active-section" class="skill-category-card" style="margin-bottom: 1.25rem;">
                <div class="skill-category-header">액티브 스킬</div>
                <div id="skills-active-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;"></div>
              </div>
              
              <div id="skills-passive-section" class="skill-category-card" style="margin-bottom: 1.25rem;">
                <div class="skill-category-header">패시브 스킬</div>
                <div id="skills-passive-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;"></div>
              </div>
              
              <div id="skills-stigma-section" class="skill-category-card" style="margin-bottom: 1.25rem;">
                <div class="skill-category-header" id="stigma-header">스티그마</div>
                <div id="stigmas-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 0.75rem; margin-top: 0.5rem;"></div>
              </div>
              
              <div id="stats-section" class="skill-category-card" style="display: none;">
                <div class="skill-category-header" id="stats-header">스탯</div>
                <div id="stats-container" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.4rem; margin-top: 0.5rem;"></div>
              </div>
              
              <div id="normal-stats-section" class="skill-category-card" style="display: none; margin-top: 1.25rem;">
                <div class="skill-category-header" id="normal-stats-header">일반 스탯</div>
                <div id="normal-stats-container" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.4rem; margin-top: 0.5rem;"></div>
              </div>
            </div>
            </div>
            
            <!-- 데바니온 탭 패널 -->
            <div class="character-tab-card character-tab-panel" id="panel-daevanion" style="display: none;">
              <!-- 데바니온 서브탭 -->
              <div class="daevanion-subtabs" style="display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; align-items: flex-start;">
                <button class="daevanion-subtab-btn active" data-boardid="41" style="padding: 0.5rem 1rem; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(157, 140, 255, 0.12); border-color: rgba(157, 140, 255, 0.3); color: var(--accent); cursor: pointer; border-radius: 8px; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">
                  네자칸
                </button>
                <button class="daevanion-subtab-btn" data-boardid="42" style="padding: 0.5rem 1rem; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.04); color: var(--text-muted); cursor: pointer; border-radius: 8px; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">
                  지켈
                </button>
                <button class="daevanion-subtab-btn" data-boardid="43" style="padding: 0.5rem 1rem; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.04); color: var(--text-muted); cursor: pointer; border-radius: 8px; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">
                  바이젤
                </button>
                <button class="daevanion-subtab-btn" data-boardid="44" style="padding: 0.5rem 1rem; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.04); color: var(--text-muted); cursor: pointer; border-radius: 8px; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">
                  트리니엘
                </button>
                <button class="daevanion-subtab-btn" data-boardid="45" style="padding: 0.5rem 1rem; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.04); color: var(--text-muted); cursor: pointer; border-radius: 8px; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">
                  아리엘
                </button>
                <button class="daevanion-subtab-btn" data-boardid="46" style="padding: 0.5rem 1rem; border: 1px solid rgba(255, 255, 255, 0.1); background: rgba(255, 255, 255, 0.04); color: var(--text-muted); cursor: pointer; border-radius: 8px; font-size: 0.85rem; font-weight: 500; transition: all 0.2s;">
                  아스펠
                </button>
              </div>
              
              <!-- 데바니온 정보 표시 영역 -->
              <div id="daevanion-content" style="min-height: 200px;">
                <div style="text-align: center; color: var(--text-muted); padding: 2rem;">
                  서브탭을 선택하여 데바니온 정보를 확인하세요.
                </div>
              </div>
            </div>
            
            <!-- 성장기록 탭 패널 -->
            <div class="character-tab-card character-tab-panel" id="panel-growth-history" style="display: none;">
              <div id="growth-history-content" style="min-height: 400px; width: 100%; max-width: 100%; overflow: hidden;">
                <div style="text-align: center; color: var(--text-muted); padding: 2rem;">
                  성장도표를 불러오는 중...
                </div>
              </div>
            </div>
          </div>
          </article>
        </div>
        
        <!-- 로딩 상태 (숨김) -->
        <div id="character-loading" class="empty-state" style="display: none;">
          검색 중...
        </div>
        
        <!-- 에러 상태 -->
        <div id="character-error" class="empty-state" style="display: none !important;">
        </div>
      </section>
      
      <!-- 전체 화면 로딩 오버레이 -->
      <div id="fullscreen-loading-overlay" style="display: none;">
        <div class="loading-spinner-container">
          <div class="loading-spinner"></div>
          <div class="loading-dots">
            <span>검색 중</span>
            <span class="dot">.</span>
            <span class="dot">.</span>
            <span class="dot">.</span>
          </div>
        </div>
      </div>

      <!-- 서버 데이터를 HTML data 속성으로 전달 -->
      <script type="application/json" id="server-data">
{"asmodian": [{"id": 2001, "name": "\uc774\uc2a4\ub77c\ud3a0"}, {"id": 2002, "name": "\uc9c0\ucf08"}, {"id": 2003, "name": "\ud2b8\ub9ac\ub2c8\uc5d8"}, {"id": 2004, "name": "\ub8e8\ubbf8\uc5d8"}, {"id": 2005, "name": "\ub9c8\ub974\ucfe0\ud0c4"}, {"id": 2006, "name": "\uc544\uc2a4\ud3a0"}, {"id": 2007, "name": "\uc5d0\ub808\uc288\ud0a4\uac08"}, {"id": 2008, "name": "\ube0c\ub9ac\ud2b8\ub77c"}, {"id": 2009, "name": "\ub124\ubaac"}, {"id": 2010, "name": "\ud558\ub2ec"}, {"id": 2011, "name": "\ub8e8\ub4dc\ub77c"}, {"id": 2012, "name": "\uc6b8\uace0\ub978"}, {"id": 2013, "name": "\ubb34\ub2cc"}, {"id": 2014, "name": "\uc624\ub2e4\ub974"}, {"id": 2015, "name": "\uc820\uce74\uce74"}, {"id": 2016, "name": "\ud06c\ub85c\uba54\ub370"}, {"id": 2017, "name": "\ucf70\uc774\ub9c1"}, {"id": 2018, "name": "\ubc14\ubc14\ub8fd"}, {"id": 2019, "name": "\ud30c\ud504\ub2c8\ub974"}, {"id": 2020, "name": "\uc778\ub4dc\ub098\ud750"}, {"id": 2021, "name": "\uc774\uc2a4\ud560\uac90"}], "elyos": [{"id": 1001, "name": "\uc2dc\uc5d8"}, {"id": 1002, "name": "\ub124\uc790\uce78"}, {"id": 1003, "name": "\ubc14\uc774\uc824"}, {"id": 1004, "name": "\uce74\uc774\uc2dc\ub12c"}, {"id": 1005, "name": "\uc720\uc2a4\ud2f0\uc5d8"}, {"id": 1006, "name": "\uc544\ub9ac\uc5d8"}, {"id": 1007, "name": "\ud504\ub808\uae30\uc628"}, {"id": 1008, "name": "\uba54\uc2a4\ub78c\ud0c0\uc5d0\ub2e4"}, {"id": 1009, "name": "\ud788\ud0c0\ub2c8\uc5d0"}, {"id": 1010, "name": "\ub098\ub2c8\uc544"}, {"id": 1011, "name": "\ud0c0\ud558\ubc14\ud0c0"}, {"id": 1012, "name": "\ub8e8\ud130\uc2a4"}, {"id": 1013, "name": "\ud398\ub974\ub178\uc2a4"}, {"id": 1014, "name": "\ub2e4\ubbf8\ub204"}, {"id": 1015, "name": "\uce74\uc0ac\uce74"}, {"id": 1016, "name": "\ubc14\uce74\ub974\ub9c8"}, {"id": 1017, "name": "\ucc48\uac00\ub8fd"}, {"id": 1018, "name": "\ucf54\uce58\ub8fd"}, {"id": 1019, "name": "\uc774\uc288\ud0c0\ub974"}, {"id": 1020, "name": "\ud2f0\uc544\ub9c8\ud2b8"}, {"id": 1021, "name": "\ud3ec\uc5d0\ud0c0"}]}
      </script>
      
      <!-- 랭킹 패널 -->
      <section id="panel-ranking" class="tab-panel">
        <!-- <p class="badge" style="margin-bottom: 0.75rem;">랭킹</p> -->
        <div class="card-grid" style="grid-column: 1 / -1;">
          <article class="hero-card" style="grid-column: 1 / -1;">
            <div>
            </div>
            <div>
              <!-- 랭킹 서브 탭 -->
              <div class="statistics-sub-tabs">
                <a href="/ranking" class="statistics-sub-tab-btn active" data-target="combat-power-ranking">전투력 랭킹</a>
                <a href="/ranking/farming/title" class="statistics-sub-tab-btn" data-target="farming-ranking" style="position: relative;">
                  내실 랭킹
                </a>
                <a href="/ranking/combat-score" class="statistics-sub-tab-btn combat-score-ranking-special" data-target="combat-score-ranking">
                  아툴 전투 점수 랭킹
                  <span class="new-badge">HOT</span>
                </a>
                <a href="/ranking/contents/abyss" class="statistics-sub-tab-btn" data-target="contents-ranking">컨텐츠 랭킹</a>
                <a href="/ranking/region" class="statistics-sub-tab-btn" data-target="region-ranking">레기온 랭킹</a>
              </div>

              <!-- 1. 전투력 랭킹 컨텐츠 -->
              <div id="combat-power-ranking-content" style="">
              <div style="margin-bottom: 1rem;">
                <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">직업 필터</div>
                <div class="ranking-filters" id="ranking-job-filters">
                  <button class="ranking-filter-btn active" data-filter-type="job" data-value="all">전체</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="검성">검성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="수호성">수호성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="궁성">궁성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="살성">살성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="마도성">마도성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="정령성">정령성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="치유성">치유성</button>
                  <button class="ranking-filter-btn" data-filter-type="job" data-value="호법성">호법성</button>
                </div>
              </div>
              <div>
                <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 필터</div>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                  <button class="ranking-server-tab-btn active" data-race="all">전체</button>
                  <button class="ranking-server-tab-btn" data-race="elyos">천족</button>
                  <button class="ranking-server-tab-btn" data-race="asmodian">마족</button>
                </div>
                <div class="ranking-filters" id="ranking-server-filters">
                  <button class="ranking-filter-btn active" data-filter-type="server" data-value="all">전체</button>
                </div>
              </div>

              <!-- [제거됨] 전투력 구간 필터 - slow query 유발 및 캐시 효율 저하 -->
              
              <div id="ranking-container">
                <table class="ranking-list" id="ranking-table">
                  <thead>
                    <tr>
                      <th class="col-rank">순위</th>
                      <th class="col-nickname">닉네임</th>
                      <th class="col-job">직업</th>
                      <th class="col-race">종족</th>
                      <th class="col-server">서버</th>
                      <th class="col-guild">레기온</th>
                      <th class="col-power">전투력</th>
                    </tr>
                  </thead>
                  <tbody id="ranking-body">
                    <tr>
                      <td colspan="7" style="text-align:center; padding:1rem;">아직 랭킹 데이터가 없습니다. 먼저 캐릭터를 검색해보세요.</td>
                    </tr>
                  </tbody>
                </table>
                <div id="ranking-pagination" class="pagination-container" style="display: none; margin-top: 1.5rem; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;"></div>
              </div>
              </div>

              <!-- 2. 내실 랭킹 컨텐츠 -->
              <div id="internal-ranking-content" style="display: none;">
                <!-- 내실 랭킹 서브 탭 (타이틀, 스티그마 샤드, 주신스탯합) -->
                <div class="statistics-sub-tabs" style="margin-bottom: 1rem;">
                  <a href="/ranking/farming/title" class="statistics-sub-tab-btn internal-sub-tab active" data-internal-type="title">타이틀</a>
                  <a href="/ranking/farming/stigma" class="statistics-sub-tab-btn internal-sub-tab" data-internal-type="stigma">스티그마 샤드</a>
                  <a href="/ranking/farming/total_stat" class="statistics-sub-tab-btn internal-sub-tab" data-internal-type="total_stat">주신스탯합</a>
                </div>

                <!-- 필터 영역 (전투력 랭킹과 동일) -->
                <div style="margin-bottom: 1rem;">
                  <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">직업 필터</div>
                  <div class="ranking-filters" id="internal-ranking-job-filters">
                    <button class="ranking-filter-btn active" data-filter-type="job" data-value="all">전체</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="검성">검성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="수호성">수호성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="궁성">궁성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="살성">살성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="마도성">마도성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="정령성">정령성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="치유성">치유성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="호법성">호법성</button>
                  </div>
                </div>
                <div>
                  <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 필터</div>
                  <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <button class="ranking-server-tab-btn internal-server-tab active" data-race="all">전체</button>
                    <button class="ranking-server-tab-btn internal-server-tab" data-race="elyos">천족</button>
                    <button class="ranking-server-tab-btn internal-server-tab" data-race="asmodian">마족</button>
                  </div>
                  <div class="ranking-filters" id="internal-ranking-server-filters">
                    <button class="ranking-filter-btn active" data-filter-type="server" data-value="all">전체</button>
                  </div>
                </div>

                <div id="internal-ranking-container">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div></div>
                    <div id="internal-ranking-last-update" style="font-size: 0.85rem; color: var(--text-muted);"></div>
                  </div>
                  <table class="ranking-list" id="internal-ranking-table">
                    <thead>
                      <tr>
                        <th class="col-rank">순위</th>
                        <th class="col-nickname">닉네임</th>
                        <th class="col-job">직업</th>
                        <th class="col-race">종족</th>
                        <th class="col-server">서버</th>
                        <th class="col-guild">레기온</th>
                        <th class="col-power">전투력</th>
                        <th class="col-power" id="internal-ranking-value-header">타이틀</th>
                      </tr>
                    </thead>
                    <tbody id="internal-ranking-body">
                      <tr>
                        <td colspan="8" style="text-align:center; padding:1rem;">내실 랭킹 데이터를 불러오는 중...</td>
                      </tr>
                    </tbody>
                  </table>
                  <div id="internal-ranking-pagination" class="pagination-container" style="display: none; margin-top: 1.5rem; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;"></div>
                </div>
              </div>

              <!-- 3. 아툴 전투 점수 랭킹 컨텐츠 -->
              <div id="combat-score-ranking-content" style="display: none;">
                <!-- 필터 영역 (전투력 랭킹과 동일) -->
                <div style="margin-bottom: 1rem;">
                  <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">직업 필터</div>
                  <div class="ranking-filters" id="combat-score-ranking-job-filters">
                    <button class="ranking-filter-btn active" data-filter-type="job" data-value="all">전체</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="검성">검성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="수호성">수호성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="궁성">궁성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="살성">살성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="마도성">마도성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="정령성">정령성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="치유성">치유성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="호법성">호법성</button>
                  </div>
                </div>
                <div>
                  <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 필터</div>
                  <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <button class="ranking-server-tab-btn combat-score-server-tab active" data-race="all">전체</button>
                    <button class="ranking-server-tab-btn combat-score-server-tab" data-race="elyos">천족</button>
                    <button class="ranking-server-tab-btn combat-score-server-tab" data-race="asmodian">마족</button>
                  </div>
                  <div class="ranking-filters" id="combat-score-ranking-server-filters">
                    <button class="ranking-filter-btn active" data-filter-type="server" data-value="all">전체</button>
                  </div>
                </div>

                <div id="combat-score-ranking-container">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div></div>
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.25rem;">
                      <div id="combat-score-ranking-last-update" style="font-size: 0.85rem; color: var(--text-muted);"></div>
                    </div>
                  </div>
                  <table class="ranking-list" id="combat-score-ranking-table">
                    <thead>
                      <tr>
                        <th class="col-rank">순위</th>
                        <th class="col-nickname">닉네임</th>
                        <th class="col-job">직업</th>
                        <th class="col-race">종족</th>
                        <th class="col-server">서버</th>
                        <th class="col-guild">레기온</th>
                        <th class="col-power">전투력</th>
                        <th class="col-power">아툴 전투 점수<br>(최고 기준)</th>
                      </tr>
                    </thead>
                    <tbody id="combat-score-ranking-body">
                      <tr>
                        <td colspan="8" style="text-align:center; padding:1rem;">아툴 전투 점수 랭킹 데이터를 불러오는 중...</td>
                      </tr>
                    </tbody>
                  </table>
                  <div id="combat-score-ranking-pagination" class="pagination-container" style="display: none; margin-top: 1.5rem; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;"></div>
                </div>
              </div>

              <!-- 4. 컨텐츠 랭킹 컨텐츠 -->
              <div id="contents-ranking-content" style="display: none;">
                <!-- 컨텐츠 랭킹 서브 탭 (7개 컨텐츠) -->
                <div class="statistics-sub-tabs" style="margin-bottom: 1rem;">
                  <a href="/ranking/contents/abyss" class="statistics-sub-tab-btn contents-sub-tab active" data-content-type="abyss">어비스</a>
                  <a href="/ranking/contents/solo_arena" class="statistics-sub-tab-btn contents-sub-tab" data-content-type="solo_arena">고독의 투기장</a>
                  <a href="/ranking/contents/coop_arena" class="statistics-sub-tab-btn contents-sub-tab" data-content-type="coop_arena">협력의 투기장</a>
                  <a href="/ranking/contents/nightmare" class="statistics-sub-tab-btn contents-sub-tab" data-content-type="nightmare">악몽</a>
                  <a href="/ranking/contents/transcendence" class="statistics-sub-tab-btn contents-sub-tab" data-content-type="transcendence">초월</a>
                  <a href="/ranking/contents/awakening" class="statistics-sub-tab-btn contents-sub-tab" data-content-type="awakening">각성전</a>
                  <a href="/ranking/contents/subjugation" class="statistics-sub-tab-btn contents-sub-tab" data-content-type="subjugation">토벌전</a>
                </div>

                <!-- 필터 영역 (전투력 랭킹과 동일) -->
                <div style="margin-bottom: 1rem;">
                  <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">직업 필터</div>
                  <div class="ranking-filters" id="contents-ranking-job-filters">
                    <button class="ranking-filter-btn active" data-filter-type="job" data-value="all">전체</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="검성">검성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="수호성">수호성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="궁성">궁성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="살성">살성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="마도성">마도성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="정령성">정령성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="치유성">치유성</button>
                    <button class="ranking-filter-btn" data-filter-type="job" data-value="호법성">호법성</button>
                  </div>
                </div>
                <div>
                  <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 필터</div>
                  <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <button class="ranking-server-tab-btn contents-server-tab active" data-race="all">전체</button>
                    <button class="ranking-server-tab-btn contents-server-tab" data-race="elyos">천족</button>
                    <button class="ranking-server-tab-btn contents-server-tab" data-race="asmodian">마족</button>
                  </div>
                  <div class="ranking-filters" id="contents-ranking-server-filters">
                    <button class="ranking-filter-btn active" data-filter-type="server" data-value="all">전체</button>
                  </div>
                </div>

                <div id="contents-ranking-container">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <div></div>
                    <div id="contents-ranking-last-update" style="font-size: 0.85rem; color: var(--text-muted);"></div>
                  </div>
                  <table class="ranking-list" id="contents-ranking-table">
                    <thead>
                      <tr>
                        <th class="col-rank">순위</th>
                        <th class="col-nickname">닉네임</th>
                        <th class="col-job">직업</th>
                        <th class="col-race">종족</th>
                        <th class="col-server">서버</th>
                        <th class="col-guild">레기온</th>
                        <th class="col-power" id="contents-ranking-value-header" style="text-align: right;">점수</th>
                      </tr>
                    </thead>
                    <tbody id="contents-ranking-body">
                      <tr>
                        <td colspan="7" style="text-align:center; padding:1rem;">컨텐츠 랭킹 데이터를 불러오는 중...</td>
                      </tr>
                    </tbody>
                  </table>
                  <div id="contents-ranking-pagination" class="pagination-container" style="display: none; margin-top: 1.5rem; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;"></div>
                </div>
              </div>

              <!-- 5. 레기온 랭킹 컨텐츠 -->
              <div id="region-ranking-content" style="display: none;">
                <!-- 리스트 뷰 -->
                <div id="region-ranking-list-view">
                  <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 8px; color: var(--text-muted); font-size: 0.9rem;">
                    ⚠️ 주의: 아툴 DB에 포함된 캐릭터만 세기 때문에 실제 레기온 인원수와 다를 수 있습니다.
                  </div>
                  <div style="margin-bottom: 1rem;">
                    <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 필터</div>
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                      <button class="ranking-server-tab-btn active" id="region-race-all" data-race="all">전체</button>
                      <button class="ranking-server-tab-btn" id="region-race-elyos" data-race="elyos">천족</button>
                      <button class="ranking-server-tab-btn" id="region-race-asmodian" data-race="asmodian">마족</button>
                    </div>
                    <div class="ranking-filters" id="region-server-filters" style="display: none;">
                      <button class="ranking-filter-btn active" data-filter-type="server" data-value="all">전체</button>
                    </div>
                  </div>
                  <div style="margin-bottom: 1rem;">
                    <div style="font-size: 1rem; color: var(--text-muted); margin-bottom: 0.5rem;">레기온 검색</div>
                    <div style="display: flex; gap: 0.5rem;">
                      <input type="text" id="region-search-input" placeholder="레기온명 입력" style="flex: 1; padding: 0.5rem; border-radius: 8px; border: 1px solid var(--card-border); background: rgba(255, 255, 255, 0.05); color: var(--text-primary); font-size: 0.95rem;">
                      <button type="button" id="region-search-button" class="stat-apply-button">검색</button>
                    </div>
                  </div>
                  <div id="region-ranking-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                      <div></div>
                      <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.25rem;">
                        <div id="region-ranking-update-time" style="font-size: 0.85rem; color: var(--text-muted);"></div>
                      </div>
                    </div>
                    <table class="ranking-list" id="region-ranking-table">
                      <thead>
                        <tr>
                          <th class="col-rank">순위</th>
                          <th class="col-nickname">레기온명</th>
                          <th class="col-server">서버</th>
                          <th class="col-power">인원수</th>
                          <th class="col-power">총 전투력</th>
                        </tr>
                      </thead>
                      <tbody id="region-ranking-body">
                        <tr>
                          <td colspan="5" style="text-align:center; padding:1rem;">레기온 랭킹 데이터를 불러오는 중...</td>
                        </tr>
                      </tbody>
                    </table>
                    <div id="region-ranking-pagination" class="pagination-container" style="display: none; margin-top: 1.5rem; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;"></div>
                  </div>
                </div>
                <!-- 상세 뷰 -->
                <div id="region-ranking-detail-view" style="display: none;"></div>
              </div>
            </div>
        </article>
        </div>
      </section>

      <section id="panel-statistics" class="tab-panel">
        <!-- <p class="badge" style="margin-bottom: 0.75rem;">통계</p> -->
        <div class="card-grid" style="grid-column: 1 / -1;">
          <article class="hero-card" style="grid-column: 1 / -1;">
            <div>
            </div>

            <!-- 통계 서브 탭 -->
            <div class="statistics-sub-tabs">
              <a href="/statistics/jobstats" class="statistics-sub-tab-btn" data-target="job-statistics">직업 통계</a>
              <a href="/statistics/skill" class="statistics-sub-tab-btn" data-target="skill-statistics">
                스킬 통계
              </a>
              <a href="/statistics/item" class="statistics-sub-tab-btn" data-target="item-statistics">
                아이템 통계
              </a>
            </div>

            <!-- 1. 직업 통계 컨텐츠 -->
            <div id="job-statistics-content" style="">

              <div class="statistics-controls">
                <div class="stat-filter-row">
                  <span class="stat-filter-label">전투력 구간</span>
                  <input type="number" id="stat-min-input" class="stat-range-input" value="0" min="0" max="4999">
                  <div class="dual-range">
                    <div class="dual-range-track" id="stat-range-track"></div>
                    <input type="range" id="stat-range-min" min="0" max="5000" value="0" step="1">
                    <input type="range" id="stat-range-max" min="0" max="5000" value="4999" step="1">
                  </div>
                  <input type="number" id="stat-max-input" class="stat-range-input" value="4999" min="0" max="5000">
                  <button type="button" id="stat-apply-button" class="stat-apply-button">적용</button>
                </div>
                <p class="stat-range-summary" id="stat-range-summary">0 ~ 4,999 전투력 기준</p>
              </div>
              <div class="statistics-desc-wrap" style="margin-top: 0.3rem; margin-bottom: 1.2rem;">
                <p class="statistics-desc" id="job-stat-desc">슬라이더로 전투력 범위를 지정하고 해당 구간의 직업 분포를 확인하세요.</p>
              </div>

              <div id="job-statistics-update-info" style="text-align: center; color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1rem; min-height: 1.2rem;"></div>

              <div id="job-statistics-container" style="min-height: 200px;">
                <p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>
              </div>
            </div>

            <!-- 2. 스킬 통계 컨텐츠 -->
            <div id="skill-statistics-content" style="display: none;">

              <div class="skill-stats-class-selector">
                <button class="skill-stats-class-btn active" data-job="검성">검성</button>
                <button class="skill-stats-class-btn" data-job="수호성">수호성</button>
                <button class="skill-stats-class-btn" data-job="살성">살성</button>
                <button class="skill-stats-class-btn" data-job="궁성">궁성</button>
                <button class="skill-stats-class-btn" data-job="마도성">마도성</button>
                <button class="skill-stats-class-btn" data-job="정령성">정령성</button>
                <button class="skill-stats-class-btn" data-job="치유성">치유성</button>
                <button class="skill-stats-class-btn" data-job="호법성">호법성</button>
              </div>

              <div style="display: flex; justify-content: space-between; align-items: left; margin-bottom: 1.75rem; flex-wrap: wrap; gap: 1rem;">
                <div class="skill-stats-legend">
                  <div class="statistics-desc-wrap" style="flex-basis: 100%; margin-top: 0.4rem; margin-bottom: 0.6rem;">
                    <p class="statistics-desc" id="skill-stat-desc" style="display: none;">1~100위 랭커들의 고투자 스킬 채용률을 확인하세요.</p>
                  </div>
                  <div class="skill-stats-legend-item">
                    <div class="skill-stats-legend-dot skill-stats-bar-high"></div>
                    <span>고투자 (20+/Stigma 15+)</span>
                  </div>
                  <div class="skill-stats-legend-item">
                    <div class="skill-stats-legend-dot skill-stats-bar-mid"></div>
                    <span>중투자 (16~19/Stigma 10~14)</span>
                  </div>
                  <div class="skill-stats-legend-item">
                    <div class="skill-stats-legend-dot skill-stats-bar-low"></div>
                    <span>저투자 (미만)</span>
                  </div>
                </div>
                <div id="skill-stats-last-update" style="font-size: 0.85rem; color: var(--text-muted);">
                  마지막 업데이트: -
                </div>
              </div>

              <div class="skill-stats-grid" id="skill-stats-container">
                <div style="grid-column: 1/-1; text-align: center; padding: 3rem; color: var(--text-muted);">
                  데이터를 불러오는 중...
                </div>
              </div>
            </div>

            <!-- 3. 아이템 통계 컨텐츠 -->
            <div id="item-statistics-content" style="display: none;">
              <!-- 직업 필터 -->
              <div class="skill-stats-class-selector" style="margin-bottom: 1.5rem;">
                <button class="skill-stats-class-btn active" data-job="전체">전체</button>
                <button class="skill-stats-class-btn" data-job="검성">검성</button>
                <button class="skill-stats-class-btn" data-job="수호성">수호성</button>
                <button class="skill-stats-class-btn" data-job="살성">살성</button>
                <button class="skill-stats-class-btn" data-job="궁성">궁성</button>
                <button class="skill-stats-class-btn" data-job="마도성">마도성</button>
                <button class="skill-stats-class-btn" data-job="정령성">정령성</button>
                <button class="skill-stats-class-btn" data-job="치유성">치유성</button>
                <button class="skill-stats-class-btn" data-job="호법성">호법성</button>
              </div>

              <!-- 전투력 구간 필터 -->
              <div class="statistics-controls">
                <div class="stat-filter-row">
                  <span class="stat-filter-label">전투력 구간</span>
                  <input type="number" id="item-stat-min-input" class="stat-range-input" value="0" min="0" max="4999">
                  <div class="dual-range">
                    <div class="dual-range-track" id="item-stat-range-track"></div>
                    <input type="range" id="item-stat-range-min" min="0" max="5000" value="0" step="1">
                    <input type="range" id="item-stat-range-max" min="0" max="5000" value="4999" step="1">
                  </div>
                  <input type="number" id="item-stat-max-input" class="stat-range-input" value="4999" min="0" max="5000">
                  <button type="button" id="item-stat-apply-button" class="stat-apply-button">적용</button>
                </div>
                <p class="stat-range-summary" id="item-stat-range-summary">0 ~ 4,999 전투력 기준</p>
              </div>

              <!-- <div class="statistics-desc-wrap" style="margin-top: 0.3rem; margin-bottom: 1.2rem;">
                <p class="statistics-desc" style="color: #ffffff;">랭커들이 사용하는 아르카나 세트 옵션과 장비 통계를 확인하세요.</p>
              </div> -->

              <div id="item-statistics-update-info" style="text-align: center; color: #ffffff; font-size: 0.85rem; margin-bottom: 1rem; min-height: 1.2rem;"></div>

              <div id="item-statistics-container" style="min-height: 200px;">
                <p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>
              </div>
            </div>
          </article>
        </div>
      </section>

    </div>
  </section>
  </section>

  <!-- 우측 배너: 서버 정보 -->
  <aside class="sidebar-banner sidebar-right">
    <!-- 키나 시세 카드 (임시 주석 처리) -->
    <!--
    <p class="badge" style="margin-bottom: 0.5rem; margin-top: 0; padding-top: 0;">💎 큐나 시세</p>
    <a href="/quna-chart" style="text-decoration: none; display: block; cursor: pointer;">
      <article class="hero-card" style="margin: 0 0 1rem 0;">
        <div id="kinah-price-container" style="display: flex; flex-direction: column; gap: 0.75rem;">
          <p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">로딩 중...</p>
        </div>
      </article>
    </a>
    -->
    <!-- 컨텐츠 타이머 (임시 주석 처리) -->
    <!--
    <p class="badge" style="margin-bottom: 0.5rem; margin-top: 0;">⏰ 컨텐츠 타이머</p>
    <article class="hero-card" style="margin: 0 0 0.75rem 0;">
      <div style="display: flex; flex-direction: column; gap: 0.5rem;">
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div style="font-weight: 600;">슈고페스타</div>
          <div id="shugo-countdown" style="font-weight: 700; color: var(--accent);">--:--</div>
        </div>
        <div style="display: flex; align-items: center; justify-content: space-between;">
          <div style="font-weight: 600;">시공의 균열</div>
          <div id="rift-countdown" style="font-weight: 700; color: var(--accent-strong);">--:--</div>
        </div>
      </div>
    </article>
    -->
    <p class="badge" style="margin-bottom: 0.5rem; margin-top: 0 !important; padding-top: 0 !important;">🌐 서버 정보</p>
    <div style="display: flex; align-items: center; justify-content: flex-end; margin-bottom: 0.75rem; margin-top: -2.5rem;">
      <a href="/server-comparison" style="padding: 0.4rem 0.8rem; background: transparent; color: var(--accent); border: 1px solid var(--accent); border-radius: 8px; font-size: 0.75rem; font-weight: 600; text-decoration: none; transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(157, 140, 255, 0.3)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">서버 우세 현황 보기 ></a>
    </div>
    <article class="hero-card" style="margin: 0; height: 100%;">
      <div>
        <!-- <h3 style="font-size: 1.2rem; margin-bottom: 1rem;">아이온2 전략 허브</h3> -->
        <div id="server-stats" style="min-height: auto; overflow-y: visible;">
          <p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>
        </div>
      </div>
        </article>
  </aside>
    </div>

<script>
// ========== 공통 URL 라우팅 유틸리티 ==========
// URL 업데이트 함수 (실제 URL로 변경, 페이지 리로드)
function updateURL(hash, replace = false, clearPathname = false) {
  let newURL;
  if (clearPathname || hash) {
    // 실제 URL 경로로 변경
    if (hash === 'character' || hash === '') {
      newURL = '/';
    } else if (hash === 'ranking') {
      newURL = '/ranking';
    } else if (hash === 'statistics') {
      newURL = '/statistics';
    } else if (hash.startsWith('ranking/')) {
      newURL = '/ranking';
    } else if (hash.startsWith('statistics/')) {
      newURL = '/statistics';
    } else {
      newURL = hash ? `/${hash}` : '/';
    }
  } else {
    // 기존 pathname 유지하되 해시는 실제 URL로 변경
    if (hash === 'character' || hash === '') {
      newURL = '/';
    } else if (hash === 'ranking') {
      newURL = '/ranking';
    } else if (hash === 'statistics') {
      newURL = '/statistics';
    } else if (hash.startsWith('ranking/')) {
      newURL = '/ranking';
    } else if (hash.startsWith('statistics/')) {
      newURL = '/statistics';
    } else {
      newURL = hash ? `/${hash}` : window.location.pathname;
    }
  }
  if (replace) {
    window.history.replaceState(null, '', newURL);
  } else {
    window.history.pushState(null, '', newURL);
  }
  // 무한 루프 방지: updateURL에서 activateTabByPath 호출 제거
  // 탭 활성화는 탭 클릭 이벤트나 페이지 로드 시에만 수행
}

// URL에서 해시 파싱 함수
function parseHash() {
  const hash = window.location.hash.substring(1); // # 제거
  if (!hash) return null;
  
  const parts = hash.split('/');
  return {
    tab: parts[0] || null,
    params: parts.slice(1) || []
  };
}

// 랭킹 탭 URL 생성
function buildRankingURL(job, server, race) {
  const parts = ['ranking'];
  if (job && job !== 'all') parts.push(job);
  if (race && race !== 'all') {
    parts.push(race === 'elyos' ? '천족' : race === 'asmodian' ? '마족' : race);
  }
  if (server && server !== 'all') parts.push(server);
  return parts.join('/');
}

// 내실 랭킹 URL 생성
function buildInternalRankingURL(type, job, race, server) {
  const parts = ['ranking', 'farming'];
  
  // 서브타입 매핑 (title, stigma, total_stat)
  const typeMap = {
    'title': 'title',
    'stigma': 'stigma',
    'total_stat': 'total_stat'
  };
  const typeValue = typeMap[type] || 'title';
  parts.push(typeValue);
  
  if (job && job !== 'all') parts.push(job);
  if (race && race !== 'all') {
    parts.push(race === 'elyos' ? '천족' : race === 'asmodian' ? '마족' : race);
  }
  if (server && server !== 'all') parts.push(server);
  
  return parts.join('/');
}

// 통계 탭 URL 생성
function buildStatisticsURL(subtab) {
  if (subtab === 'skillstat' || subtab === 'skill-statistics') {
    return 'statistics/skillstat';
  }
  if (subtab === 'itemstats' || subtab === 'item-statistics') {
    return 'statistics/itemstats';
  }
  return 'statistics/jobstats';
}

// 티어 탭 URL 생성
function buildTierURL(subtab) {
  if (subtab === 'ranker' || subtab === 'ranker-tier') {
    return 'tier/ranker';
  }
  return 'tier/combatpower';
}

// 스펙 비교 탭 URL 생성
function buildCompareURL(char1, char2) {
  if (!char1 || !char2) return 'compare';
  const encodeChar = (c) => encodeURIComponent(c.nickname || '') + '/' + (c.race || '') + '/' + (c.server || '');
  return `compare/${encodeChar(char1)}/${encodeChar(char2)}`;
}

// 서버 비교 탭 URL 생성
function buildServerComparisonURL(matchId) {
  if (!matchId || matchId === 'all') return 'server-comparison';
  return `server-comparison/${matchId}`;
}

// 캐릭터 검색 URL 생성
function buildCharacterURL(nickname, serverId, race) {
  if (!nickname || !serverId) return null;
  return `char/serverid=${serverId}/${encodeURIComponent(nickname)}`;
}

// URL에서 상태 복원 함수
function restoreStateFromURL() {
  const hash = window.location.hash.substring(1);
  
  // char/serverid=xxx/닉네임 형식 처리
  if (hash.startsWith('char/serverid=')) {
    const charMatch = hash.match(/^char\/serverid=(\d+)\/(.+)$/);
    if (charMatch) {
      const serverId = charMatch[1];
      const nickname = decodeURIComponent(charMatch[2]);
      
      // 서버 정보 찾기
      const serverDataEl = document.getElementById('server-data');
      let servers = { elyos: [], asmodian: [] };
      if (serverDataEl && serverDataEl.textContent) {
        try {
          servers = JSON.parse(serverDataEl.textContent);
        } catch (e) {
        }
      }
      
      let race = null;
      let server = null;
      for (const serverList of [servers.elyos || [], servers.asmodian || []]) {
        for (const s of serverList) {
          if (s.id == serverId) {
            server = s.id;
            race = servers.elyos && servers.elyos.some(es => es.id == serverId) ? '1' : '2';
            break;
          }
        }
        if (race) break;
      }
      
      if (nickname && race && server) {
        const characterTab = document.getElementById('tab-character');
        if (characterTab) {
          characterTab.checked = true;
          characterTab.dispatchEvent(new Event('change'));
          updateSidebarVisibility();
          
          // 검색 폼에 값 설정
          const serverSelect = document.getElementById('server-select');
          const keywordInput = document.getElementById('character-keyword');
          
          // 종족 버튼 업데이트 (캐릭터 링크 클릭이므로 localStorage에 저장하지 않음)
          if (race) {
            updateRaceSelection(race, true);
          }
          
          setTimeout(() => {
            if (serverSelect) {
              serverSelect.value = server;
              if (keywordInput) keywordInput.value = nickname;
              
              // 로딩 표시 유지
              document.getElementById('character-loading').style.display = 'block';
              const hashLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
              if (hashLoadingOverlay) {
                hashLoadingOverlay.style.display = 'flex';
              }
              
              // 검색 실행
              performSearch();
            }
          }, 300);
        }
        return;
      }
    }
  }
  
  const parsed = parseHash();
  if (!parsed) return;
  
  const { tab, params } = parsed;
  
  // 랭킹 탭
  if (tab === 'ranking') {
    // 컨텐츠 랭킹 서브탭 체크
    if (params.length > 0 && params[0] === 'contentsRanking') {
      const rankingTab = document.getElementById('tab-ranking');
      if (rankingTab) {
        rankingTab.checked = true;
        rankingTab.dispatchEvent(new Event('change'));
        
        // 컨텐츠 랭킹 탭 활성화
        setTimeout(() => {
          const contentsTab = document.querySelector('#panel-ranking .statistics-sub-tab-btn[data-target="contents-ranking"]');
          if (contentsTab) {
            contentsTab.click();
            
            // URL 파라미터에서 필터 복원
            const urlParams = new URLSearchParams(window.location.search);
            const contentType = urlParams.get('contentType') || 'abyss';
            const job = urlParams.get('job') || 'all';
            const race = urlParams.get('race') || 'all';
            const server = urlParams.get('server') || 'all';
            const page = parseInt(urlParams.get('page')) || 1;
            
            setTimeout(() => {
              if (typeof initializeContentsRankingFilters === 'function') {
                initializeContentsRankingFilters();
              }
              
              // 필터 상태 복원
              currentContentsRankingType = contentType;
              currentContentsJobFilter = job;
              currentContentsServerRaceFilter = race;
              currentContentsServerFilter = server;
              currentContentsPage = page;
              
              // 서브탭 활성화
              const contentsSubTabs = document.querySelectorAll('.contents-sub-tab');
              contentsSubTabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.contentType === contentType) {
                  tab.classList.add('active');
                }
              });
              
              // 직업 필터 활성화
              const jobFilterButtons = document.querySelectorAll('#contents-ranking-job-filters .ranking-filter-btn');
              jobFilterButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-value') === job) {
                  btn.classList.add('active');
                }
              });
              
              // 서버 필터 탭 활성화
              const serverTabButtons = document.querySelectorAll('.contents-server-tab');
              serverTabButtons.forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'rgba(255, 255, 255, 0.05)';
                btn.style.borderColor = 'var(--card-border)';
                btn.style.color = 'var(--text-primary)';
                if (btn.getAttribute('data-race') === race) {
                  btn.classList.add('active');
                  btn.style.background = 'rgba(157, 140, 255, 0.16)';
                  btn.style.borderColor = 'rgba(157, 140, 255, 0.9)';
                  btn.style.color = 'var(--accent)';
                }
              });
              
              // 서버 필터 업데이트
              if (typeof updateContentsServerFilters === 'function') {
                updateContentsServerFilters(race);
              }
              
              // 서버 필터 버튼 활성화
              setTimeout(() => {
                const serverFilterContainer = document.getElementById('contents-ranking-server-filters');
                if (serverFilterContainer) {
                  const serverBtn = serverFilterContainer.querySelector(`[data-value="${server}"]`);
                  if (serverBtn) {
                    serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
                    serverBtn.classList.add('active');
                  }
                }
              }, 100);
              
              // 이벤트 리스너 설정 및 데이터 로드
              if (typeof setupContentsRankingEventListeners === 'function') {
                setupContentsRankingEventListeners();
              }
              
              if (typeof loadContentsRanking === 'function') {
                loadContentsRanking(page);
              }
            }, 100);
          }
        }, 300);
      }
      return;
    }
    
    // 레기온 랭킹 서브탭 체크
    if (params.length > 0 && params[0] === 'region') {
      const rankingTab = document.getElementById('tab-ranking');
      if (rankingTab) {
        rankingTab.checked = true;
        rankingTab.dispatchEvent(new Event('change'));
        
        // 레기온 랭킹 탭 활성화
        setTimeout(() => {
          const regionTab = document.querySelector('#panel-ranking .statistics-sub-tab-btn[data-target="region-ranking"]');
          if (regionTab) {
            regionTab.click();
          }
        }, 300);
      }
      return;
    }
    
    const job = params[0] && params[0] !== '천족' && params[0] !== '마족' ? params[0] : 'all';
    let race = 'all';
    let server = 'all';
    
    if (params.length > 0) {
      if (params[0] === '천족' || params[0] === '마족') {
        race = params[0] === '천족' ? 'elyos' : 'asmodian';
        server = params[1] || 'all';
      } else if (params[1] === '천족' || params[1] === '마족') {
        race = params[1] === '천족' ? 'elyos' : 'asmodian';
        server = params[2] || 'all';
      } else if (params[1]) {
        server = params[1];
      }
    }
    
    // 랭킹 탭 활성화 및 필터 적용
    const rankingTab = document.getElementById('tab-ranking');
    if (rankingTab) {
      rankingTab.checked = true;
      rankingTab.dispatchEvent(new Event('change'));
      
      // 필터 적용 (약간의 지연 필요)
      setTimeout(() => {
        if (job !== 'all') {
          const jobBtn = document.querySelector(`#ranking-job-filters .ranking-filter-btn[data-value="${job}"]`);
          if (jobBtn) jobBtn.click();
        }
        if (race !== 'all') {
          const raceBtn = document.querySelector(`.ranking-server-tab-btn[data-race="${race}"]`);
          if (raceBtn) raceBtn.click();
        }
        if (server !== 'all') {
          setTimeout(() => {
            const serverBtn = document.querySelector(`#ranking-server-filters .ranking-filter-btn[data-value="${server}"]`);
            if (serverBtn) serverBtn.click();
          }, 100);
        }
      }, 200);
    }
  }
  
  // 통계 탭
  if (tab === 'statistics') {
    const subtab = params[0] || 'jobstats';
    const statisticsTab = document.getElementById('tab-statistics');
    if (statisticsTab) {
      statisticsTab.checked = true;
      statisticsTab.dispatchEvent(new Event('change'));
      
      setTimeout(() => {
        let targetSelector;
        if (subtab === 'skillstat') {
          targetSelector = 'skill-statistics';
        } else if (subtab === 'itemstats') {
          targetSelector = 'item-statistics';
        } else {
          targetSelector = 'job-statistics';
        }
        const targetBtn = document.querySelector(`.statistics-sub-tab-btn[data-target="${targetSelector}"]`);
        if (targetBtn) targetBtn.click();
      }, 200);
    }
  }
  
  // 티어 탭
  if (tab === 'tier') {
    // 티어 탭은 별도 페이지이므로 여기서는 처리하지 않음
  }
  
  // 스펙 비교 탭
  if (tab === 'compare') {
    // 스펙 비교 탭은 별도 페이지이므로 여기서는 처리하지 않음
  }
  
  // 서버 비교 탭
  if (tab === 'server-comparison') {
    // 서버 비교 탭은 별도 페이지이므로 여기서는 처리하지 않음
  }
  
  // 캐릭터 검색
  if (tab === 'char') {
    // 캐릭터 검색은 별도 라우트로 처리
  }
}

// 서버 목록 데이터
const serverDataEl = document.getElementById('server-data');
const servers = serverDataEl ? JSON.parse(serverDataEl.textContent) : { elyos: [], asmodian: [] };
const SKILL_ICON_PLACEHOLDER = 'https://via.placeholder.com/40x40/1f2335/ffffff?text=%20';
const STAT_SUBTAB_DESCRIPTIONS = {
  'job-statistics': document.getElementById('job-stat-desc'),
  'skill-statistics': document.getElementById('skill-stat-desc'),
  'item-statistics': null // 아이템 통계는 설명이 없음
};

const STAT_MIN_GAP = 1;
// 전투력 구간 스냅 포인트 (캐시 효율성을 위해 특정 구간으로만 제한)
const POWER_SNAP_POINTS = [0, 1000, 2000, 2500, 3000, 3500, 5000];

// 값을 가장 가까운 스냅 포인트로 조정하는 함수
function snapToPowerPoint(value) {
  if (value <= POWER_SNAP_POINTS[0]) return POWER_SNAP_POINTS[0];
  if (value >= POWER_SNAP_POINTS[POWER_SNAP_POINTS.length - 1]) return POWER_SNAP_POINTS[POWER_SNAP_POINTS.length - 1];
  
  let closest = POWER_SNAP_POINTS[0];
  let minDiff = Math.abs(value - POWER_SNAP_POINTS[0]);
  
  for (let i = 1; i < POWER_SNAP_POINTS.length; i++) {
    const diff = Math.abs(value - POWER_SNAP_POINTS[i]);
    if (diff < minDiff) {
      minDiff = diff;
      closest = POWER_SNAP_POINTS[i];
    }
  }
  
  return closest;
}

const statisticsState = {
  initialized: false,
  bounds: { min: 0, max: 5000 },
  range: { min: 0, max: 4999 },
  filteredCount: 0
};
// 통계 데이터 메모리 캐시
// 중복 선언 방지
if (typeof statisticsDataCache === 'undefined') {
  var statisticsDataCache = null;
}
if (typeof statisticsDataCacheTime === 'undefined') {
  var statisticsDataCacheTime = null;
}
const STATISTICS_CACHE_DURATION = 55 * 60 * 1000; // 55분 (서버 캐시 1시간보다 짧게)

const statisticsControls = {
  minInput: document.getElementById('stat-min-input'),
  maxInput: document.getElementById('stat-max-input'),
  minRange: document.getElementById('stat-range-min'),
  maxRange: document.getElementById('stat-range-max'),
  track: document.getElementById('stat-range-track'),
  summary: document.getElementById('stat-range-summary'),
  applyButton: document.getElementById('stat-apply-button')
};

// [제거됨] 전투력 랭킹용 전투력 구간 컨트롤 - slow query 유발 및 캐시 효율 저하

initializeStatisticsControls();

// 종족 선택 버튼 이벤트 리스너
function updateRaceSelection(selectedRace, skipSave = false) {
  // 모든 버튼에서 active 클래스 제거
  document.querySelectorAll('.race-button').forEach(btn => {
    btn.classList.remove('active');
  });
  
  // 선택된 버튼에 active 클래스 추가
  if (selectedRace === '') {
    document.getElementById('race-all').classList.add('active');
  } else if (selectedRace === '1') {
    document.getElementById('race-elyos').classList.add('active');
  } else if (selectedRace === '2') {
    document.getElementById('race-asmodian').classList.add('active');
  }
  
  // 서버 목록 업데이트
  const serverSelect = document.getElementById('server-select');
  
  // 종족에 따라 첫 번째 옵션 텍스트 설정
  let firstOptionText = '전체 서버에서 검색';
  if (selectedRace === '1') {
    firstOptionText = '천족 서버에서 검색';
  } else if (selectedRace === '2') {
    firstOptionText = '마족 서버에서 검색';
  }
  
  // 전체 서버 옵션 추가
  serverSelect.innerHTML = `<option value="all">${firstOptionText}</option>`;
  
  if (selectedRace === '1') {
    // 천족 서버
    servers.elyos.forEach(server => {
      const option = document.createElement('option');
      option.value = server.id;
      const prefix = server.name.substring(0, 2);
      option.textContent = `${server.name} - [${prefix}]`;
      serverSelect.appendChild(option);
    });
    serverSelect.disabled = false;
  } else if (selectedRace === '2') {
    // 마족 서버
    servers.asmodian.forEach(server => {
      const option = document.createElement('option');
      option.value = server.id;
      const prefix = server.name.substring(0, 2);
      option.textContent = `${server.name} - [${prefix}]`;
      serverSelect.appendChild(option);
    });
    serverSelect.disabled = false;
  } else {
    // 전체 선택 시: 모든 서버 표시
    servers.elyos.forEach(server => {
      const option = document.createElement('option');
      option.value = server.id;
      const prefix = server.name.substring(0, 2);
      option.textContent = `${server.name} - [${prefix}]`;
      serverSelect.appendChild(option);
    });
    servers.asmodian.forEach(server => {
      const option = document.createElement('option');
      option.value = server.id;
      const prefix = server.name.substring(0, 2);
      option.textContent = `${server.name} - [${prefix}]`;
      serverSelect.appendChild(option);
    });
    serverSelect.disabled = false;
  }
  
  // localStorage에 저장 (skipSave가 false일 때만)
  if (!skipSave) {
    localStorage.setItem('characterSearchRace', selectedRace);
  }
}

// 종족 버튼 클릭 이벤트
document.getElementById('race-all').addEventListener('click', function() {
  updateRaceSelection('');
});

document.getElementById('race-elyos').addEventListener('click', function() {
  updateRaceSelection('1');
});

document.getElementById('race-asmodian').addEventListener('click', function() {
  updateRaceSelection('2');
});

// 페이지 로드 시 localStorage에서 종족 선택 복원
function loadSearchPreferences() {
  // URL 파라미터나 경로에 캐릭터 정보가 있으면 localStorage 복원 스킵 (URL 우선)
  const urlParams = new URLSearchParams(window.location.search);
  const hasCharacterParams = urlParams.get('nickname') && urlParams.get('race') && urlParams.get('server');
  
  // 새로운 URL 형식도 확인: /char/serverid=xxxx/닉네임
  const path = window.location.pathname;
  const charMatch = path.match(/^\/char\/serverid=(\d+)\/(.+)$/);
  
  // URL 파라미터나 경로에 캐릭터 정보가 있으면 localStorage 복원하지 않음
  if (hasCharacterParams || charMatch) {
    return;
  }
  
  const savedRace = localStorage.getItem('characterSearchRace') || '';
  updateRaceSelection(savedRace);
}

// URL 경로에 따라 탭 활성화 (한 번만 실행되도록 플래그 사용)
let tabActivationInProgress = false;
function activateTabByPath() {
  // 이미 실행 중이면 중복 실행 방지
  if (tabActivationInProgress) {
    return;
  }
  
  const path = window.location.pathname;
  let tabId = null;
  
  if (path.startsWith('/ranking')) {
    tabId = 'tab-ranking';
  } else if (path.startsWith('/statistics')) {
    tabId = 'tab-statistics';
  } else if (path === '/' || path === '') {
    tabId = 'tab-character';
  }
  
  if (tabId) {
    const tabRadio = document.getElementById(tabId);
    if (tabRadio && !tabRadio.checked) {
      tabActivationInProgress = true;
      tabRadio.checked = true;
      
      // 통계 탭은 change 이벤트를 발생시키지 않음 (중복 호출 방지)
      // 초기화는 DOMContentLoaded 블록에서 처리됨
      if (tabId !== 'tab-statistics') {
        // 랭킹/캐릭터 검색 탭만 change 이벤트 트리거
        tabRadio.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        // 통계 탭은 직접 초기화
        hideCharacterResult();
        updateURL('statistics/jobstats', false, true);
        updateSidebarVisibility();
        scrollToTop();
        setupStatisticsSubTabs();
      }
      
      setTimeout(() => {
        tabActivationInProgress = false;
      }, 200);
    } else {
      tabActivationInProgress = false;
    }
  }
}

// 페이지 로드 시 실행
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    loadSearchPreferences();
    // change 이벤트 리스너가 등록된 후 실행되도록 지연
    setTimeout(() => {
      activateTabByPath();
    }, 50);
  });
} else {
  loadSearchPreferences();
  // change 이벤트 리스너가 등록된 후 실행되도록 지연
  setTimeout(() => {
    activateTabByPath();
  }, 50);
}

// 일일 검색 랭킹 로드
// 일일 검색 랭킹 렌더링 함수 (서버 사이드 데이터와 API 응답 모두 처리)
function renderDailySearchRanking(data) {
  // API 응답 형식과 서버 사이드 데이터 형식 모두 처리
  const rankingData = data.success ? data : { success: true, data: data.data || [] };
  
  if (rankingData.success && rankingData.data) {
        const container = document.getElementById('daily-search-ranking');
        if (data.data.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">검색 데이터가 없습니다.</p>';
          return;
        }
        
        // 전체 랭킹 데이터 저장 (마우스 오버 시 사용)
        window.dailyRankingData = data.data;
        
        // 서버 정보 가져오기
        const serverDataEl = document.getElementById('server-data');
        const servers = serverDataEl ? JSON.parse(serverDataEl.textContent) : { elyos: [], asmodian: [] };
        
        let html = '<div id="daily-ranking-container" style="display: flex; flex-direction: column; gap: 0.5rem; transition: transform 0.4s ease-in-out;">';
        data.data.forEach((item, index) => {
          // 순위를 1,2,3,4,5,6,7,8,9,10으로 고정 (배열 순서 기준)
          const displayRank = index + 1;
          const medalIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
          const nickname = item.nickname || '';
          const serverName = item.server || '';
          const raceName = item.race || '';
          const nicknameColor = raceName === '천족' ? '#3b82f6' : raceName === '마족' ? '#ef4444' : 'var(--accent)';
          
          // 닉네임을 클릭 가능하게 만들기
          let nicknameDisplay = nickname;
          if (nickname && serverName && raceName) {
            // race를 숫자로 변환 (천족=1, 마족=2)
            let raceValue = '';
            let serverId = '';
            
            if (raceName === '천족') {
              raceValue = '1';
              if (servers && servers.elyos) {
                const serverInfo = servers.elyos.find(s => s.name === serverName);
                if (serverInfo) serverId = serverInfo.id;
              }
            } else if (raceName === '마족') {
              raceValue = '2';
              if (servers && servers.asmodian) {
                const serverInfo = servers.asmodian.find(s => s.name === serverName);
              if (serverInfo) serverId = serverInfo.id;
              }
            }
            
            if (raceValue && serverId) {
              // 쿼리 파라미터 형식 사용 (새 탭에서도 loadCharacterFromUrlParams가 제대로 작동하도록)
              const characterUrl = `/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}`;
              nicknameDisplay = `<a href="${characterUrl}" class="daily-ranking-nickname-link" data-nickname="${nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: ${nicknameColor}; text-decoration: none; cursor: pointer; transition: opacity 0.2s; font-weight: 500;">${nickname}</a>`;
            } else {
              nicknameDisplay = `<span style="color: ${nicknameColor}; font-weight: 500;">${nickname}</span>`;
            }
          } else if (nickname) {
            nicknameDisplay = `<span style="color: ${nicknameColor}; font-weight: 500;">${nickname}</span>`;
          }
          
          // 순위 변동 표시
          let rankChangeDisplay = '';
          if (item.rank_change_type === 'up' && item.rank_change !== null) {
            // 순위 상승: 빨간색 위 삼각형 + 변동 수치
            rankChangeDisplay = `<span style="color: #ef4444; font-weight: bold; display: inline-flex; align-items: center; gap: 2px;">${item.rank_change} <span style="color: #ef4444; font-size: 0.7em; line-height: 1;">▲</span></span>`;
          } else if (item.rank_change_type === 'down' && item.rank_change !== null) {
            // 순위 하락: 파란색 아래 삼각형 + 변동 수치
            rankChangeDisplay = `<span style="color: #3b82f6; font-weight: bold; display: inline-flex; align-items: center; gap: 2px;">${item.rank_change} <span style="color: #3b82f6; font-size: 0.7em; line-height: 1;">▼</span></span>`;
          } else if (item.rank_change_type === 'same') {
            // 순위 동일: "-"
            rankChangeDisplay = `<span style="color: var(--text-secondary); font-weight: bold;">-</span>`;
          } else if (item.rank_change_type === 'new') {
            // 신규: "New" 표시
            rankChangeDisplay = `<span style="color: var(--accent); font-weight: bold;">New</span>`;
          } else {
            // 기타 경우 (순위 밖이었던 경우 등): "-" 표시
            rankChangeDisplay = `<span style="color: var(--text-secondary); font-weight: bold;">-</span>`;
          }
          
          html += `
            <div class="daily-ranking-item" style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px; height: 40px; flex-shrink: 0;">
              <span style="font-weight: bold; min-width: 30px;">${displayRank}${medalIcon ? ' ' + medalIcon : ''}</span>
              <span style="flex: 1;">${nicknameDisplay}</span>
              ${rankChangeDisplay}
            </div>
          `;
        });
        html += '</div>';
        container.innerHTML = html;
        
        // 애니메이션 시작: 처음에는 1위만 보이게, 3초마다 다음 순위 추가
        startDailyRankingAnimation(container, data.data.length);
        
        // 마우스 오버 시 전체 보이기
        setupDailyRankingHover(container, data.data.length);
        
    // 닉네임 클릭 이벤트 추가
    setupDailyRankingNicknameClicks();
    
    // 전투력 TOP 5 닉네임 클릭 이벤트 추가
    setupPowerTop5NicknameClicks();
    
  } else {
    const container = document.getElementById('daily-search-ranking');
    if (container) {
      container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">데이터를 불러올 수 없습니다.</p>';
    }
  }
}

function loadDailySearchRanking() {
  fetch('/api/daily-search-ranking?limit=10')
    .then(response => response.json())
    .then(data => {
      renderDailySearchRanking(data);
    })
    .catch(error => {
      const container = document.getElementById('daily-search-ranking');
      if (container) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">로딩 오류가 발생했습니다.</p>';
      }
    });
}

// 일일 검색 랭킹 애니메이션 (2초마다 다음 순위로 이동, 위로 올라가는 애니메이션, 순환)
function startDailyRankingAnimation(container, totalCount) {
  if (!container) return;
  
  const rankingContainer = container.querySelector('#daily-ranking-container');
  if (!rankingContainer) return;
  
  // 기존 애니메이션 중지
  if (container._animationInterval) {
    clearInterval(container._animationInterval);
    container._animationInterval = null;
  }
  
  // 현재 보이는 아이템 인덱스 (0부터 시작, 마우스 오버 후 복귀 시 사용)
  let currentIndex = container._currentIndex !== undefined ? container._currentIndex : 0;
  container._currentIndex = undefined; // 초기화
  
  const itemHeight = 40 + 8; // height + gap
  
  // 컨테이너 높이를 고정 (1개 아이템 높이만)
  container.style.maxHeight = `${itemHeight}px`;
  container.style.height = `${itemHeight}px`;
  container.style.overflow = 'hidden';
  
  // 처음에는 currentIndex 아이템만 보이게 설정
  const items = rankingContainer.querySelectorAll('.daily-ranking-item');
  items.forEach((item, index) => {
    if (index === currentIndex) {
      item.style.display = 'flex';
    } else {
      item.style.display = 'none';
    }
  });
  
  // transform 설정 (항상 1개만 보이므로 translateY(0))
  rankingContainer.style.transform = 'translateY(0)';
  
  // 2초마다 다음 순위로 이동 (순환, 위로 올라가는 애니메이션)
  const animationInterval = setInterval(() => {
    // 현재 아이템을 위로 올라가게 애니메이션
    rankingContainer.style.transform = `translateY(-${itemHeight}px)`;
    
    // 애니메이션 완료 후 다음 아이템으로 전환
    setTimeout(() => {
      // 다음 순위로 이동
      currentIndex++;
      
      // 10위를 넘어가면 1위(인덱스 0)로 돌아감
      if (currentIndex >= totalCount) {
        currentIndex = 0;
      }
      
      // 모든 아이템 숨기고 현재 인덱스만 표시
      items.forEach((item, index) => {
        if (index === currentIndex) {
          item.style.display = 'flex';
        } else {
          item.style.display = 'none';
        }
      });
      
      // transform을 아래에서 시작하도록 설정 (다음 애니메이션을 위해)
      rankingContainer.style.transform = `translateY(${itemHeight}px)`;
      
      // 즉시 위로 올라오는 애니메이션
      setTimeout(() => {
        rankingContainer.style.transform = 'translateY(0)';
      }, 10);
    }, 400); // transition 시간과 맞춤
    
    // 컨테이너 높이는 항상 고정
    container.style.maxHeight = `${itemHeight}px`;
    container.style.height = `${itemHeight}px`;
  }, 2000); // 2초마다
  
  // 컨테이너에 애니메이션 인터벌 저장 (나중에 정리용)
  container._animationInterval = animationInterval;
}

// 일일 검색 랭킹 마우스 오버 시 전체 보이기 (오버레이 박스 사용)
function setupDailyRankingHover(container, totalCount) {
  if (!container) return;
  
  const rankingContainer = container.querySelector('#daily-ranking-container');
  if (!rankingContainer) return;
  
  const overlay = document.getElementById('daily-ranking-overlay');
  const overlayContent = document.getElementById('daily-ranking-overlay-content');
  const heroCard = container.closest('.hero-card');
  
  if (!overlay || !overlayContent || !heroCard) return;
  
  // 오버레이에 전체 랭킹 데이터 복사
  function createOverlayContent() {
    if (!window.dailyRankingData) return;
    
    const serverDataEl = document.getElementById('server-data');
    const servers = serverDataEl ? JSON.parse(serverDataEl.textContent) : { elyos: [], asmodian: [] };
    
    let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
    window.dailyRankingData.forEach((item, index) => {
      const medalIcon = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : '';
      const nickname = item.nickname || '';
      const serverName = item.server || '';
      const raceName = item.race || '';
      const nicknameColor = raceName === '천족' ? '#3b82f6' : raceName === '마족' ? '#ef4444' : 'var(--accent)';
      
      // 닉네임을 클릭 가능하게 만들기
      let nicknameDisplay = nickname;
      if (nickname && serverName && raceName) {
        let raceValue = '';
        let serverId = '';
        
        if (raceName === '천족') {
          raceValue = '1';
          if (servers && servers.elyos) {
            const serverInfo = servers.elyos.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        } else if (raceName === '마족') {
          raceValue = '2';
          if (servers && servers.asmodian) {
            const serverInfo = servers.asmodian.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        }
        
        if (raceValue && serverId) {
          // 쿼리 파라미터 형식 사용 (새 탭에서도 loadCharacterFromUrlParams가 제대로 작동하도록)
          const characterUrl = `/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}`;
          nicknameDisplay = `<a href="${characterUrl}" class="daily-ranking-nickname-link" data-nickname="${nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: ${nicknameColor}; text-decoration: none; cursor: pointer; transition: opacity 0.2s; font-weight: 500;">${nickname}</a>`;
        } else {
          nicknameDisplay = `<span style="color: ${nicknameColor}; font-weight: 500;">${nickname}</span>`;
        }
      } else if (nickname) {
        nicknameDisplay = `<span style="color: ${nicknameColor}; font-weight: 500;">${nickname}</span>`;
      }
      
      // 순위 변동 표시 (오버레이에서도 동일한 로직 사용)
      let rankChangeDisplay = '';
      if (item.rank_change_type === 'up' && item.rank_change !== null) {
        // 순위 상승: 빨간색 위 삼각형 + 변동 수치
        rankChangeDisplay = `<span style="color: #ef4444; font-weight: bold; display: inline-flex; align-items: center; gap: 2px;">${item.rank_change} <span style="color: #ef4444; font-size: 0.7em; line-height: 1;">▲</span></span>`;
      } else if (item.rank_change_type === 'down' && item.rank_change !== null) {
        // 순위 하락: 파란색 아래 삼각형 + 변동 수치
        rankChangeDisplay = `<span style="color: #3b82f6; font-weight: bold; display: inline-flex; align-items: center; gap: 2px;">${item.rank_change} <span style="color: #3b82f6; font-size: 0.7em; line-height: 1;">▼</span></span>`;
      } else if (item.rank_change_type === 'same') {
        // 순위 동일: "-"
        rankChangeDisplay = `<span style="color: var(--text-secondary); font-weight: bold;">-</span>`;
      } else if (item.rank_change_type === 'new') {
        // 신규: "New" 표시
        rankChangeDisplay = `<span style="color: var(--accent); font-weight: bold;">New</span>`;
      } else {
        // 기타 경우 (순위 밖이었던 경우 등): "-" 표시
        rankChangeDisplay = `<span style="color: var(--text-secondary); font-weight: bold;">-</span>`;
      }
      
      // 순위를 1,2,3,4,5,6,7,8,9,10으로 고정 (count 상관없이)
      const displayRank = index + 1;
      
      html += `
        <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px;">
          <span style="font-weight: bold; min-width: 30px;">${displayRank}${medalIcon ? ' ' + medalIcon : ''}</span>
          <span style="flex: 1;">${nicknameDisplay}</span>
          ${rankChangeDisplay}
        </div>
      `;
    });
    html += '</div>';
    overlayContent.innerHTML = html;
    
    // 닉네임 클릭 이벤트 추가
    setupDailyRankingNicknameClicks();
  }
  
  let overlayTimeout = null;
  
  container.addEventListener('mouseenter', function() {
    // 애니메이션 일시 중지 (중지는 안 함, 계속 진행)
    // 오버레이 내용 생성
    createOverlayContent();
    
    // 기존 timeout 취소
    if (overlayTimeout) {
      clearTimeout(overlayTimeout);
      overlayTimeout = null;
    }
    
    // 오버레이 표시
    overlay.style.display = 'block';
  });
  
  // 오버레이에 마우스가 들어오면 유지
  overlay.addEventListener('mouseenter', function() {
    if (overlayTimeout) {
      clearTimeout(overlayTimeout);
      overlayTimeout = null;
    }
    overlay.style.display = 'block';
  });
  
  // 오버레이에서 마우스가 나가면 숨김
  overlay.addEventListener('mouseleave', function() {
    overlayTimeout = setTimeout(() => {
      overlay.style.display = 'none';
    }, 100); // 약간의 딜레이로 자연스러운 전환
  });
  
  // 컨테이너에서 마우스가 나가면 오버레이도 숨김 (오버레이 위에 있지 않은 경우)
  container.addEventListener('mouseleave', function(e) {
    // 마우스가 오버레이로 이동하는 경우 체크
    if (overlay.contains(e.relatedTarget)) {
      return;
    }
    overlayTimeout = setTimeout(() => {
      overlay.style.display = 'none';
    }, 100);
  });
}

// 전투력 TOP 5 닉네임 클릭 이벤트 설정
function setupPowerTop5NicknameClicks() {
  const nicknameLinks = document.querySelectorAll('.power-top5-nickname-link');
  
  nicknameLinks.forEach(link => {
    link.addEventListener('click', function(e) {
      // 마우스 휠 클릭(중간 클릭)이나 Ctrl+클릭, Shift+클릭(새 탭/새 창)은 기본 동작 허용
      if (e.button === 1 || e.ctrlKey || e.metaKey || e.shiftKey) {
        return; // 기본 동작 허용 (새 탭으로 열기)
      }
      
      // 일반 클릭도 URL로 이동하도록 허용 (loadCharacterFromUrlParams가 처리)
      // preventDefault 하지 않음
    });
    
    // 호버 효과
    link.addEventListener('mouseenter', function() {
      this.style.opacity = '0.7';
    });
    link.addEventListener('mouseleave', function() {
      this.style.opacity = '1';
    });
  });
}

// 일일 검색 랭킹 닉네임 클릭 이벤트 설정
function setupDailyRankingNicknameClicks() {
  const nicknameLinks = document.querySelectorAll('.daily-ranking-nickname-link');
  
  nicknameLinks.forEach(link => {
    link.addEventListener('click', function(e) {
      // 새 탭에서 열 때는 기본 동작 허용 (URL 파라미터로 처리됨)
      if (e.ctrlKey || e.metaKey || e.button === 1 || (e.button === 0 && e.shiftKey)) {
        return;
      }
      
      // 같은 탭에서 클릭할 때만 preventDefault
      e.preventDefault();
      const nickname = this.getAttribute('data-nickname');
      const race = this.getAttribute('data-race');
      const serverId = this.getAttribute('data-server');
      
      if (!nickname || !race || !serverId) return;
      
      // 일일 검색 랭킹에서 온 클릭임을 표시하는 플래그 설정
      window.skipSearchCount = true;
      
      // 로딩 표시를 먼저 설정 (탭 변경 전에)
      document.getElementById('character-result').style.display = 'none';
      document.getElementById('character-all-servers-result').style.display = 'none';
      document.getElementById('character-loading').style.display = 'block';
      const rankingLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
      if (rankingLoadingOverlay) {
        rankingLoadingOverlay.style.display = 'flex';
      }
      
      // 캐릭터 검색 탭으로 이동
      const characterTab = document.getElementById('tab-character');
      if (characterTab) {
        characterTab.checked = true;
        
        // 탭 변경 이벤트 트리거
        characterTab.dispatchEvent(new Event('change'));
        
        // 배너 표시 업데이트
        updateSidebarVisibility();
        
        // 검색 폼에 값 설정
        const serverSelect = document.getElementById('server-select');
        const keywordInput = document.getElementById('character-keyword');
        
        // 종족 버튼 업데이트 (캐릭터 링크 클릭이므로 localStorage에 저장하지 않음)
        if (race) {
          updateRaceSelection(race, true);
        }
        
        // 서버 선택이 활성화될 때까지 대기
        setTimeout(() => {
          if (serverSelect) {
            serverSelect.value = serverId;
            if (keywordInput) keywordInput.value = nickname;
            
            // 로딩 표시 유지 (updateSidebarVisibility가 호출되어도 로딩 상태 확인)
            document.getElementById('character-loading').style.display = 'block';
            const rankingLoadingOverlay3 = document.getElementById('fullscreen-loading-overlay');
            if (rankingLoadingOverlay3) {
              rankingLoadingOverlay3.style.display = 'flex';
            }
            
            // 검색 실행 (performSearch가 로딩 표시를 처리함)
            performSearch();
          }
        }, 300);
      }
    });
    
    // 호버 효과
    link.addEventListener('mouseenter', function() {
      this.style.opacity = '0.7';
    });
    link.addEventListener('mouseleave', function() {
      this.style.opacity = '1';
    });
  });
}

// 서버 통계 로드
function loadServerStats() {
  const container = document.getElementById('server-stats');
  if (!container) return;
  
  // 프론트엔드 캐싱: localStorage에 저장된 데이터 확인 (20분 이내면 재사용)
  const SERVER_STATS_CACHE_KEY = 'server_stats_cache';
  const SERVER_STATS_CACHE_TIME_KEY = 'server_stats_cache_time';
  const CACHE_DURATION = 20 * 60 * 1000; // 20분 (서버 스케줄러 주기와 동일)
  
  const cachedData = localStorage.getItem(SERVER_STATS_CACHE_KEY);
  const cachedTime = localStorage.getItem(SERVER_STATS_CACHE_TIME_KEY);
  const now = Date.now();
  
  // 캐시된 데이터가 있고 20분 이내면 재사용
  if (cachedData && cachedTime && (now - parseInt(cachedTime)) < CACHE_DURATION) {
    try {
      const result = JSON.parse(cachedData);
      if (result.success && result.data) {
        // 캐시된 데이터로 렌더링
        renderServerStatsData(result);
        return; // API 호출 없이 종료
      }
    } catch (e) {
      // 캐시 파싱 실패 시 무시하고 API 호출
    }
  }
  
  // 타임아웃 설정 (10초)
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000);
  
  fetch('/api/server-stats', { 
    signal: controller.signal,
    cache: 'default', // 브라우저 캐시 활용
    headers: {
      'Cache-Control': 'max-age=1200' // 20분간 브라우저 캐시 (서버 스케줄러 주기와 동일)
    }
  })
    .then(response => {
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    })
    .then(data => {
      // API 응답을 localStorage에 캐싱 (20분간 유효)
      if (data.success) {
        try {
          localStorage.setItem(SERVER_STATS_CACHE_KEY, JSON.stringify(data));
          localStorage.setItem(SERVER_STATS_CACHE_TIME_KEY, now.toString());
        } catch (e) {
          // localStorage 용량 초과 등 오류 시 무시
        }
      }
      
      // 데이터 렌더링
      renderServerStatsData(data);
    })
    .catch(error => {
      clearTimeout(timeoutId);
      const container = document.getElementById('server-stats');
      if (!container) return;
      
      if (error.name === 'AbortError') {
        container.innerHTML = '<p style="text-align: center; color: #ef4444; padding: 1rem;">요청 시간이 초과되었습니다.<br><button onclick="loadServerStats()" style="margin-top: 0.5rem; padding: 0.4rem 0.8rem; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer;">다시 시도</button></p>';
      } else {
        container.innerHTML = '<p style="text-align: center; color: #ef4444; padding: 1rem;">로딩 오류가 발생했습니다.<br><button onclick="loadServerStats()" style="margin-top: 0.5rem; padding: 0.4rem 0.8rem; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer;">다시 시도</button></p>';
      }
    });
}

// 서버 통계 데이터 렌더링 함수 (캐시된 데이터와 API 응답 모두 처리)
function renderServerStatsData(data) {
  const container = document.getElementById('server-stats');
  if (!container) return;
  
  if (data.success && data.data) {
    const stats = data.data;
    
    let html = '<div style="display: flex; flex-direction: column; gap: 0.6rem;">';
    
    // 전체 통계
    html += `
      <div style="display: flex; justify-content: space-between; padding: 0.5rem 0.4rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px; gap: 0.4rem;">
        <div style="text-align: center; flex: 1;">
          <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.1rem;">등록된 레기온</div>
          <div style="font-size: 1.1rem; font-weight: 600; color: var(--accent);">${stats.total_guilds.toLocaleString()}</div>
        </div>
        <div style="text-align: center; flex: 1;">
          <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.1rem;">등록된 캐릭터</div>
          <div style="font-size: 1.1rem; font-weight: 600; color: var(--accent);">${stats.total_characters.toLocaleString()}</div>
        </div>
      </div>
    `;
    
    // 서버별 통계
    const totalCount = stats.elyos_count + stats.asmodian_count;
    html += `
      <div style="padding: 0.6rem 0.4rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px;">
        <div id="server-stats-list" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
          <!-- 동적으로 채워짐 -->
        </div>
      </div>
    `;
    html += '</div>';
    
    container.innerHTML = html;
    
    // 서버별 통계 직접 표시
    displayServerStats(stats, totalCount);
  } else {
    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 1rem;">데이터를 불러올 수 없습니다.</p>';
  }
}

// 아이온2 업데이트 내역 로드
// 아이온2 업데이트 내역 렌더링 함수 (서버 사이드 데이터와 API 응답 모두 처리)
function renderAion2Updates(data) {
  const container = document.getElementById('aion2-updates-container');
  if (!container) return;
  
  // API 응답 형식과 서버 사이드 데이터 형식 모두 처리
  const updatesData = data.success ? data : { success: true, data: data.data || [] };
  
  if (updatesData.success && updatesData.data && updatesData.data.length > 0) {
        const updates = data.data;
        let html = '<div class="announcement-list">';
        
        // 현재 시간 (2일 이내 체크용)
        const now = new Date();
        const twoDaysAgo = new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000);
        
        updates.forEach(update => {
          // 날짜 파싱
          let dateStr = '';
          let isNew = false;
          let updateDate = null;
          
          // created_at이 있으면 사용
          if (update.created_at) {
            try {
              updateDate = new Date(update.created_at);
              if (isNaN(updateDate.getTime())) {
                updateDate = null;
              }
            } catch (e) {
              updateDate = null;
            }
          }
          
          // created_at이 없거나 파싱 실패한 경우, 제목에서 날짜 추출 시도
          if (!updateDate && update.title) {
            // 제목 형식: "[안내] 12/3(수) 업데이트 노트" 또는 "[안내] 11/26(수) 업데이트 노트"
            const dateMatch = update.title.match(/(\d{1,2})\/(\d{1,2})\(/);
            if (dateMatch) {
              const month = parseInt(dateMatch[1]);
              const day = parseInt(dateMatch[2]);
              const now = new Date();
              const currentYear = now.getFullYear();
              // 현재 월보다 크면 작년으로 간주 (예: 12월인데 1월이 나오면)
              let year = currentYear;
              if (month > now.getMonth() + 1) {
                year = currentYear - 1;
              }
              updateDate = new Date(year, month - 1, day);
            }
          }
          
          if (updateDate && !isNaN(updateDate.getTime())) {
            // 2일 이내인지 확인
            if (updateDate > twoDaysAgo) {
              isNew = true;
            }
            // 날짜 포맷팅 (YYYY-MM-DD 형식 - 아툴 업데이트 내역과 동일)
            const year = updateDate.getFullYear();
            const month = String(updateDate.getMonth() + 1).padStart(2, '0');
            const day = String(updateDate.getDate()).padStart(2, '0');
            dateStr = `${year}-${month}-${day}`;
          } else {
            // 날짜를 찾을 수 없는 경우 빈 문자열 (하지만 표시는 함)
            dateStr = '';
          }
          
          // URL이 있으면 클릭 가능하게
          const urlAttr = update.url ? `onclick="window.open('${update.url}', '_blank')"` : '';
          const cursorStyle = update.url ? 'cursor: pointer;' : '';
          
          html += `
            <div class="announcement-item" ${urlAttr} style="${cursorStyle} min-width: 0; width: 100%; max-width: 100%; box-sizing: border-box; overflow: hidden;">
              <div class="announcement-header" style="min-width: 0; width: 100%; max-width: 100%; box-sizing: border-box; overflow: hidden;">
                <span class="announcement-date" style="min-width: 0; flex-shrink: 1; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; box-sizing: border-box;">${dateStr || '날짜 없음'}</span>
                <span class="announcement-title" style="min-width: 0; flex: 1 1 0; overflow: hidden; box-sizing: border-box;">
                  <span style="overflow: hidden !important; text-overflow: ellipsis !important; white-space: nowrap !important; flex: 1 1 0 !important; min-width: 0 !important; box-sizing: border-box !important; display: block;">${update.title || '제목 없음'}</span>
                </span>
              </div>
            </div>
          `;
        });
        
    html += '</div>';
    container.innerHTML = html;
  } else {
    container.innerHTML = '<div class="announcement-list"><p style="text-align: center; color: var(--text-secondary);">업데이트 내역이 없습니다.</p></div>';
  }
}

function loadAion2Updates() {
  fetch('/api/aion2-updates')
    .then(response => response.json())
    .then(data => {
      renderAion2Updates(data);
    })
    .catch(error => {
      const container = document.getElementById('aion2-updates-container');
      if (container) {
        container.innerHTML = '<div class="announcement-list"><p style="text-align: center; color: var(--text-secondary);">업데이트 내역을 불러올 수 없습니다.</p></div>';
      }
    });
}

// 서버별 통계 표시 (탭 없이 두 컬럼으로)
function displayServerStats(stats, totalCount) {
  const serverStatsList = document.getElementById('server-stats-list');
  
  if (!serverStatsList || !servers || !stats) return;
  
  // 서버 쌍 매칭 맵 (두 번째 스크린샷 기준)
  const serverPairs = {
    '시엘': '이스라펠',
    '네자칸': '지켈',
    '바이젤': '트리니엘',
    '카이시넬': '루미엘',
    '유스티엘': '마르쿠탄',
    '아리엘': '아스펠',
    '프레기온': '에레슈키갈',
    '메스람타에다': '브리트라',
    '히타니에': '네몬',
    '나니아': '하달',
    '타하바타': '루드라',
    '루터스': '울고른',
    '페르노스': '무닌',
    '다미누': '오다르',
    '카사카': '젠카카',
    '바카르마': '크로메데',
    '챈가룽': '콰이링',
    '코치룽': '바바룽',
    '이슈타르': '파프니르',
    '티아마트': '인드라노스',
    '포에타': '이스할겐'
  };
  
  // 역방향 맵 생성
  const reversePairs = {};
  Object.keys(serverPairs).forEach(elyos => {
    const asmodian = serverPairs[elyos];
    if (asmodian) {
      reversePairs[asmodian] = elyos;
    }
  });
  
  let elyosHtml = '<div style="display: flex; flex-direction: column; gap: 0.35rem;">';
  let asmodianHtml = '<div style="display: flex; flex-direction: column; gap: 0.35rem;">';
  
  // 천족 서버 목록
  if (servers.elyos && servers.elyos.length > 0) {
    servers.elyos.forEach(serverInfo => {
      const count = stats.server_stats[serverInfo.name] || 0;
      
      // 서버 쌍 비교 및 퍼센티지 계산
      const pairedServer = serverPairs[serverInfo.name];
      let showArrow = false;
      let pairPercentage = '';
      
      if (pairedServer) {
        const pairedCount = stats.server_stats[pairedServer] || 0;
        if (count > pairedCount) {
          showArrow = true;
        }
        pairPercentage = count.toLocaleString();
      } else {
        pairPercentage = count.toLocaleString();
      }

      const isLead = pairedServer ? count > (stats.server_stats[pairedServer] || 0) : false;
      const nameWeight = isLead ? '700' : '500';
      const valueWeight = isLead ? '700' : '500';
      
      // 신규 서버 체크 (포에타)
      const isNewServer = serverInfo.name === '포에타';
      const newBadge = isNewServer ? '<span style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 16px; background: #3b82f6; color: white; font-size: 0.65rem; font-weight: 700; border-radius: 4px; margin-right: 0.3rem;">N</span>' : '';
      
      // 1200~1400px 범위 체크
      const width = window.innerWidth;
      const isMediumWidth = width >= 1201 && width <= 1400;
      
      if (isMediumWidth) {
        // 1컬럼 레이아웃: 서버명과 인원수를 세로로 배치하고 center align
        elyosHtml += `
          <div style="display: flex; flex-direction: column; align-items: center; padding: 0.45rem 0.6rem; background: rgba(59, 130, 246, 0.08); border-radius: 6px; border: 1px solid rgba(59, 130, 246, 0.18);">
            <span style="font-size: 0.77rem; font-weight: ${nameWeight}; color: #3b82f6; text-align: center; margin-bottom: 0.25rem;">${newBadge}${serverInfo.name}${showArrow ? ' ▲' : ''}</span>
            <span style="font-size: 0.82rem; font-weight: ${valueWeight}; color: #3b82f6; text-align: center;">${pairPercentage}</span>
          </div>
        `;
      } else {
        // 기본 레이아웃: 서버명 - 인원수 (가로 배치)
        elyosHtml += `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.45rem 0.6rem; background: rgba(59, 130, 246, 0.08); border-radius: 6px; border: 1px solid rgba(59, 130, 246, 0.18);">
            <span style="font-size: 0.77rem; font-weight: ${nameWeight}; color: #3b82f6; display: flex; align-items: center;">${newBadge}${serverInfo.name}${showArrow ? ' ▲' : ''}</span>
            <span style="font-size: 0.82rem; font-weight: ${valueWeight}; color: #3b82f6;">${pairPercentage}</span>
          </div>
        `;
      }
    });
  }
  
  // 마족 서버 목록
  if (servers.asmodian && servers.asmodian.length > 0) {
    servers.asmodian.forEach(serverInfo => {
      const count = stats.server_stats[serverInfo.name] || 0;
      
      // 서버 쌍 비교 및 퍼센티지 계산
      const pairedServer = reversePairs[serverInfo.name];
      let showArrow = false;
      let pairPercentage = '';
      
      if (pairedServer) {
        const pairedCount = stats.server_stats[pairedServer] || 0;
        if (count > pairedCount) {
          showArrow = true;
        }
        pairPercentage = count.toLocaleString();
      } else {
        pairPercentage = count.toLocaleString();
      }

      const isLead = pairedServer ? count > (stats.server_stats[pairedServer] || 0) : false;
      const nameWeight = isLead ? '700' : '500';
      const valueWeight = isLead ? '700' : '500';
      
      // 신규 서버 체크 (이스할겐)
      const isNewServer = serverInfo.name === '이스할겐';
      const newBadge = isNewServer ? '<span style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 16px; background: #ef4444; color: white; font-size: 0.65rem; font-weight: 700; border-radius: 4px; margin-right: 0.3rem;">N</span>' : '';
      
      // 1200~1400px 범위 체크
      const width2 = window.innerWidth;
      const isMediumWidth2 = width2 >= 1201 && width2 <= 1400;
      
      if (isMediumWidth2) {
        // 1컬럼 레이아웃: 서버명과 인원수를 세로로 배치하고 center align
        asmodianHtml += `
          <div style="display: flex; flex-direction: column; align-items: center; padding: 0.45rem 0.6rem; background: rgba(239, 68, 68, 0.08); border-radius: 6px; border: 1px solid rgba(239, 68, 68, 0.18);">
            <span style="font-size: 0.77rem; font-weight: ${nameWeight}; color: #ef4444; text-align: center; margin-bottom: 0.25rem;">${newBadge}${serverInfo.name}${showArrow ? ' ▲' : ''}</span>
            <span style="font-size: 0.82rem; font-weight: ${valueWeight}; color: #ef4444; text-align: center;">${pairPercentage}</span>
          </div>
        `;
      } else {
        // 기본 레이아웃: 서버명 - 인원수 (가로 배치)
        asmodianHtml += `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.45rem 0.6rem; background: rgba(239, 68, 68, 0.08); border-radius: 6px; border: 1px solid rgba(239, 68, 68, 0.18);">
            <span style="font-size: 0.77rem; font-weight: ${nameWeight}; color: #ef4444; display: flex; align-items: center;">${newBadge}${serverInfo.name}${showArrow ? ' ▲' : ''}</span>
            <span style="font-size: 0.82rem; font-weight: ${valueWeight}; color: #ef4444;">${pairPercentage}</span>
          </div>
        `;
      }
    });
  }
  
  elyosHtml += '</div>';
  asmodianHtml += '</div>';
  
  serverStatsList.innerHTML = `
    <div>
      <div class="server-stat-header server-stat-header--elyos" style="margin-bottom: 0.4rem;">
        <span class="server-stat-header-label">천족</span>
        <span class="server-stat-header-count">(${stats.elyos_count.toLocaleString()})</span>
      </div>
      ${elyosHtml}
    </div>
    <div>
      <div class="server-stat-header server-stat-header--asmodian" style="margin-bottom: 0.4rem;">
        <span class="server-stat-header-label">마족</span>
        <span class="server-stat-header-count">(${stats.asmodian_count.toLocaleString()})</span>
      </div>
      ${asmodianHtml}
    </div>
  `;
  serverStatsList.style.display = 'grid';
}

// 즐겨찾기 관리 함수들
const FAVORITES_STORAGE_KEY = 'aion2_favorites';

function getFavorites() {
  try {
    const stored = localStorage.getItem(FAVORITES_STORAGE_KEY);
    return stored ? JSON.parse(stored) : [];
  } catch (e) {
    return [];
  }
}

function saveFavorites(favorites) {
  try {
    localStorage.setItem(FAVORITES_STORAGE_KEY, JSON.stringify(favorites));
  } catch (e) {
  }
}

function addFavorite(character) {
  const favorites = getFavorites();
  const key = `${character.nickname}_${character.server}_${character.race}`;
  
  // 중복 체크
  if (favorites.some(f => `${f.nickname}_${f.server}_${f.race}` === key)) {
    return false;
  }
  
  favorites.push({
    nickname: character.nickname,
    server: character.server,
    race: character.race,
    avatar_url: character.avatar_url || null
  });
  
  saveFavorites(favorites);
  return true;
}

function removeFavorite(character) {
  const favorites = getFavorites();
  const key = `${character.nickname}_${character.server}_${character.race}`;
  const filtered = favorites.filter(f => `${f.nickname}_${f.server}_${f.race}` !== key);
  
  if (filtered.length !== favorites.length) {
    saveFavorites(filtered);
    return true;
  }
  return false;
}

function isFavorite(character) {
  const favorites = getFavorites();
  const key = `${character.nickname}_${character.server}_${character.race}`;
  return favorites.some(f => `${f.nickname}_${f.server}_${f.race}` === key);
}

function updateFavoriteStar(character) {
  const starBtn = document.getElementById('favorite-star-btn');
  const starIcon = document.getElementById('favorite-star-icon');
  
  if (!starBtn || !starIcon) return;
  
  const favorited = isFavorite(character);
  starIcon.textContent = favorited ? '★' : '☆';
  starBtn.style.color = favorited ? '#ffd700' : 'rgba(255, 255, 255, 0.3)';
  starBtn.title = favorited ? '즐겨찾기 제거' : '즐겨찾기 추가';
}

// 즐겨찾기 페이지네이션 상태
// 중복 선언 방지
if (typeof favoritesCurrentPage === 'undefined') {
  var favoritesCurrentPage = 0;
}

function renderFavorites() {
  const favoritesSection = document.getElementById('favorites-section');
  const favoritesTitle = document.getElementById('favorites-title');
  const favoritesContainer = document.getElementById('favorites-container');
  const favoritesEmpty = document.getElementById('favorites-empty');
  const favoritesPagination = document.getElementById('favorites-pagination');
  const favoritesPrevBtn = document.getElementById('favorites-prev-btn');
  const favoritesNextBtn = document.getElementById('favorites-next-btn');
  const favoritesPageInfo = document.getElementById('favorites-page-info');
  
  if (!favoritesSection || !favoritesTitle || !favoritesContainer || !favoritesEmpty) return;
  
  const favorites = getFavorites();
  
  // 캐릭터 검색 결과가 표시된 경우에도 즐겨찾기 섹션은 표시 (CSS로 처리)
  const characterResult = document.getElementById('character-result');
  const mainLayout = document.querySelector('.main-layout');
  const isCharacterResultScreen = mainLayout && mainLayout.classList.contains('show-character-result');
  
  // character-result의 실제 display 상태 확인 (getComputedStyle 사용)
  let isCharacterResultVisible = false;
  if (characterResult) {
    const computedStyle = window.getComputedStyle(characterResult);
    isCharacterResultVisible = computedStyle.display !== 'none';
  }
  
  // 페이지당 아이템 수 결정 (더 정확하게 감지)
  // 캐릭터 검색 결과 화면: 7 columns * 2 rows = 14개
  // 홈 화면: 3 columns * 3 rows = 9개
  let itemsPerPage = 9; // 기본값
  // character-result가 표시되어 있거나 show-character-result 클래스가 있으면 검색 결과 화면
  if (isCharacterResultScreen || isCharacterResultVisible) {
    itemsPerPage = 14; // 검색 결과 화면
  }
  
  // 총 페이지 수 계산
  const totalPages = Math.ceil(favorites.length / itemsPerPage);
  
  // 현재 페이지가 범위를 벗어나면 조정
  if (favoritesCurrentPage >= totalPages) {
    favoritesCurrentPage = Math.max(0, totalPages - 1);
  }
  
  // 현재 페이지의 즐겨찾기 아이템 가져오기
  const startIndex = favoritesCurrentPage * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const currentPageFavorites = favorites.slice(startIndex, endIndex);
  
  // 캐릭터 검색 결과 화면에서는 CSS로 표시되므로 display는 변경하지 않음
  // 하지만 컨텐츠는 업데이트해야 함 (즐겨찾기 추가/제거 시)
  
  if (favorites.length === 0) {
    // 즐겨찾기가 없을 때 display 제어
    if (!isCharacterResultScreen) {
      favoritesSection.style.display = 'grid';
      favoritesTitle.style.display = 'block';
    } else {
      // 캐릭터 검색 결과 화면에서는 CSS로 표시되므로 display는 변경하지 않음
      favoritesSection.style.display = '';
      favoritesTitle.style.display = '';
    }
    favoritesContainer.innerHTML = '';
    favoritesEmpty.style.display = 'block';
    if (favoritesPagination) favoritesPagination.style.display = 'none';
    return;
  }
  
  // 즐겨찾기가 있을 때 display 제어
  if (!isCharacterResultScreen) {
    favoritesSection.style.display = 'grid';
    favoritesTitle.style.display = 'block';
  } else {
    // 캐릭터 검색 결과 화면에서는 CSS로 표시되므로 display는 변경하지 않음
    favoritesSection.style.display = '';
    favoritesTitle.style.display = '';
  }
  favoritesContainer.innerHTML = '';
  favoritesEmpty.style.display = 'none';
  
  // 페이지네이션 표시 여부 결정
  if (favoritesPagination) {
    if (totalPages > 1) {
      favoritesPagination.style.display = 'flex';
      if (favoritesPageInfo) {
        favoritesPageInfo.textContent = `${favoritesCurrentPage + 1} / ${totalPages}`;
      }
      if (favoritesPrevBtn) {
        favoritesPrevBtn.disabled = favoritesCurrentPage === 0;
        favoritesPrevBtn.style.opacity = favoritesCurrentPage === 0 ? '0.5' : '1';
        favoritesPrevBtn.style.cursor = favoritesCurrentPage === 0 ? 'not-allowed' : 'pointer';
      }
      if (favoritesNextBtn) {
        favoritesNextBtn.disabled = favoritesCurrentPage >= totalPages - 1;
        favoritesNextBtn.style.opacity = favoritesCurrentPage >= totalPages - 1 ? '0.5' : '1';
        favoritesNextBtn.style.cursor = favoritesCurrentPage >= totalPages - 1 ? 'not-allowed' : 'pointer';
      }
    } else {
      favoritesPagination.style.display = 'none';
    }
  }
  
  currentPageFavorites.forEach(fav => {
    const card = document.createElement('div');
    card.style.cssText = 'background: rgba(4, 7, 25, 0.35); border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 10px; padding: 0.6rem; cursor: pointer; transition: all 0.2s ease;';
    card.onmouseover = () => {
      card.style.transform = 'translateY(-2px)';
      card.style.borderColor = 'rgba(157, 140, 255, 0.4)';
    };
    card.onmouseout = () => {
      card.style.transform = '';
      card.style.borderColor = 'rgba(255, 255, 255, 0.12)';
    };
    card.onclick = (e) => {
      e.preventDefault();
      
      // 이미 검색 중이거나 쿨다운 중이면 클릭 무시
      if (window.isFavoriteSearching || window.favoriteCardCooldown) {
        return;
      }
      
      // 서버 정보 가져오기
      const serverDataEl = document.getElementById('server-data');
      const servers = serverDataEl ? JSON.parse(serverDataEl.textContent) : { elyos: [], asmodian: [] };
      
      const raceValue = fav.race === '천족' ? '1' : fav.race === '마족' ? '2' : '';
      let serverId = '';
      
      if (raceValue === '1' && servers.elyos) {
        const serverInfo = servers.elyos.find(s => s.name === fav.server);
        if (serverInfo) serverId = serverInfo.id;
      } else if (raceValue === '2' && servers.asmodian) {
        const serverInfo = servers.asmodian.find(s => s.name === fav.server);
        if (serverInfo) serverId = serverInfo.id;
      }
      
      if (!fav.nickname || !raceValue || !serverId) return;
      
      // 즐겨찾기 카드 비활성화 플래그 설정
      window.isFavoriteSearching = true;
      window.favoriteCardCooldown = true;
      
      // 모든 즐겨찾기 카드 비활성화
      const allFavoriteCards = favoritesContainer.querySelectorAll('div');
      allFavoriteCards.forEach(c => {
        // 카드인지 확인 (삭제 버튼이 아닌 카드 자체)
        if (!c.classList.contains('favorite-delete-btn') && c.style.cursor === 'pointer') {
          c.style.pointerEvents = 'none';
          c.style.opacity = '0.5';
          c.style.cursor = 'not-allowed';
        }
      });
      // 클릭한 카드도 비활성화
      card.style.pointerEvents = 'none';
      card.style.opacity = '0.5';
      card.style.cursor = 'not-allowed';
      
      // 전역 변수 초기화 (이전 캐릭터 데이터가 남지 않도록)
      window.attackPowerResult = null;
      window.combatSpeedResult = null;
      window.damageAmplificationResult = null;
      window.skillDamageResult = null;
      window.cooldownReductionResult = null;
      window.daevanionData = null;
      window.currentEquipment = null;
      window.currentAccessories = null;
      window.currentStatData = null;
      window.currentSkills = null;
      window.currentStigmas = null;
      window.currentSkillPriorities = null;
      window.currentTitles = null;
      window.cachedCombatScore = undefined;
      window.isCacheMiss = false;
      window.logCharacterInfoCalled = false;
      // ★ 추가: 더 많은 전역 변수 초기화 (이전 캐릭터 데이터 잔류 방지)
      window.perfectResult = null;
      window.stunHitResult = null;
      window.multiHitResult = null;
      window.criticalHitResult = null;
      window.weaponMinAttack = 0;
      window.weaponMaxAttack = 0;
      window.currentCombatScoreMax = null;
      window.currentCombatPower = null;
      // 데바니온 포인트 변수 초기화 (updateAllDaevanionSkillPoints가 다시 호출되도록)
      window.daevanionSharedPoints = undefined;
      window.daevanionArielPoints = undefined;
      window.daevanionAspelPoints = undefined;
      
      // 캐릭터 검색 탭으로 이동
      const characterTab = document.getElementById('tab-character');
      if (characterTab) {
        characterTab.checked = true;
        characterTab.dispatchEvent(new Event('change'));
        updateSidebarVisibility();
        
        // 검색 폼에 값 설정
        const raceSelect = document.getElementById('race-select');
        const serverSelect = document.getElementById('server-select');
        const keywordInput = document.getElementById('character-keyword');
        
        // 종족 버튼 업데이트 (즐겨찾기 캐릭터 클릭이므로 localStorage에 저장하지 않음)
        if (raceValue) {
          updateRaceSelection(raceValue, true);
        }
        
        // 서버 선택이 활성화될 때까지 대기
        setTimeout(() => {
          if (serverSelect) {
            serverSelect.value = serverId;
            if (keywordInput) keywordInput.value = fav.nickname;
            
            // 로딩 표시 유지
            document.getElementById('character-loading').style.display = 'block';
            const favoriteLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
            if (favoriteLoadingOverlay) {
              favoriteLoadingOverlay.style.display = 'flex';
            }
            
            // 검색 실행
            performSearch();
          }
        }, 300);
      }
    };
    
    const raceColor = fav.race === '천족' ? '#3b82f6' : '#ef4444';
    
    card.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem; position: relative;">
        ${fav.avatar_url ? `
          <img src="${fav.avatar_url}" alt="${fav.nickname}" style="width: 56px; height: 84px; border-radius: 6px; border: 2px solid ${raceColor}40; object-fit: cover; flex-shrink: 0;">
        ` : `
          <div style="width: 56px; height: 84px; border-radius: 6px; border: 2px solid ${raceColor}40; background: rgba(255, 255, 255, 0.05); display: flex; align-items: center; justify-content: center; color: var(--text-muted); font-size: 1.5rem; flex-shrink: 0;">👤</div>
        `}
        <div style="flex: 1; display: flex; flex-direction: column; gap: 0.35rem; min-width: 0; overflow: hidden;">
          <div style="font-weight: 600; font-size: 0.9rem; color: #ffffff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height: 1.2;">${fav.nickname}</div>
          <div style="font-size: 0.75rem; color: ${raceColor}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${fav.race}</div>
          <div style="font-size: 0.7rem; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${fav.server}</div>
        </div>
        <button class="favorite-delete-btn" data-nickname="${fav.nickname}" data-server="${fav.server}" data-race="${fav.race}" style="position: absolute; top: -8px; right: -8px; background: rgba(239, 68, 68, 0.9); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: #ffffff; width: 22px; height: 22px; cursor: pointer; font-size: 0.85rem; font-weight: bold; transition: all 0.2s ease; display: none; align-items: center; justify-content: center; z-index: 10; line-height: 1; padding: 0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);" title="즐겨찾기 제거" onmouseover="this.style.background='rgba(239, 68, 68, 1)'; this.style.transform='scale(1.1)';" onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)';">×</button>
      </div>
    `;
    
    // 마우스 오버 시 삭제 버튼 표시
    card.onmouseenter = () => {
      const deleteBtn = card.querySelector('.favorite-delete-btn');
      if (deleteBtn) {
        deleteBtn.style.display = 'flex';
      }
    };
    
    card.onmouseleave = () => {
      const deleteBtn = card.querySelector('.favorite-delete-btn');
      if (deleteBtn) {
        deleteBtn.style.display = 'none';
      }
    };
    
    // 삭제 버튼 클릭 이벤트
    const deleteBtn = card.querySelector('.favorite-delete-btn');
    if (deleteBtn) {
      deleteBtn.onclick = (e) => {
        e.stopPropagation(); // 카드 클릭 이벤트 방지
        
        const nickname = deleteBtn.getAttribute('data-nickname');
        const server = deleteBtn.getAttribute('data-server');
        const race = deleteBtn.getAttribute('data-race');
        
        if (nickname && server && race) {
          removeFavorite({ nickname, server, race });
          renderFavorites();
          
          // 캐릭터 검색 결과 화면에서도 별표 업데이트
          const characterResult = document.getElementById('character-result');
          if (characterResult && characterResult.style.display !== 'none') {
            const resultNickname = document.getElementById('result-nickname');
            if (resultNickname && resultNickname.textContent === nickname) {
              const character = {
                nickname: nickname,
                server: server,
                race: race
              };
              updateFavoriteStar(character);
            }
          }
        }
      };
    }
    
    favoritesContainer.appendChild(card);
  });
  
  // 페이지네이션 버튼 이벤트
  if (favoritesPrevBtn) {
    favoritesPrevBtn.onclick = () => {
      if (favoritesCurrentPage > 0) {
        favoritesCurrentPage--;
        renderFavorites();
      }
    };
  }
  
  if (favoritesNextBtn) {
    favoritesNextBtn.onclick = () => {
      const mainLayout = document.querySelector('.main-layout');
      const isCharacterResultScreen = mainLayout && mainLayout.classList.contains('show-character-result');
      const characterResult = document.getElementById('character-result');
      let isCharacterResultVisible = false;
      if (characterResult) {
        const computedStyle = window.getComputedStyle(characterResult);
        isCharacterResultVisible = computedStyle.display !== 'none';
      }
      const currentItemsPerPage = (isCharacterResultScreen || isCharacterResultVisible) ? 14 : 9;
      const totalPages = Math.ceil(getFavorites().length / currentItemsPerPage);
      if (favoritesCurrentPage < totalPages - 1) {
        favoritesCurrentPage++;
        renderFavorites();
      }
    };
  }
}

// 즐겨찾기 카드 활성화 함수 (쿨다운 후)
function enableFavoriteCardsAfterCooldown() {
  // 쿨다운 타이머가 이미 있으면 취소
  if (window.favoriteCardCooldownTimer) {
    clearTimeout(window.favoriteCardCooldownTimer);
  }
  
  // 4초 후 카드 활성화
  window.favoriteCardCooldownTimer = setTimeout(() => {
    window.favoriteCardCooldown = false;
    const favoritesContainer = document.getElementById('favorites-container');
    if (favoritesContainer) {
      const allFavoriteCards = favoritesContainer.querySelectorAll('div');
      allFavoriteCards.forEach(c => {
        // 카드인지 확인 (삭제 버튼이 아닌 카드 자체)
        if (!c.classList.contains('favorite-delete-btn') && (c.style.cursor === 'not-allowed' || c.style.cursor === 'pointer')) {
          c.style.pointerEvents = '';
          c.style.opacity = '';
          c.style.cursor = 'pointer';
        }
      });
    }
    window.favoriteCardCooldownTimer = null;
  }, 2000); // 4초 쿨다운
}

// 탭 변경 시 좌우 배너 표시/숨김 처리 함수 (전역으로 선언)
function updateSidebarVisibility() {
  const tabCharacter = document.getElementById('tab-character');
  const characterSearchWrapper = document.getElementById('character-search-wrapper');
  const streamerSection = document.getElementById('streamer-section');
  const streamerTitle = document.getElementById('streamer-title');
  const favoritesSection = document.getElementById('favorites-section');
  const favoritesTitle = document.getElementById('favorites-title');
  const mainDashboard = document.getElementById('main-dashboard');
  
  // 캐릭터 검색 탭일 때만 검색 폼과 스트리머 섹션 표시
  if (characterSearchWrapper) {
    if (tabCharacter && tabCharacter.checked) {
      characterSearchWrapper.style.display = 'block';
      if (streamerSection) {
        streamerSection.style.display = 'grid';
      }
      if (streamerTitle) {
        streamerTitle.style.display = 'block';
      }
      
      // 즐겨찾기 섹션 표시
      renderFavorites();
      
      if (mainDashboard) {
        // [수정됨] 무조건 숨기는 것이 아니라, 표시할 내용(결과, 로딩, 에러)이 없을 때만 숨김
        const resultElement = document.getElementById('character-result');
        const loadingElement = document.getElementById('character-loading');
        const errorElement = document.getElementById('character-error');
        
        const isResultVisible = resultElement && resultElement.style.display !== 'none';
        const isLoading = loadingElement && loadingElement.style.display !== 'none';
        const isError = errorElement && errorElement.style.display !== 'none';

        if (isResultVisible || isLoading || isError) {
            mainDashboard.style.display = 'block'; // 결과가 있으면 보여줌
            // 검색 결과가 표시되면 스트리머 섹션 및 즐겨찾기 섹션 숨김
            if (streamerSection) {
              streamerSection.style.display = 'none';
            }
            if (streamerTitle) {
              streamerTitle.style.display = 'none';
            }
            if (favoritesSection) {
              favoritesSection.style.display = 'none';
            }
            if (favoritesTitle) {
              favoritesTitle.style.display = 'none';
            }
        } else {
            mainDashboard.style.display = 'none';  // 초기 상태면 숨김 (빈 박스 방지)
            // 검색 결과가 없으면 스트리머 섹션 및 즐겨찾기 섹션 표시 (홈 화면)
            if (streamerSection) {
              streamerSection.style.display = 'grid';
            }
            if (streamerTitle) {
              streamerTitle.style.display = 'block';
            }
            renderFavorites();
        }
      }
    } else {
      characterSearchWrapper.style.display = 'none';
      if (streamerSection) {
        streamerSection.style.display = 'none';
      }
      if (streamerTitle) {
        streamerTitle.style.display = 'none';
      }
      if (mainDashboard) {
        mainDashboard.style.display = 'block'; // 다른 탭에서는 항상 보여줌
      }
    }
  }
  const tabRanking = document.getElementById('tab-ranking');
  const tabStatistics = document.getElementById('tab-statistics');
  const mainLayout = document.querySelector('.main-layout');
  
  // 랭킹 또는 통계 탭이 선택되었을 때 스트리머 섹션 숨김 (모바일 포함)
  if (tabRanking && tabRanking.checked) {
    if (streamerSection) {
      streamerSection.style.display = 'none';
    }
    if (streamerTitle) {
      streamerTitle.style.display = 'none';
    }
    if (mainLayout) {
      mainLayout.classList.add('hide-sidebars');
    }
  } else if (tabStatistics && tabStatistics.checked) {
    if (streamerSection) {
      streamerSection.style.display = 'none';
    }
    if (streamerTitle) {
      streamerTitle.style.display = 'none';
    }
    if (mainLayout) {
      mainLayout.classList.add('hide-sidebars');
    }
  } else if (tabCharacter && tabCharacter.checked) {
    if (mainLayout) {
      mainLayout.classList.remove('hide-sidebars');
    }
    // 캐릭터 검색 탭일 때는 검색 결과가 없을 때만 스트리머 섹션 표시
    // (이미 위에서 처리됨)
  }
}

// URL 파라미터에서 캐릭터 정보 읽기 및 자동 검색
function loadCharacterFromUrlParams() {
  // 새로운 URL 형식 확인: /char/serverid=xxxx/{아이디}
  const path = window.location.pathname;
  const charMatch = path.match(/^\/char\/serverid=(\d+)\/(.+)$/);
  
  if (charMatch) {
    const serverId = charMatch[1];
    const nickname = decodeURIComponent(charMatch[2]);
    
    // 서버 정보 찾기
    let race = null;
    let server = null;
    for (const serverList of [servers.elyos || [], servers.asmodian || []]) {
      for (const s of serverList) {
        if (s.id == serverId) {
          server = s.id;
          race = servers.elyos && servers.elyos.includes(s) ? '1' : '2';
          break;
        }
      }
      if (race) break;
    }
    
    if (nickname && race && server) {
      // 로딩 표시를 먼저 설정 (탭 변경 전에)
      document.getElementById('character-result').style.display = 'none';
      document.getElementById('character-all-servers-result').style.display = 'none';
      document.getElementById('character-loading').style.display = 'block';
      const urlLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
      if (urlLoadingOverlay) {
        urlLoadingOverlay.style.display = 'flex';
      }
      
      // 캐릭터 검색 탭으로 이동
      const characterTab = document.getElementById('tab-character');
      if (characterTab) {
        characterTab.checked = true;
        characterTab.dispatchEvent(new Event('change'));
        updateSidebarVisibility();
        
        // 종족 버튼 업데이트 (URL 파라미터로 로드된 것이므로 localStorage에 저장하지 않음)
        if (race) {
          updateRaceSelection(race, true);
        }
        
        // 검색 폼에 값 설정
        const raceSelect = document.getElementById('race-select');
        const serverSelect = document.getElementById('server-select');
        const keywordInput = document.getElementById('character-keyword');
        
        if (raceSelect) raceSelect.value = race;
        if (raceSelect && raceSelect.dispatchEvent) {
          raceSelect.dispatchEvent(new Event('change'));
        }
        
        // 로딩 표시가 updateSidebarVisibility에 의해 숨겨질 수 있으므로 다시 설정
        setTimeout(() => {
          if (serverSelect) {
            serverSelect.value = server;
            if (keywordInput) keywordInput.value = nickname;
            
            // 로딩 표시 유지 (updateSidebarVisibility가 호출되어도 로딩 상태 확인)
            document.getElementById('character-loading').style.display = 'block';
            const urlLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
            if (urlLoadingOverlay2) {
              urlLoadingOverlay2.style.display = 'flex';
            }
            
            // 검색 실행 (performSearch가 로딩 표시를 처리함)
            performSearch();
          }
        }, 300);
      }
      return;
    }
  }
  
  // 기존 URL 파라미터 형식 (하위 호환성)
  const urlParams = new URLSearchParams(window.location.search);
  const nickname = urlParams.get('nickname');
  const race = urlParams.get('race');
  const server = urlParams.get('server');
  
  if (nickname && race && server) {
    // 로딩 표시를 먼저 설정 (탭 변경 전에)
    document.getElementById('character-result').style.display = 'none';
    document.getElementById('character-all-servers-result').style.display = 'none';
    document.getElementById('character-loading').style.display = 'block';
    const urlLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
    if (urlLoadingOverlay2) {
      urlLoadingOverlay2.style.display = 'flex';
    }
    
    // 캐릭터 검색 탭으로 이동
    const characterTab = document.getElementById('tab-character');
    if (characterTab) {
      characterTab.checked = true;
      characterTab.dispatchEvent(new Event('change'));
      updateSidebarVisibility();
      
      // 검색 폼에 값 설정
      const serverSelect = document.getElementById('server-select');
      const keywordInput = document.getElementById('character-keyword');
      
      // 종족 버튼 업데이트 (URL 파라미터로 로드된 것이므로 localStorage에 저장하지 않음)
      if (race) {
        updateRaceSelection(race, true);
      }
      
      setTimeout(() => {
          if (serverSelect) {
            serverSelect.value = server;
            if (keywordInput) keywordInput.value = decodeURIComponent(nickname);
            
            // 로딩 표시 유지 (updateSidebarVisibility가 호출되어도 로딩 상태 확인)
            document.getElementById('character-loading').style.display = 'block';
            const urlLoadingOverlay3 = document.getElementById('fullscreen-loading-overlay');
            if (urlLoadingOverlay3) {
              urlLoadingOverlay3.style.display = 'flex';
            }
            
            // 검색 실행 (performSearch가 로딩 표시를 처리함)
            performSearch();
          }
        }, 300);
    }
  }
}

// 전투력 TOP 5 로드
// 전투력 TOP 5 렌더링 함수 (서버 사이드 데이터와 API 응답 모두 처리)
function renderPowerTop5(data) {
  // API 응답 형식과 서버 사이드 데이터 형식 모두 처리
  const powerData = data.success ? data : { success: true, data: data.data || { elyos: [], asmodian: [] } };
  
  if (powerData.success && powerData.data) {
    // 천족 TOP 5
    const elyosContainer = document.getElementById('power-top5-elyos');
    if (powerData.data.elyos && powerData.data.elyos.length > 0) {
          let html = '';
          // 서버 정보 가져오기
          const serverDataEl = document.getElementById('server-data');
          const servers = serverDataEl ? JSON.parse(serverDataEl.textContent) : { elyos: [], asmodian: [] };
          
      powerData.data.elyos.forEach((item) => {
            // 닉네임 클릭 링크 생성
            let nicknameDisplay = item.nickname;
            let raceValue = '1';
            let serverId = '';
            if (servers && servers.elyos) {
              const serverInfo = servers.elyos.find(s => s.name === item.server);
              if (serverInfo) serverId = serverInfo.id;
            }
            
            if (serverId) {
              // 쿼리 파라미터 형식 사용 (새 탭에서도 loadCharacterFromUrlParams가 제대로 작동하도록)
              const characterUrl = `/?nickname=${encodeURIComponent(item.nickname)}&race=${raceValue}&server=${serverId}`;
              nicknameDisplay = `<a href="${characterUrl}" class="power-top5-nickname-link" data-nickname="${item.nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: inherit; text-decoration: none; cursor: pointer; transition: opacity 0.2s; font-weight: 500;">${item.nickname}</a>`;
            }
            
            // 1200~1400px 범위 체크
            const width = window.innerWidth;
            const isMediumWidth = width >= 1201 && width <= 1400;
            
            if (isMediumWidth) {
              // 2컬럼 레이아웃: 순위 | 닉네임/전투력
              html += `
                <div style="display: grid; grid-template-columns: 30px 1fr; gap: 0.5rem; align-items: start; padding: 0.5rem 0.75rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px; font-size: 0.85rem;">
                  <span style="font-weight: bold; color: #3b82f6; grid-row: 1 / 3; align-self: center; text-align: center;">${item.rank}</span>
                  <span style="font-weight: 500; grid-column: 2; grid-row: 1;">${nicknameDisplay}</span>
                  <span style="color: var(--accent); font-weight: bold; font-size: 0.75rem; grid-column: 2; grid-row: 2;">${item.combat_score_max.toLocaleString()}</span>
                </div>
              `;
            } else {
              // 기본 레이아웃: 순위 - 닉네임 - 전투력
              html += `
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.3rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px; font-size: 0.85rem;">
                  <span style="font-weight: bold; min-width: 20px; color: #3b82f6;">${item.rank}</span>
                  <span style="flex: 1; font-weight: 500;">${nicknameDisplay}</span>
                  <span style="color: var(--accent); font-weight: bold; font-size: 0.72rem; min-width: 50px; text-align: right;">${item.combat_score_max.toLocaleString()}</span>
                </div>
              `;
            }
          });
          elyosContainer.innerHTML = html;
        } else {
          elyosContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">데이터가 없습니다.</p>';
        }
        
    // 마족 TOP 5
    const asmodianContainer = document.getElementById('power-top5-asmodian');
    if (powerData.data.asmodian && powerData.data.asmodian.length > 0) {
          let html = '';
          // 서버 정보 가져오기
          const serverDataEl2 = document.getElementById('server-data');
          const servers2 = serverDataEl2 ? JSON.parse(serverDataEl2.textContent) : { elyos: [], asmodian: [] };
          
      powerData.data.asmodian.forEach((item) => {
            // 닉네임 클릭 링크 생성
            let nicknameDisplay = item.nickname;
            let raceValue = '2';
            let serverId = '';
            if (servers2 && servers2.asmodian) {
              const serverInfo = servers2.asmodian.find(s => s.name === item.server);
              if (serverInfo) serverId = serverInfo.id;
            }
            
            if (serverId) {
              // 쿼리 파라미터 형식 사용 (새 탭에서도 loadCharacterFromUrlParams가 제대로 작동하도록)
              const characterUrl = `/?nickname=${encodeURIComponent(item.nickname)}&race=${raceValue}&server=${serverId}`;
              nicknameDisplay = `<a href="${characterUrl}" class="power-top5-nickname-link" data-nickname="${item.nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: inherit; text-decoration: none; cursor: pointer; transition: opacity 0.2s; font-weight: 500;">${item.nickname}</a>`;
            }
            
            // 1200~1400px 범위 체크
            const width2 = window.innerWidth;
            const isMediumWidth2 = width2 >= 1201 && width2 <= 1400;
            
            if (isMediumWidth2) {
              // 2컬럼 레이아웃: 순위 | 닉네임/전투력
              html += `
                <div style="display: grid; grid-template-columns: 30px 1fr; gap: 0.5rem; align-items: start; padding: 0.5rem 0.75rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px; font-size: 0.85rem;">
                  <span style="font-weight: bold; color: #ef4444; grid-row: 1 / 3; align-self: center; text-align: center;">${item.rank}</span>
                  <span style="font-weight: 500; grid-column: 2; grid-row: 1;">${nicknameDisplay}</span>
                  <span style="color: var(--accent); font-weight: bold; font-size: 0.75rem; grid-column: 2; grid-row: 2;">${item.combat_score_max.toLocaleString()}</span>
                </div>
              `;
            } else {
              // 기본 레이아웃: 순위 - 닉네임 - 전투력
              html += `
                <div style="display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.3rem; background: rgba(255, 255, 255, 0.03); border-radius: 8px; font-size: 0.85rem;">
                  <span style="font-weight: bold; min-width: 20px; color: #ef4444;">${item.rank}</span>
                  <span style="flex: 1; font-weight: 500;">${nicknameDisplay}</span>
                  <span style="color: var(--accent); font-weight: bold; font-size: 0.72rem; min-width: 50px; text-align: right;">${item.combat_score_max.toLocaleString()}</span>
                </div>
              `;
            }
          });
          asmodianContainer.innerHTML = html;
        } else {
          asmodianContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">데이터가 없습니다.</p>';
        }
        
    // 전투력 TOP 5 닉네임 클릭 이벤트 추가
    setupPowerTop5NicknameClicks();
    
    // 천족과 마족 섹션 높이 맞추기 (여러 번 시도하여 확실하게)
    const alignHeights = () => {
          const elyosSection = document.getElementById('power-top5-elyos')?.parentElement;
          const asmodianSection = document.getElementById('power-top5-asmodian')?.parentElement;
          if (elyosSection && asmodianSection) {
            // 높이 재설정 (이전 설정 제거)
            elyosSection.style.height = '';
            asmodianSection.style.height = '';
            
            // 강제 리플로우
            void elyosSection.offsetHeight;
            void asmodianSection.offsetHeight;
            
            // 현재 높이 측정 (getBoundingClientRect 사용)
            const elyosRect = elyosSection.getBoundingClientRect();
            const asmodianRect = asmodianSection.getBoundingClientRect();
            const elyosHeight = elyosRect.height;
            const asmodianHeight = asmodianRect.height;
            const maxHeight = Math.max(elyosHeight, asmodianHeight);
            
            // 더 큰 높이로 통일
            if (maxHeight > 0) {
              elyosSection.style.height = maxHeight + 'px';
              asmodianSection.style.height = maxHeight + 'px';
            }
          }
        };
        
    // 여러 번 시도하여 확실하게 높이 맞추기
    setTimeout(alignHeights, 50);
    setTimeout(alignHeights, 200);
    setTimeout(alignHeights, 500);
    requestAnimationFrame(() => {
      requestAnimationFrame(alignHeights);
    });
    
    // 리사이즈 이벤트 리스너 추가 (전투력 TOP 5 및 서버 정보 레이아웃 업데이트)
    if (!window.powerTop5ResizeHandlerAdded) {
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          loadPowerTop5();
          loadServerStats();
        }, 200);
      });
      window.powerTop5ResizeHandlerAdded = true;
    }
    
    // 리사이즈 시 높이 재조정
    if (!window.powerTop5HeightResizeHandlerAdded) {
      let heightResizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(heightResizeTimeout);
        heightResizeTimeout = setTimeout(() => {
          const elyosSection = document.getElementById('power-top5-elyos')?.parentElement;
          const asmodianSection = document.getElementById('power-top5-asmodian')?.parentElement;
          if (elyosSection && asmodianSection) {
            elyosSection.style.height = '';
            asmodianSection.style.height = '';
            void elyosSection.offsetHeight;
            void asmodianSection.offsetHeight;
            const elyosHeight = elyosSection.getBoundingClientRect().height;
            const asmodianHeight = asmodianSection.getBoundingClientRect().height;
            const maxHeight = Math.max(elyosHeight, asmodianHeight);
            if (maxHeight > 0) {
              elyosSection.style.height = maxHeight + 'px';
              asmodianSection.style.height = maxHeight + 'px';
            }
          }
        }, 250);
      });
      window.powerTop5HeightResizeHandlerAdded = true;
    }
  } else {
    const elyosContainer = document.getElementById('power-top5-elyos');
    const asmodianContainer = document.getElementById('power-top5-asmodian');
    if (elyosContainer) {
      elyosContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">데이터를 불러올 수 없습니다.</p>';
    }
    if (asmodianContainer) {
      asmodianContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">데이터를 불러올 수 없습니다.</p>';
    }
  }
}

function loadPowerTop5() {
  fetch('/api/power-top5')
    .then(response => response.json())
    .then(data => {
      renderPowerTop5(data);
    })
    .catch(error => {
      const elyosContainer = document.getElementById('power-top5-elyos');
      const asmodianContainer = document.getElementById('power-top5-asmodian');
      if (elyosContainer) {
        elyosContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">로딩 오류가 발생했습니다.</p>';
      }
      if (asmodianContainer) {
        asmodianContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">로딩 오류가 발생했습니다.</p>';
      }
    });
}

// 큐나 시세 렌더링 함수 (서버 사이드 데이터와 API 응답 모두 처리)
function renderKinahPrice(priceData, changeData = null) {
  const container = document.getElementById('kinah-price-container');
  if (!container) return;
  
  // API 응답 형식과 서버 사이드 데이터 형식 모두 처리
  const kinahData = priceData.success ? priceData : { success: true, data: priceData.data || null };
  
  if (kinahData.success && kinahData.data) {
    const price = kinahData.data;
    
    // 전일 대비 정보가 없으면 API 호출
    if (!changeData) {
      fetch('/api/quna-chart/current-price')
        .then(response => response.json())
        .then(changeData => {
          renderKinahPriceContent(price, changeData);
        })
        .catch(() => {
          renderKinahPriceContent(price, null);
        });
    } else {
      renderKinahPriceContent(price, changeData);
    }
  } else {
    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">시세 데이터가 없습니다.</p>';
  }
}

// 큐나 시세 내용 렌더링 (내부 함수)
function renderKinahPriceContent(price, changeData) {
  const container = document.getElementById('kinah-price-container');
  if (!container) return;
  
  // 100 큐나당 키나 계산
  const kinahPer100Quna = Math.round(price.per_100_quna_kinah || 0);
  
  // 전일 대비 변동 정보
  let changeHtml = '';
  if (changeData && changeData.success && changeData.data && changeData.data.change !== undefined && changeData.data.change !== 0) {
    const change = changeData.data.change;
    const changePercent = changeData.data.change_percent;
    const isUp = changeData.data.is_up;
    const changeColor = isUp ? '#ef4444' : '#3b82f6'; // 올랐으면 빨강, 떨어졌으면 파랑
    const changeSymbol = isUp ? '▲' : '▼';
    const changeSign = isUp ? '+' : '';
    
    changeHtml = `
      <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        <div style="font-size: 0.85rem; font-weight: 600; color: ${changeColor};">
          ${changeSymbol} ${Math.abs(change).toLocaleString()} (${changeSign}${changePercent}%)
        </div>
      </div>
    `;
  }
  
  // 시간 계산 (방금 전, N분 전 등 + 전체 시간)
  // DB에 저장된 시간이 이미 한국 시간이므로 timezone 변환 없이 사용
  let timeDisplay = '시간 정보 없음';
  let timeDisplayFull = '';
  if (price.updated_at) {
    try {
      // 한국 시간으로 파싱 (timezone 정보 없이 로컬 시간으로 처리)
      const timeStr = price.updated_at.replace(/(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})/, '$1-$2-$3T$4:$5:00');
      const [datePart, timePart] = timeStr.split('T');
      const [year, month, day] = datePart.split('-').map(Number);
      const [hour, minute] = timePart.split(':').map(Number);
      
      // 한국 시간으로 Date 객체 생성 (로컬 시간 기준)
      const updatedTime = new Date(year, month - 1, day, hour, minute);
      const now = new Date();
      const diffMs = now - updatedTime;
      const diffMins = Math.floor(diffMs / 60000);
      
      if (diffMins < 1) {
        timeDisplay = '방금 전';
      } else if (diffMins < 60) {
        timeDisplay = `${diffMins}분 전`;
      } else if (diffMins < 1440) {
        const hours = Math.floor(diffMins / 60);
        timeDisplay = `${hours}시간 전`;
      } else {
        const days = Math.floor(diffMins / 1440);
        timeDisplay = `${days}일 전`;
      }
      
      // 전체 시간도 표시 (한국 시간 - 서버에서 이미 한국 시간으로 반환됨)
      if (price.updated_at_full) {
        timeDisplayFull = price.updated_at_full;
      } else {
        timeDisplayFull = price.updated_at;
      }
    } catch (e) {
      timeDisplay = price.updated_at || '시간 정보 없음';
      timeDisplayFull = price.updated_at || '';
    }
  }
  
  container.innerHTML = `
    <div style="text-align: center;">
      <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-strong); margin-bottom: 0.5rem;">
        ${kinahPer100Quna.toLocaleString()} 키나
      </div>
      <div style="font-size: 1rem; color: var(--accent); margin-bottom: 0.75rem;">
        = 100 큐나
      </div>
      ${changeHtml}
      <div style="font-size: 0.75rem; color: var(--text-muted); line-height: 1.5;">
        기준: ${price.box_amount.toLocaleString()} 키나 상자 / 월드 거래소 <br>
        (${price.quna_price.toLocaleString()} 큐나)<br>
        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="color: var(--text-secondary); font-size: 0.7rem;">
            업데이트: ${timeDisplay}
          </div>
          ${timeDisplayFull ? `<div style="color: var(--text-secondary); font-size: 0.65rem; margin-top: 0.25rem;">${timeDisplayFull}</div>` : ''}
        </div>
      </div>
    </div>
  `;
}

// 큐나 시세 로드 함수
function loadKinahPrice() {
  const container = document.getElementById('kinah-price-container');
  if (!container) return;
  
  // 기본 가격 정보와 전일 대비 정보를 동시에 가져오기
  Promise.all([
    fetch('/api/kinah-price').then(response => response.json()),
    fetch('/api/quna-chart/current-price').then(response => response.json())
  ])
    .then(([priceData, changeData]) => {
      renderKinahPrice(priceData, changeData);
    })
    .catch(error => {
      const container = document.getElementById('kinah-price-container');
      if (container) {
        container.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 0.85rem;">시세 정보를 불러올 수 없습니다.</p>';
      }
    });
}

// alignSectionBadges 함수 제거됨 - 카드 제목 겹침 문제 해결을 위해 제거

// 페이지 로드 시 일일 검색 랭킹과 서버 통계 로드
document.addEventListener('DOMContentLoaded', function() {
  // 즐겨찾기 섹션 초기 렌더링
  renderFavorites();
  
  // URL 해시에서 스킬 통계 직업 정보 확인
  checkSkillStatsHash();
  
  // 서버 사이드에서 전달된 Redis 캐시 데이터 사용 (0.01초 만에 표시)
  
  // 서버 사이드 캐시가 없으면 API 호출 (폴백)
  // 우선순위 1: 즉시 로드 (빠른 API, 캐싱됨)
  // loadKinahPrice(); // 큐나 시세 기능 임시 비활성화
  loadPowerTop5();
  
  // 우선순위 2: 약간 지연 로드 (중간 우선순위)
  setTimeout(() => {
    loadDailySearchRanking();
    loadServerStats();
    loadAion2Updates();
  }, 100);
  
  
  // 페이지 로드 시 URL 파라미터가 있으면 즉시 로딩 표시
  (function() {
    const path = window.location.pathname;
    const charMatch = path.match(/^\/char\/serverid=(\d+)\/(.+)$/);
    const urlParams = new URLSearchParams(window.location.search);
    const hasNicknameParam = urlParams.get('nickname');
    
    if (charMatch || hasNicknameParam) {
      // DOM이 로드되기 전이므로 즉시 표시
      const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
      }
      const characterLoading = document.getElementById('character-loading');
      if (characterLoading) {
        characterLoading.style.display = 'block';
      }
    }
  })();
  
  // URL 파라미터에서 캐릭터 정보 읽기
  loadCharacterFromUrlParams();
  startEventCountdowns();
  
  // 공지사항 아코디언 기능
  const announcementItems = document.querySelectorAll('.announcement-item');
  
  announcementItems.forEach(item => {
    const header = item.querySelector('.announcement-header');
    header.addEventListener('click', function() {
      const isActive = item.classList.contains('active');
      
      // 다른 항목들 닫기
      announcementItems.forEach(otherItem => {
        if (otherItem !== item) {
          otherItem.classList.remove('active');
        }
      });
      
      // 현재 항목 토글
      if (isActive) {
        item.classList.remove('active');
      } else {
        item.classList.add('active');
      }
    });
  });
  
  // 탭 변경 이벤트 리스너
  const tabCharacter = document.getElementById('tab-character');
  const tabRanking = document.getElementById('tab-ranking');
  const tabStatistics = document.getElementById('tab-statistics');
  
  // 탭 변경 시 맨 위로 스크롤하는 함수
  function scrollToTop() {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }
  
  // 캐릭터 검색 결과 숨기는 공통 함수
  function hideCharacterResult() {
    const characterResult = document.getElementById('character-result');
    if (characterResult) {
      characterResult.style.display = 'none';
    }
    const mainLayout = document.querySelector('.main-layout');
    if (mainLayout) {
      mainLayout.classList.remove('show-character-result');
    }
  }
  
  if (tabCharacter) {
    tabCharacter.addEventListener('change', function() {
      if (tabCharacter.checked) {
        // URL 업데이트
        updateURL('character', false);
      }
      updateSidebarVisibility();
      scrollToTop();
    });
  }
  if (tabRanking) {
    tabRanking.addEventListener('change', function() {
      if (tabRanking.checked) {
        // 캐릭터 검색 결과 숨김
        hideCharacterResult();
        // URL 업데이트 (캐릭터 검색 URL 제거, pathname도 정리)
        updateURL('ranking', false, true);
      }
      updateSidebarVisibility();
      scrollToTop();
      // 랭킹 탭이 선택되면 필터 초기화 및 랭킹 로드
      if (tabRanking.checked) {
        initializeRankingFilters();
        setupRankingSubTabs();
        // 랭킹 탭이 활성화될 때만 랭킹 데이터 로드
        const activeSubTab = document.querySelector('#panel-ranking .statistics-sub-tab-btn.active');
        if (activeSubTab && activeSubTab.dataset.target === 'region-ranking') {
          // 레기온 랭킹 필터 초기화는 setupRankingSubTabs에서 처리됨
        } else if (rankingBody) {
          loadRanking('all', 'all', 'all', 1);
        }
      }
    });
  }
  if (tabStatistics) {
    tabStatistics.addEventListener('change', function() {
      if (tabStatistics.checked) {
        // 캐릭터 검색 결과 숨김
        hideCharacterResult();
        // URL 업데이트 (캐릭터 검색 URL 제거, pathname도 정리, 기본적으로 jobstats로 설정)
        updateURL('statistics/jobstats', false, true);
      }
      updateSidebarVisibility();
      scrollToTop();
      // setupStatisticsSubTabs만 호출 (데이터 로드는 DOMContentLoaded에서 처리)
      setupStatisticsSubTabs();
    });
  }
  
  // 페이지 로드 시 이미 체크된 탭 처리 (URL 직접 접속 시)
  // 랭킹 관련 서브탭이면 메인 탭도 체크되어 있어야 함
  const path = window.location.pathname;
  if (path.startsWith('/ranking')) {
    if (tabRanking && !tabRanking.checked) {
      tabRanking.checked = true;
      tabRanking.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }
  
  // 통계 탭 초기화 (랭킹 탭 초기화 전에 처리)
  if (path.startsWith('/statistics')) {
    if (tabStatistics && !tabStatistics.checked) {
      tabStatistics.checked = true;
      // change 이벤트를 발생시키지 않음 (중복 호출 방지)
      // 초기화는 아래 블록에서 처리
    }
  }
  
  if (tabStatistics && tabStatistics.checked) {
    // 통계 탭이 이미 체크되어 있으면 초기화 수행
    setupStatisticsSubTabs();
    
    // 서브탭에 따라 적절한 데이터 로드
    const activeSubTab = document.querySelector('#panel-statistics .statistics-sub-tab-btn.active');
    const subTabTarget = activeSubTab ? activeSubTab.dataset.target : 'job-statistics';
    
    if (subTabTarget === 'skill-statistics') {
      // 스킬 통계 초기화 및 로드 (중복 호출 방지)
      if (typeof setupSkillStatsClassSelector === 'function' && !window.skillStatsInitialized) {
        setupSkillStatsClassSelector();
        window.skillStatsInitialized = true;
      }
      setTimeout(() => {
        if (typeof loadSkillStatistics === 'function' && !window.skillStatsLoading) {
          window.skillStatsLoading = true;
          const activeJobBtn = document.querySelector('.skill-stats-class-btn.active');
          const job = activeJobBtn ? activeJobBtn.dataset.job : '검성';
          loadSkillStatistics(job);
          setTimeout(() => {
            window.skillStatsLoading = false;
          }, 1000);
        }
      }, 100);
    } else if (subTabTarget === 'item-statistics') {
      // 아이템 통계 초기화 및 로드 (중복 호출 방지)
      if (typeof initializeItemStatisticsControls === 'function' && !window.itemStatsControlsInitialized) {
        initializeItemStatisticsControls();
        window.itemStatsControlsInitialized = true;
      }
      if (typeof itemStatisticsJobSelectorInitialized === 'undefined' || !itemStatisticsJobSelectorInitialized) {
        if (typeof setupItemStatisticsJobSelector === 'function') {
          setupItemStatisticsJobSelector();
        }
      }
      setTimeout(() => {
        if (typeof loadItemStatistics === 'function' && !window.itemStatsLoading) {
          window.itemStatsLoading = true;
          loadItemStatistics();
          setTimeout(() => {
            window.itemStatsLoading = false;
          }, 1000);
        }
      }, 100);
    } else {
      // 직업 통계 로드
      if (typeof loadStatistics === 'function') {
        loadStatistics();
      }
    }
  }
  
  if (tabRanking && tabRanking.checked) {
    // 랭킹 탭이 이미 체크되어 있으면 초기화 수행
    initializeRankingFilters();
    setupRankingSubTabs();
    
    // 서브탭에 따라 적절한 데이터 로드
    const activeSubTab = document.querySelector('#panel-ranking .statistics-sub-tab-btn.active');
    const subTabTarget = activeSubTab ? activeSubTab.dataset.target : 'combat-power-ranking';
    
    if (subTabTarget === 'region-ranking') {
      // 레기온 랭킹 초기화 및 로드
      if (typeof initializeRegionRankingFilters === 'function') {
        initializeRegionRankingFilters();
      }
      setTimeout(() => {
        if (typeof loadRegionRankings === 'function') {
          loadRegionRankings(1);
        }
      }, 100);
    } else if (subTabTarget === 'farming-ranking') {
      // 내실 랭킹 초기화 및 로드 (중복 호출 방지)
      // active_farming_type에 따라 타입 설정
      
      if (typeof initializeInternalRankingFilters === 'function' && !window.internalRankingInitialized) {
        initializeInternalRankingFilters();
        window.internalRankingInitialized = true;
      }
      if (typeof setupInternalRankingEventListeners === 'function' && !window.internalRankingListenersSetup) {
        setupInternalRankingEventListeners();
        window.internalRankingListenersSetup = true;
      }
      setTimeout(() => {
        if (typeof loadInternalRanking === 'function' && !window.internalRankingLoading) {
          window.internalRankingLoading = true;
          loadInternalRanking(1);
          setTimeout(() => {
            window.internalRankingLoading = false;
          }, 1000);
        }
      }, 100);
    } else if (subTabTarget === 'combat-score-ranking') {
      // 아툴 전투 점수 랭킹 초기화 및 로드
      if (typeof setupCombatScoreRankingEventListeners === 'function') {
        setupCombatScoreRankingEventListeners();
      }
      setTimeout(() => {
        if (typeof loadCombatScoreRanking === 'function') {
          loadCombatScoreRanking(1);
        }
      }, 100);
    } else if (subTabTarget === 'contents-ranking') {
      // 컨텐츠 랭킹 초기화 및 로드 (중복 호출 방지)
      // active_contents_type에 따라 타입 설정
      
      if (typeof initializeContentsRankingFilters === 'function' && !window.contentsRankingInitialized) {
        initializeContentsRankingFilters();
        window.contentsRankingInitialized = true;
      }
      if (typeof setupContentsRankingEventListeners === 'function' && !window.contentsRankingListenersSetup) {
        setupContentsRankingEventListeners();
        window.contentsRankingListenersSetup = true;
      }
      setTimeout(() => {
        if (typeof loadContentsRanking === 'function' && !window.contentsRankingLoading) {
          window.contentsRankingLoading = true;
          loadContentsRanking(1);
          setTimeout(() => {
            window.contentsRankingLoading = false;
          }, 1000);
        }
      }, 100);
    } else if (rankingBody) {
      // 전투력 랭킹 로드
      loadRanking('all', 'all', 'all', 1);
    }
  }
  
  // 통계 탭 초기화는 위의 path.startsWith('/statistics') 블록에서 이미 처리됨
  // 중복 호출 방지를 위해 이 블록은 제거됨
  
  // URL 해시로 탭 선택 처리
  function handleHashChange() {
    const hash = window.location.hash.replace('#', '');
    
    // char/serverid=xxx/닉네임 형식 처리
    if (hash.startsWith('char/serverid=')) {
      const charMatch = hash.match(/^char\/serverid=(\d+)\/(.+)$/);
      if (charMatch) {
        const serverId = charMatch[1];
        const nickname = decodeURIComponent(charMatch[2]);
        
        // 서버 정보 찾기
        const serverDataEl = document.getElementById('server-data');
        let servers = { elyos: [], asmodian: [] };
        if (serverDataEl && serverDataEl.textContent) {
          try {
            servers = JSON.parse(serverDataEl.textContent);
          } catch (e) {
          }
        }
        
        let race = null;
        let server = null;
        for (const serverList of [servers.elyos || [], servers.asmodian || []]) {
          for (const s of serverList) {
            if (s.id == serverId) {
              server = s.id;
              race = servers.elyos && servers.elyos.some(es => es.id == serverId) ? '1' : '2';
              break;
            }
          }
          if (race) break;
        }
        
        if (nickname && race && server && tabCharacter) {
          // 캐릭터 검색 탭으로 이동
          tabCharacter.checked = true;
          tabCharacter.dispatchEvent(new Event('change'));
          updateSidebarVisibility();
          
          // 검색 폼에 값 설정
          const serverSelect = document.getElementById('server-select');
          const keywordInput = document.getElementById('character-keyword');
          
          // 종족 버튼 업데이트 (캐릭터 링크 클릭이므로 localStorage에 저장하지 않음)
          if (race) {
            updateRaceSelection(race, true);
          }
          
          setTimeout(() => {
            if (serverSelect) {
              serverSelect.value = server;
              if (keywordInput) keywordInput.value = nickname;
              
              // 로딩 표시 유지
              document.getElementById('character-loading').style.display = 'block';
              const hashLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
              if (hashLoadingOverlay2) {
                hashLoadingOverlay2.style.display = 'flex';
              }
              
              // 검색 실행
              performSearch();
            }
          }, 300);
          scrollToTop();
          return;
        }
      }
    }
    
    if (hash === 'character' && tabCharacter) {
      tabCharacter.checked = true;
      tabCharacter.dispatchEvent(new Event('change'));
      scrollToTop();
    } else if (hash === 'ranking' && tabRanking) {
      tabRanking.checked = true;
      tabRanking.dispatchEvent(new Event('change'));
      scrollToTop();
    } else if (hash.startsWith('ranking/region') && tabRanking) {
      tabRanking.checked = true;
      tabRanking.dispatchEvent(new Event('change'));
      scrollToTop();
      setTimeout(() => {
        // setupRankingSubTabs가 먼저 호출되어야 함
        if (typeof setupRankingSubTabs === 'function') {
          setupRankingSubTabs();
        }
        const regionTab = document.querySelector('#panel-ranking .statistics-sub-tab-btn[data-target="region-ranking"]');
        if (regionTab) {
          regionTab.click();
        } else {
        }
      }, 200);
    } else if (hash.startsWith('region/') && tabRanking) {
      tabRanking.checked = true;
      tabRanking.dispatchEvent(new Event('change'));
      scrollToTop();
      const parts = hash.split('/');
      if (parts.length >= 3) {
        const server = decodeURIComponent(parts[1]);
        const guild = decodeURIComponent(parts.slice(2).join('/'));
        setTimeout(() => {
          loadRegionDetail(server, guild);
        }, 100);
      }
    } else if (hash === 'statistics' && tabStatistics) {
      tabStatistics.checked = true;
      // change 이벤트를 발생시키지 않음 (중복 호출 방지)
      // 초기화는 DOMContentLoaded 블록에서 처리됨
      hideCharacterResult();
      updateURL('statistics/jobstats', false, true);
      updateSidebarVisibility();
      scrollToTop();
      setupStatisticsSubTabs();
    }
  }
  
  // 초기 해시 처리
  handleHashChange();
  
  // 해시 변경 이벤트 리스너
  window.addEventListener('hashchange', function() {
    handleHashChange();
    scrollToTop();
    // URL에서 상태 복원
    restoreStateFromURL();
  });
  
  // 브라우저 뒤로가기/앞으로가기 처리
  window.addEventListener('popstate', function(event) {
    const path = window.location.pathname;
    
    // 캐릭터 검색 결과 URL인 경우
    const charMatch = path.match(/^\/char\/serverid=(\d+)\/(.+)$/);
    if (charMatch) {
      loadCharacterFromUrlParams();
      return;
    }
    
    // 홈 경로 또는 기본 경로인 경우
    if (path === '/' || path === '') {
      hideCharacterResult();
      // 캐릭터 검색 탭 활성화
      const tabCharacter = document.getElementById('tab-character');
      if (tabCharacter) {
        tabCharacter.checked = true;
      }
      scrollToTop();
      return;
    }
    
    // 다른 경로인 경우 (랭킹, 통계 등)
    hideCharacterResult();
    activateTabByPath();
    scrollToTop();
  });
  
  // 초기 상태 설정
  updateSidebarVisibility();
  
  // URL에서 상태 복원 (초기 로드 시)
  restoreStateFromURL();
  
  // 통계 탭이 처음부터 선택되어 있으면 통계 로드
  if (tabStatistics && tabStatistics.checked) {
    loadStatistics();
    setupStatisticsSubTabs();
  } else {
    setupStatisticsSubTabs(); // 초기화 (탭 이동 시 자동 동작)
  }
  
  // 내실 랭킹 서브탭 이벤트 리스너는 setupInternalRankingEventListeners에서 등록
});

// 레기온 랭킹 관련 변수 (전역 스코프)
// 중복 선언 방지
if (typeof currentRegionRaceFilter === 'undefined') {
  var currentRegionRaceFilter = 'all';
}
if (typeof currentRegionServerFilter === 'undefined') {
  var currentRegionServerFilter = 'all';
}
if (typeof currentRegionPage === 'undefined') {
  var currentRegionPage = 1;
}
if (typeof regionSearchQuery === 'undefined') {
  var regionSearchQuery = '';
}

// 랭킹 서브 탭 설정
function setupRankingSubTabs() {
  const btns = document.querySelectorAll('#panel-ranking .statistics-sub-tab-btn');
  const contents = {
    'combat-power-ranking': document.getElementById('combat-power-ranking-content'),
    'farming-ranking': document.getElementById('internal-ranking-content'),
    'combat-score-ranking': document.getElementById('combat-score-ranking-content'),
    'contents-ranking': document.getElementById('contents-ranking-content'),
    'region-ranking': document.getElementById('region-ranking-content')
  };
  
  if (btns.length === 0) return; // 요소가 없으면 리턴
  
  // a 태그인 경우 클릭 이벤트 등록하지 않음 (페이지 이동으로 처리)
  // 초기 상태만 갱신
  const activeBtn = document.querySelector('#panel-ranking .statistics-sub-tab-btn.active') || btns[0];
  if (activeBtn) {
    const target = activeBtn.dataset.target;
    Object.keys(contents).forEach(key => {
      if (contents[key]) {
        contents[key].style.display = key === target ? 'block' : 'none';
      }
    });
    
    // 메인 탭의 border-bottom 유지
    const mainTabsContainer = document.querySelector('#panel-ranking .statistics-sub-tabs');
    if (mainTabsContainer) {
      mainTabsContainer.classList.remove('no-border-bottom');
    }
    
    if (target === 'farming-ranking') {
      // 내실 랭킹은 setupRankingSubTabs에서 처리하지 않음 (중복 방지)
      // DOMContentLoaded에서만 처리
    } else if (target === 'contents-ranking') {
      // 컨텐츠 랭킹은 setupRankingSubTabs에서 처리하지 않음 (중복 방지)
      // DOMContentLoaded에서만 처리
    } else if (target === 'region-ranking') {
      try {
        if (typeof initializeRegionRankingFilters === 'function') {
          initializeRegionRankingFilters();
        }
      } catch (e) {
      }
      setTimeout(() => {
        try {
          if (typeof loadRegionRankings === 'function') {
            loadRegionRankings();
          } else {
          }
        } catch (e) {
        }
      }, 100);
    }
  }
}

// 통계 서브 탭 설정
function setupStatisticsSubTabs() {
  const btns = document.querySelectorAll('#panel-statistics .statistics-sub-tab-btn');
  const contents = {
    'job-statistics': document.getElementById('job-statistics-content'),
    'skill-statistics': document.getElementById('skill-statistics-content'),
    'item-statistics': document.getElementById('item-statistics-content')
  };
  
  if (btns.length === 0) return; // 요소가 없으면 리턴
  
  // a 태그인 경우 클릭 이벤트 등록하지 않음 (페이지 이동으로 처리)
  // 초기 상태만 갱신
  const activeBtn = document.querySelector('#panel-statistics .statistics-sub-tab-btn.active') || btns[0];
  if (activeBtn) {
    const target = activeBtn.dataset.target;
    // 컨텐츠 표시/숨김 처리
    Object.keys(contents).forEach(key => {
      if (contents[key]) {
        contents[key].style.display = key === target ? 'block' : 'none';
      }
    });
    // 설명 표시/숨김 처리
    Object.keys(STAT_SUBTAB_DESCRIPTIONS).forEach(key => {
      if (STAT_SUBTAB_DESCRIPTIONS[key]) {
        STAT_SUBTAB_DESCRIPTIONS[key].style.display = key === target ? 'block' : 'none';
      }
    });
  }
}

// 아이템 통계 상태
const itemStatisticsState = {
  job: '전체',
  combatPowerMin: 0,
  combatPowerMax: 4999,
  initialized: false
};

// 아이템 통계용 전투력 구간 컨트롤 (동적으로 가져옴)
function getItemStatisticsControls() {
  return {
    minInput: document.getElementById('item-stat-min-input'),
    maxInput: document.getElementById('item-stat-max-input'),
    minRange: document.getElementById('item-stat-range-min'),
    maxRange: document.getElementById('item-stat-range-max'),
    track: document.getElementById('item-stat-range-track'),
    summary: document.getElementById('item-stat-range-summary'),
    applyButton: document.getElementById('item-stat-apply-button')
  };
}

// 아이템 통계 슬라이더 초기화
function initializeItemStatisticsControls() {
  const controls = getItemStatisticsControls();
  if (!controls.minInput || !controls.maxInput || !controls.minRange || !controls.maxRange || !controls.track || !controls.applyButton) {
    return;
  }

  let minValue = itemStatisticsState.combatPowerMin || 0;
  let maxValue = itemStatisticsState.combatPowerMax || 4999;

  // 이미 초기화되었으면 값만 업데이트하고 이벤트 리스너는 추가하지 않음
  if (itemStatisticsState.initialized) {
    controls.minInput.value = minValue;
    controls.maxInput.value = maxValue;
    controls.minRange.value = minValue;
    controls.maxRange.value = maxValue;
    updateItemRangeTrack(controls, minValue, maxValue);
    if (controls.summary) {
      controls.summary.textContent = `${Number(minValue).toLocaleString()} ~ ${Number(maxValue).toLocaleString()} 전투력 기준`;
    }
    return;
  }

  function clampItemRange() {
    if (maxValue < minValue) {
      maxValue = minValue;
    }
    if (maxValue - minValue < STAT_MIN_GAP) {
      maxValue = minValue + STAT_MIN_GAP;
    }
  }

  function updateItemRangeTrack(ctrl, minVal, maxVal) {
    const bounds = { min: 0, max: 5000 };
    const span = bounds.max - bounds.min || 1;
    const startPercent = ((minVal - bounds.min) / span) * 100;
    const endPercent = ((maxVal - bounds.min) / span) * 100;
    const gradientValue = `linear-gradient(90deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.15) ${startPercent}%, rgba(157, 140, 255, 0.9) ${startPercent}%, rgba(236, 72, 153, 0.9) ${endPercent}%, rgba(255,255,255,0.15) ${endPercent}%, rgba(255,255,255,0.15) 100%)`;
    ctrl.track.style.setProperty('background', gradientValue, 'important');
    ctrl.track.style.setProperty('background-image', gradientValue, 'important');
  }

  function syncItemRangeUI() {
    clampItemRange();
    controls.minInput.value = minValue;
    controls.maxInput.value = maxValue;
    controls.minRange.value = minValue;
    controls.maxRange.value = maxValue;

    updateItemRangeTrack(controls, minValue, maxValue);

    const minLabel = Number(minValue).toLocaleString();
    const maxLabel = Number(maxValue).toLocaleString();
    if (controls.summary) {
      controls.summary.textContent = `${minLabel} ~ ${maxLabel} 전투력 기준`;
    }
  }

  controls.minInput.addEventListener('input', (e) => {
    const v = parseInt(e.target.value, 10);
    if (!Number.isNaN(v)) {
      minValue = snapToPowerPoint(v);
      syncItemRangeUI();
    }
  });

  controls.maxInput.addEventListener('input', (e) => {
    const v = parseInt(e.target.value, 10);
    if (!Number.isNaN(v)) {
      maxValue = snapToPowerPoint(v);
      syncItemRangeUI();
    }
  });

  controls.minRange.addEventListener('input', (e) => {
    const v = parseInt(e.target.value, 10);
    if (!Number.isNaN(v)) {
      minValue = snapToPowerPoint(v);
      syncItemRangeUI();
    }
  });

  controls.maxRange.addEventListener('input', (e) => {
    const v = parseInt(e.target.value, 10);
    if (!Number.isNaN(v)) {
      maxValue = snapToPowerPoint(v);
      syncItemRangeUI();
    }
  });

  controls.applyButton.addEventListener('click', () => {
    clampItemRange();
    itemStatisticsState.combatPowerMin = minValue;
    itemStatisticsState.combatPowerMax = maxValue;
    loadItemStatistics();
  });

  syncItemRangeUI();
  itemStatisticsState.initialized = true;
}

// 아이템 통계 직업 필터 버튼 설정
// 중복 선언 방지
if (typeof itemStatisticsJobSelectorInitialized === 'undefined') {
  var itemStatisticsJobSelectorInitialized = false;
}
if (typeof itemStatisticsJobSelectorRetryCount === 'undefined') {
  var itemStatisticsJobSelectorRetryCount = 0;
}
const MAX_RETRY_COUNT = 10;

function setupItemStatisticsJobSelector() {
  const contentEl = document.getElementById('item-statistics-content');
  if (!contentEl) {
    if (itemStatisticsJobSelectorRetryCount < MAX_RETRY_COUNT) {
      itemStatisticsJobSelectorRetryCount++;
      setTimeout(() => {
        setupItemStatisticsJobSelector();
      }, 100);
    } else {
    }
    return;
  }
  
  // 탭이 숨겨져 있으면 표시될 때까지 대기
  if (contentEl.style.display === 'none' || window.getComputedStyle(contentEl).display === 'none') {
    if (itemStatisticsJobSelectorRetryCount < MAX_RETRY_COUNT) {
      itemStatisticsJobSelectorRetryCount++;
      setTimeout(() => {
        setupItemStatisticsJobSelector();
      }, 100);
    }
    return;
  }
  
  const btns = contentEl.querySelectorAll('.skill-stats-class-btn');
  
  if (btns.length === 0) {
    if (itemStatisticsJobSelectorRetryCount < MAX_RETRY_COUNT) {
      itemStatisticsJobSelectorRetryCount++;
      setTimeout(() => {
        setupItemStatisticsJobSelector();
      }, 100);
    } else {
    }
    return;
  }
  
  // 재시도 카운터 리셋
  itemStatisticsJobSelectorRetryCount = 0;
  
  // 이전에 선택했던 직업 필터 버튼 복원
  const savedJob = itemStatisticsState.job || '전체';
  btns.forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.job === savedJob) {
      btn.classList.add('active');
    }
  });
  
  // 이벤트 리스너 추가 (기존 리스너는 무시하고 새로 등록)
  // 각 버튼에 고유한 핸들러 함수를 생성하여 확실하게 등록
  btns.forEach((btn, index) => {
    // 기존 이벤트 리스너 제거를 위해 이벤트 타입별로 제거
    const newHandler = function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // 모든 버튼에서 active 제거
      const allBtns = contentEl.querySelectorAll('.skill-stats-class-btn');
      allBtns.forEach(b => b.classList.remove('active'));
      
      // 클릭한 버튼에 active 추가
      btn.classList.add('active');
      
      // 상태 업데이트 및 데이터 로드
      const job = btn.dataset.job;
      if (job) {
        itemStatisticsState.job = job;
        loadItemStatistics();
      }
    };
    
    // 기존 핸들러 제거 후 새 핸들러 추가
    btn.removeEventListener('click', btn._itemStatsHandler);
    btn._itemStatsHandler = newHandler;
    btn.addEventListener('click', newHandler);
  });
  
  itemStatisticsJobSelectorInitialized = true;
}

// 아이템 통계 데이터 로드
function loadItemStatistics() {
  const container = document.getElementById('item-statistics-container');
  const updateInfoEl = document.getElementById('item-statistics-update-info');
  
  if (!container) {
    return;
  }
  
  container.innerHTML = '<p style="text-align: center; color: #ffffff;">로딩 중...</p>';
  if (updateInfoEl) {
    updateInfoEl.textContent = '';
  }
  
  // 필터 파라미터 생성
  const params = new URLSearchParams();
  if (itemStatisticsState.job && itemStatisticsState.job !== '전체') {
    params.append('job', itemStatisticsState.job);
  }
  params.append('combat_power_min', itemStatisticsState.combatPowerMin);
  params.append('combat_power_max', itemStatisticsState.combatPowerMax);
  
  fetch(`/api/stats/items?${params.toString()}`)
    .then(res => {
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      }
      return res.json();
    })
    .then(data => {
      if (!data.success) {
        container.innerHTML = `<p style="text-align: center; color: #ef4444;">${data.error || '데이터 로드 실패'}</p>`;
        return;
      }
      
      // 업데이트 시간 표시
      if (updateInfoEl && data.data.last_updated) {
        updateInfoEl.textContent = `최근 업데이트: ${data.data.last_updated}`;
      } else if (updateInfoEl) {
        updateInfoEl.textContent = '';
      }
      
      renderItemStatistics(data.data);
    })
    .catch(err => {
      container.innerHTML = '<p style="text-align: center; color: #ef4444;">데이터를 불러오는 중 오류가 발생했습니다: ' + err.message + '</p>';
    });
}

// 아이템 통계 렌더링 (5개의 pie chart)
function renderItemStatistics(data) {
  const container = document.getElementById('item-statistics-container');
  
  if (!container) {
    return;
  }
  
  const hasData = Object.keys(data.arcana || {}).length > 0 || 
                  Object.keys(data.main_weapon || {}).length > 0 || 
                  Object.keys(data.gauntlet || {}).length > 0 ||
                  Object.keys(data.armor || {}).length > 0 || 
                  Object.keys(data.accessory || {}).length > 0;
  
  if (!hasData) {
    container.innerHTML = '<p style="text-align: center; color: #ffffff;">데이터가 없습니다.</p>';
    return;
  }
  
  container.innerHTML = '';
  
  // Chart.js 로드 대기
  if (typeof Chart === 'undefined') {
    // Chart.js 로드 대기 (최대 10초)
    let checkCount = 0;
    const maxChecks = 100; // 100ms * 100 = 10초
    const checkChart = setInterval(() => {
      checkCount++;
      if (typeof Chart !== 'undefined') {
        clearInterval(checkChart);
        // Chart.js가 로드되면 다시 렌더링
        renderItemStatistics(data);
      } else if (checkCount >= maxChecks) {
        clearInterval(checkChart);
        container.innerHTML = '<p style="text-align: center; color: #ef4444;">Chart.js가 로드되지 않았습니다.</p>';
      }
    }, 100);
    return;
  }
  
  // 총 통계 대상 수
  const totalCount = data.total_count || 0;
  
  // 그리드 컨테이너 생성 (반응형)
  const gridContainer = document.createElement('div');
  gridContainer.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem; margin-top: 1rem;';
  gridContainer.id = 'item-statistics-grid';
  
  // 모바일 반응형 스타일 추가
  const mobileStyle = document.createElement('style');
  mobileStyle.id = 'item-statistics-styles';
  mobileStyle.textContent = `
    #item-statistics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
    }
    #item-statistics-grid .chart-wrapper {
      position: relative;
      height: 350px;
      width: 100%;
    }
    #item-statistics-grid * {
      color: #ffffff !important;
    }
    #item-statistics-grid canvas + div,
    #item-statistics-grid canvas ~ div,
    #item-statistics-grid canvas ~ ul,
    #item-statistics-grid canvas ~ li {
      color: #ffffff !important;
    }
    #item-statistics-grid ul,
    #item-statistics-grid li,
    #item-statistics-grid span,
    #item-statistics-grid div,
    #item-statistics-grid label,
    #item-statistics-grid p {
      color: #ffffff !important;
    }
    #item-statistics-grid .chartjs-legend,
    #item-statistics-grid .chartjs-legend * {
      color: #ffffff !important;
      font-size: 22px !important;
    }
    #item-statistics-grid canvas + ul,
    #item-statistics-grid canvas ~ ul,
    #item-statistics-grid canvas + ul li,
    #item-statistics-grid canvas ~ ul li,
    #item-statistics-grid canvas + ul span,
    #item-statistics-grid canvas ~ ul span {
      font-size: 22px !important;
    }
    #item-statistics-grid ul,
    #item-statistics-grid ul li,
    #item-statistics-grid ul li span {
      font-size: 22px !important;
    }
    @media (max-width: 768px) {
      #item-statistics-grid {
        grid-template-columns: 1fr !important;
        gap: 1rem;
      }
      #item-statistics-grid > div {
        padding: 1.5rem !important;
      }
      #item-statistics-grid .chart-wrapper {
        height: 300px !important;
      }
      #item-statistics-grid canvas {
        max-width: 100% !important;
        height: 100% !important;
      }
    }
    @media (max-width: 480px) {
      #item-statistics-grid > div {
        padding: 1rem !important;
      }
      #item-statistics-grid .chart-wrapper {
        height: 250px !important;
      }
    }
  `;
  // 기존 스타일이 있으면 제거
  const existingStyle = document.getElementById('item-statistics-styles');
  if (existingStyle) {
    existingStyle.remove();
  }
  document.head.appendChild(mobileStyle);
  
  // 차트 컨테이너 스타일
  const chartContainerStyle = 'background: linear-gradient(135deg, rgba(9, 16, 37, 0.95), rgba(15, 23, 42, 0.95)); border: 1px solid rgba(157, 140, 255, 0.2); border-radius: 16px; padding: 2rem; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); transition: transform 0.2s ease, box-shadow 0.2s ease;';
  const chartTitleStyle = 'font-size: 1.2rem; font-weight: 700; margin-bottom: 0.5rem; color: #ffffff !important; text-align: center; text-shadow: 0 2px 8px rgba(157, 140, 255, 0.3);';
  const chartSubtitleStyle = 'font-size: 0.9rem; font-weight: 400; margin-bottom: 1.5rem; color: rgba(255, 255, 255, 0.7) !important; text-align: center;';
  const chartWrapperStyle = 'position: relative; height: 350px; width: 100%;';
  const chartContainerHoverStyle = 'transform: translateY(-4px); box-shadow: 0 12px 40px rgba(157, 140, 255, 0.2);';
  
  // 공통 차트 옵션 생성 함수
  function createChartOptions(total, itemName, containerElement) {
    return {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        intersect: true,
        axis: 'x'
      },
      animation: {
        onComplete: function() {
          // legend 텍스트 색상 및 폰트 크기 강제 적용
          if (containerElement) {
            const legendContainer = containerElement.querySelector('.chartjs-legend');
            if (legendContainer) {
              const textElements = legendContainer.querySelectorAll('*');
              textElements.forEach(el => {
                el.style.color = '#ffffff';
                el.style.setProperty('color', '#ffffff', 'important');
                el.style.fontSize = '22px';
                el.style.setProperty('font-size', '22px', 'important');
              });
            }
            // Chart.js가 생성하는 모든 텍스트 요소
            const allText = containerElement.querySelectorAll('li, span, div, label');
            allText.forEach(el => {
              if (el.textContent && el.textContent.trim() && !el.querySelector('canvas')) {
                el.style.color = '#ffffff';
                el.style.setProperty('color', '#ffffff', 'important');
                el.style.fontSize = '22px';
                el.style.setProperty('font-size', '22px', 'important');
              }
            });
            // canvas 다음에 오는 ul (legend)
            const canvas = containerElement.querySelector('canvas');
            if (canvas && canvas.nextElementSibling) {
              const nextSibling = canvas.nextElementSibling;
              if (nextSibling.tagName === 'UL' || nextSibling.querySelector('ul')) {
                const ul = nextSibling.tagName === 'UL' ? nextSibling : nextSibling.querySelector('ul');
                if (ul) {
                  const items = ul.querySelectorAll('li, span');
                  items.forEach(item => {
                    item.style.fontSize = '22px';
                    item.style.setProperty('font-size', '22px', 'important');
                  });
                }
              }
            }
          }
        }
      },
      plugins: {
        legend: {
          position: 'bottom',
          onClick: () => {}, // legend 클릭 비활성화
          labels: {
            color: '#ffffff',
            padding: 12,
            font: { 
              size: 15, 
              weight: '500',
              family: 'inherit'
            },
            usePointStyle: true,
            pointStyle: 'circle',
            generateLabels: function(chart) {
              const data = chart.data;
              if (data.labels.length && data.datasets.length) {
                const dataset = data.datasets[0];
                return data.labels.map((label, i) => {
                  return {
                    text: label,
                    fillStyle: dataset.backgroundColor[i],
                    strokeStyle: dataset.backgroundColor[i],
                    fontColor: '#ffffff',
                    fontStyle: 'normal',
                    fontFamily: 'inherit',
                    fontSize: 15,
                    fontWeight: '500',
                    hidden: false,
                    index: i
                  };
                });
              }
              return [];
            }
          },
          onHover: function(e, legendItem) {
            if (e.native && e.native.target) {
              e.native.target.style.cursor = 'default';
            }
          }
        },
        tooltip: {
          enabled: true,
          intersect: true,
          mode: 'point',
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          titleColor: '#ffffff',
          bodyColor: '#ffffff',
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 1,
          padding: 12,
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.parsed || 0;
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value}${itemName} (${percentage}%)`;
            }
          }
        },
        datalabels: {
          color: '#ffffff',
          font: { size: 14, weight: 'bold' },
          textStrokeColor: '#000000',
          textStrokeWidth: 2,
          formatter: function(value, context) {
            const percentage = ((value / total) * 100).toFixed(1);
            // 3% 이상인 경우만 표시
            if (percentage >= 3) {
              return percentage + '%';
            }
            return '';
          }
        }
      }
    };
  }
  
  // legend 폰트 크기 적용 함수
  function applyLegendFontSize(container, chartInstance) {
    if (!container || !chartInstance) return;
    
    // 여러 번 시도 (Chart.js가 legend를 나중에 렌더링할 수 있음)
    const tryApply = (attempt = 0) => {
      if (attempt > 5) return; // 최대 5번 시도
      
      // Chart.js가 생성한 legend 요소 찾기 - canvas의 부모에서 찾기
      const chartWrapper = container.querySelector('.chart-wrapper');
      if (chartWrapper) {
        // canvas 다음에 오는 모든 형제 요소 (legend)
        let nextSibling = chartWrapper.nextElementSibling;
        while (nextSibling) {
          if (nextSibling.tagName === 'UL' || nextSibling.querySelector('ul')) {
            const ul = nextSibling.tagName === 'UL' ? nextSibling : nextSibling.querySelector('ul');
            if (ul) {
              const items = ul.querySelectorAll('li');
              items.forEach(item => {
                const spans = item.querySelectorAll('span');
                spans.forEach(span => {
                  span.style.fontSize = '22px';
                  span.style.setProperty('font-size', '22px', 'important');
                });
                item.style.fontSize = '22px';
                item.style.setProperty('font-size', '22px', 'important');
              });
            }
          }
          nextSibling = nextSibling.nextElementSibling;
        }
      }
      
      // container 내부의 모든 ul, li, span 요소
      const allLegendElements = container.querySelectorAll('ul li, ul li span, ul span');
      allLegendElements.forEach(el => {
        if (el.textContent && el.textContent.trim()) {
          el.style.fontSize = '22px';
          el.style.setProperty('font-size', '22px', 'important');
        }
      });
      
      // Chart.js의 legend 플러그인에서 직접 접근
      if (chartInstance.legend && chartInstance.legend.legendBox) {
        const legendBox = chartInstance.legend.legendBox;
        if (legendBox) {
          const legendTexts = legendBox.querySelectorAll('*');
          legendTexts.forEach(el => {
            if (el.textContent && el.textContent.trim()) {
              el.style.fontSize = '22px';
              el.style.setProperty('font-size', '22px', 'important');
            }
          });
        }
      }
      
      // legend가 아직 렌더링되지 않았으면 다시 시도
      const hasLegend = container.querySelector('ul') || (chartInstance.legend && chartInstance.legend.legendBox);
      if (!hasLegend && attempt < 5) {
        setTimeout(() => tryApply(attempt + 1), 200);
      }
    };
    
    tryApply();
  }
  
  // 1. 아르카나 세트 옵션
  if (Object.keys(data.arcana || {}).length > 0) {
    const arcanaContainer = document.createElement('div');
    arcanaContainer.style.cssText = chartContainerStyle;
    arcanaContainer.onmouseenter = function() { this.style.cssText = chartContainerStyle + chartContainerHoverStyle; };
    arcanaContainer.onmouseleave = function() { this.style.cssText = chartContainerStyle; };
    
    const arcanaEntries = Object.entries(data.arcana).sort((a, b) => b[1] - a[1]);
    const arcanaLabels = arcanaEntries.map(([label]) => label);
    const arcanaValues = arcanaEntries.map(([, value]) => value);
    const arcanaTotal = arcanaValues.reduce((a, b) => a + b, 0);
    const arcanaCount = arcanaTotal;
    
    arcanaContainer.innerHTML = `
      <h3 style="${chartTitleStyle}">✨ 아르카나 세트 옵션</h3>
      <p style="${chartSubtitleStyle}">총 ${arcanaCount.toLocaleString()}명</p>
      <div style="${chartWrapperStyle}" class="chart-wrapper">
        <canvas id="arcana-chart"></canvas>
      </div>
    `;
    gridContainer.appendChild(arcanaContainer);
    
    const arcanaCanvas = arcanaContainer.querySelector('#arcana-chart');
    if (!arcanaCanvas) return;
    
    const arcanaCtx = arcanaCanvas.getContext('2d');
    
    const arcanaChart = new Chart(arcanaCtx, {
      type: 'pie',
      data: {
        labels: arcanaLabels,
        datasets: [{
          data: arcanaValues,
          backgroundColor: [
            'rgba(157, 140, 255, 0.9)',
            'rgba(236, 72, 153, 0.9)',
            'rgba(59, 130, 246, 0.9)',
            'rgba(34, 197, 94, 0.9)',
            'rgba(251, 146, 60, 0.9)'
          ],
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 2
        }]
      },
      options: createChartOptions(arcanaTotal, '명', arcanaContainer),
      plugins: [typeof ChartDataLabels !== 'undefined' ? ChartDataLabels : {}]
    });
    
    // legend 폰트 크기 강제 적용
    setTimeout(() => {
      applyLegendFontSize(arcanaContainer, arcanaChart);
    }, 300);
  }
  
  // 2. 메인 무기
  if (Object.keys(data.main_weapon || {}).length > 0) {
    const mainWeaponContainer = document.createElement('div');
    mainWeaponContainer.style.cssText = chartContainerStyle;
    mainWeaponContainer.onmouseenter = function() { this.style.cssText = chartContainerStyle + chartContainerHoverStyle; };
    mainWeaponContainer.onmouseleave = function() { this.style.cssText = chartContainerStyle; };
    
    const mainWeaponEntries = Object.entries(data.main_weapon).sort((a, b) => b[1] - a[1]).slice(0, 10);
    const mainWeaponLabels = mainWeaponEntries.map(([label]) => label);
    const mainWeaponValues = mainWeaponEntries.map(([, value]) => value);
    const mainWeaponTotal = mainWeaponValues.reduce((a, b) => a + b, 0);
    const mainWeaponCount = mainWeaponTotal;
    
    mainWeaponContainer.innerHTML = `
      <h3 style="${chartTitleStyle}">⚔️ 메인 무기</h3>
      <p style="${chartSubtitleStyle}">총 ${mainWeaponCount.toLocaleString()}명</p>
      <div style="${chartWrapperStyle}" class="chart-wrapper">
        <canvas id="main-weapon-chart"></canvas>
      </div>
    `;
    gridContainer.appendChild(mainWeaponContainer);
    
    const mainWeaponCanvas = mainWeaponContainer.querySelector('#main-weapon-chart');
    if (!mainWeaponCanvas) return;
    
    const mainWeaponCtx = mainWeaponCanvas.getContext('2d');
    
    const mainWeaponChart = new Chart(mainWeaponCtx, {
      type: 'pie',
      data: {
        labels: mainWeaponLabels,
        datasets: [{
          data: mainWeaponValues,
          backgroundColor: [
            'rgba(157, 140, 255, 0.9)', 'rgba(236, 72, 153, 0.9)', 'rgba(59, 130, 246, 0.9)',
            'rgba(34, 197, 94, 0.9)', 'rgba(251, 146, 60, 0.9)', 'rgba(168, 85, 247, 0.9)',
            'rgba(14, 165, 233, 0.9)', 'rgba(20, 184, 166, 0.9)', 'rgba(245, 158, 11, 0.9)',
            'rgba(239, 68, 68, 0.9)'
          ],
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 2
        }]
      },
      options: createChartOptions(mainWeaponTotal, '명', mainWeaponContainer),
      plugins: [typeof ChartDataLabels !== 'undefined' ? ChartDataLabels : {}]
    });
    
    setTimeout(() => {
      applyLegendFontSize(mainWeaponContainer, mainWeaponChart);
    }, 300);
  }
  
  // 3. 가더
  if (Object.keys(data.gauntlet || {}).length > 0) {
    const gauntletContainer = document.createElement('div');
    gauntletContainer.style.cssText = chartContainerStyle;
    gauntletContainer.onmouseenter = function() { this.style.cssText = chartContainerStyle + chartContainerHoverStyle; };
    gauntletContainer.onmouseleave = function() { this.style.cssText = chartContainerStyle; };
    
    const gauntletEntries = Object.entries(data.gauntlet).sort((a, b) => b[1] - a[1]).slice(0, 10);
    const gauntletLabels = gauntletEntries.map(([label]) => label);
    const gauntletValues = gauntletEntries.map(([, value]) => value);
    const gauntletTotal = gauntletValues.reduce((a, b) => a + b, 0);
    const gauntletCount = gauntletTotal;
    
    gauntletContainer.innerHTML = `
      <h3 style="${chartTitleStyle}">⚔️ 가더</h3>
      <p style="${chartSubtitleStyle}">총 ${gauntletCount.toLocaleString()}명</p>
      <div style="${chartWrapperStyle}" class="chart-wrapper">
        <canvas id="gauntlet-chart"></canvas>
      </div>
    `;
    gridContainer.appendChild(gauntletContainer);
    
    const gauntletCanvas = gauntletContainer.querySelector('#gauntlet-chart');
    if (!gauntletCanvas) return;
    
    const gauntletCtx = gauntletCanvas.getContext('2d');
    
    const gauntletChart = new Chart(gauntletCtx, {
      type: 'pie',
      data: {
        labels: gauntletLabels,
        datasets: [{
          data: gauntletValues,
          backgroundColor: [
            'rgba(157, 140, 255, 0.9)', 'rgba(236, 72, 153, 0.9)', 'rgba(59, 130, 246, 0.9)',
            'rgba(34, 197, 94, 0.9)', 'rgba(251, 146, 60, 0.9)', 'rgba(168, 85, 247, 0.9)',
            'rgba(14, 165, 233, 0.9)', 'rgba(20, 184, 166, 0.9)', 'rgba(245, 158, 11, 0.9)',
            'rgba(239, 68, 68, 0.9)'
          ],
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 2
        }]
      },
      options: createChartOptions(gauntletTotal, '명', gauntletContainer),
      plugins: [typeof ChartDataLabels !== 'undefined' ? ChartDataLabels : {}]
    });
    
    setTimeout(() => {
      applyLegendFontSize(gauntletContainer, gauntletChart);
    }, 300);
  }
  
  // 4. 방어구
  if (Object.keys(data.armor || {}).length > 0) {
    const armorContainer = document.createElement('div');
    armorContainer.style.cssText = chartContainerStyle;
    armorContainer.onmouseenter = function() { this.style.cssText = chartContainerStyle + chartContainerHoverStyle; };
    armorContainer.onmouseleave = function() { this.style.cssText = chartContainerStyle; };
    
    const armorEntries = Object.entries(data.armor).sort((a, b) => b[1] - a[1]).slice(0, 10);
    const armorLabels = armorEntries.map(([label]) => label);
    const armorValues = armorEntries.map(([, value]) => value);
    const armorTotal = armorValues.reduce((a, b) => a + b, 0);
    const armorCount = armorTotal;
    
    armorContainer.innerHTML = `
      <h3 style="${chartTitleStyle}">🛡️ 방어구</h3>
      <p style="${chartSubtitleStyle}">총 ${armorCount.toLocaleString()}개</p>
      <div style="${chartWrapperStyle}" class="chart-wrapper">
        <canvas id="armor-chart"></canvas>
      </div>
    `;
    gridContainer.appendChild(armorContainer);
    
    const armorCanvas = armorContainer.querySelector('#armor-chart');
    if (!armorCanvas) return;
    
    const armorCtx = armorCanvas.getContext('2d');
    
    const armorChart = new Chart(armorCtx, {
      type: 'pie',
      data: {
        labels: armorLabels,
        datasets: [{
          data: armorValues,
          backgroundColor: [
            'rgba(157, 140, 255, 0.9)', 'rgba(236, 72, 153, 0.9)', 'rgba(59, 130, 246, 0.9)',
            'rgba(34, 197, 94, 0.9)', 'rgba(251, 146, 60, 0.9)', 'rgba(168, 85, 247, 0.9)',
            'rgba(14, 165, 233, 0.9)', 'rgba(20, 184, 166, 0.9)', 'rgba(245, 158, 11, 0.9)',
            'rgba(239, 68, 68, 0.9)'
          ],
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 2
        }]
      },
      options: createChartOptions(armorTotal, '개', armorContainer),
      plugins: [typeof ChartDataLabels !== 'undefined' ? ChartDataLabels : {}]
    });
    
    setTimeout(() => {
      applyLegendFontSize(armorContainer, armorChart);
    }, 300);
  }
  
  // 5. 장신구
  if (Object.keys(data.accessory || {}).length > 0) {
    const accessoryContainer = document.createElement('div');
    accessoryContainer.style.cssText = chartContainerStyle;
    accessoryContainer.onmouseenter = function() { this.style.cssText = chartContainerStyle + chartContainerHoverStyle; };
    accessoryContainer.onmouseleave = function() { this.style.cssText = chartContainerStyle; };
    
    const accessoryEntries = Object.entries(data.accessory).sort((a, b) => b[1] - a[1]).slice(0, 10);
    const accessoryLabels = accessoryEntries.map(([label]) => label);
    const accessoryValues = accessoryEntries.map(([, value]) => value);
    const accessoryTotal = accessoryValues.reduce((a, b) => a + b, 0);
    const accessoryCount = accessoryTotal;
    
    accessoryContainer.innerHTML = `
      <h3 style="${chartTitleStyle}">💍 장신구</h3>
      <p style="${chartSubtitleStyle}">총 ${accessoryCount.toLocaleString()}개</p>
      <div style="${chartWrapperStyle}" class="chart-wrapper">
        <canvas id="accessory-chart"></canvas>
      </div>
    `;
    gridContainer.appendChild(accessoryContainer);
    
    const accessoryCanvas = accessoryContainer.querySelector('#accessory-chart');
    if (!accessoryCanvas) return;
    
    const accessoryCtx = accessoryCanvas.getContext('2d');
    
    const accessoryChart = new Chart(accessoryCtx, {
      type: 'pie',
      data: {
        labels: accessoryLabels,
        datasets: [{
          data: accessoryValues,
          backgroundColor: [
            'rgba(157, 140, 255, 0.9)', 'rgba(236, 72, 153, 0.9)', 'rgba(59, 130, 246, 0.9)',
            'rgba(34, 197, 94, 0.9)', 'rgba(251, 146, 60, 0.9)', 'rgba(168, 85, 247, 0.9)',
            'rgba(14, 165, 233, 0.9)', 'rgba(20, 184, 166, 0.9)', 'rgba(245, 158, 11, 0.9)',
            'rgba(239, 68, 68, 0.9)'
          ],
          borderColor: 'rgba(255, 255, 255, 0.2)',
          borderWidth: 2
        }]
      },
      options: createChartOptions(accessoryTotal, '개', accessoryContainer),
      plugins: [typeof ChartDataLabels !== 'undefined' ? ChartDataLabels : {}]
    });
    
    setTimeout(() => {
      applyLegendFontSize(accessoryContainer, accessoryChart);
    }, 300);
  }
  
  container.appendChild(gridContainer);
  
  // 모든 legend 텍스트 색상 강제 적용 (추가 보장)
  setTimeout(() => {
    const allContainers = gridContainer.querySelectorAll('div[style*="background"]');
    allContainers.forEach(container => {
      const allText = container.querySelectorAll('li, span, div, label, p');
      allText.forEach(el => {
        if (el.textContent && el.textContent.trim() && !el.querySelector('canvas')) {
          el.style.color = '#ffffff';
          el.style.setProperty('color', '#ffffff', 'important');
        }
      });
    });
  }, 500);
}

// 스킬 통계 직업 선택 버튼 설정
function setupSkillStatsClassSelector() {
  const btns = document.querySelectorAll('.skill-stats-class-btn');
  btns.forEach(btn => {
    if (btn.dataset.listenerAttached === 'true') {
      return;
    }
    btn.addEventListener('click', function() {
      btns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      loadSkillStatistics(this.dataset.job);
    });
    btn.dataset.listenerAttached = 'true';
  });
}

// 스킬 통계 데이터 로드
function loadSkillStatistics(job) {
  const container = document.getElementById('skill-stats-container');
  const lastUpdateEl = document.getElementById('skill-stats-last-update');
  if (!container) {
    return;
  }
  
  container.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 3rem; color: var(--text-muted);">데이터를 불러오는 중...</div>';
  if (lastUpdateEl) {
    lastUpdateEl.textContent = '마지막 업데이트: 로딩 중...';
  }
  
  // skill_priorities와 skill_stats를 병렬로 로드
  Promise.all([
    fetch(`/api/stats/skills?job=${encodeURIComponent(job)}`).then(res => res.json()),
    fetch(`/api/skill-priorities?job=${encodeURIComponent(job)}`).then(res => res.json()).catch(() => null)
  ])
    .then(([statsData, prioritiesData]) => {
      if (!statsData.success) {
        container.innerHTML = `<div style="grid-column: 1/-1; text-align: center; color: #ef4444;">${statsData.error || '데이터 로드 실패'}</div>`;
        if (lastUpdateEl) {
          lastUpdateEl.textContent = '마지막 업데이트: -';
        }
        return;
      }
      
      // 마지막 업데이트 날짜 표시
      if (lastUpdateEl && statsData.last_update) {
        lastUpdateEl.textContent = `마지막 업데이트: ${statsData.last_update}`;
      } else if (lastUpdateEl) {
        lastUpdateEl.textContent = '마지막 업데이트: -';
      }
      
      // priority 정보 전달
      const priorities = prioritiesData && prioritiesData.success ? prioritiesData.data : null;
      renderSkillStatistics(statsData.data, statsData.total_rankers, job, priorities);
    })
    .catch(err => {
      container.innerHTML = `<div style="grid-column: 1/-1; text-align: center; color: #ef4444;">오류가 발생했습니다.</div>`;
      if (lastUpdateEl) {
        lastUpdateEl.textContent = '마지막 업데이트: -';
      }
    });
}

// 스킬 통계 렌더링
function renderSkillStatistics(stats, totalRankers, job, priorities = null) {
  const container = document.getElementById('skill-stats-container');
  if (!container) return;
  
  container.innerHTML = '';
  
  const categories = [
    { key: 'active', label: '액티브 스킬' },
    { key: 'passive', label: '패시브 스킬' },
    { key: 'stigma', label: '스티그마' }
  ];
  
  categories.forEach(cat => {
    const skills = stats[cat.key] || [];
    if (skills.length === 0) return; // 데이터 없으면 스킵
    
    // 고+중+저 합이 10명 미만인 스킬 필터링
    let filteredSkills = skills.filter(skill => {
      const totalCount = skill.high_tier_count + skill.mid_tier_count + skill.low_tier_count;
      return totalCount >= 10;
    });
    
    // priority 순으로 정렬
    if (priorities && priorities[cat.key] && priorities[cat.key].length > 0) {
      const priorityMap = {};
      priorities[cat.key].forEach((p, idx) => {
        priorityMap[p.skill_name] = idx;
      });
      filteredSkills.sort((a, b) => {
        const priorityA = priorityMap[a.name] !== undefined ? priorityMap[a.name] : 9999;
        const priorityB = priorityMap[b.name] !== undefined ? priorityMap[b.name] : 9999;
        return priorityA - priorityB;
      });
    }
    
    if (filteredSkills.length === 0) return; // 필터링 후 데이터 없으면 스킵
    
    const col = document.createElement('div');
    col.className = 'skill-stats-column';
    
    col.innerHTML = `
      <div class="skill-stats-col-header">
        <span>${cat.label}</span>
        <span style="font-size: 0.8rem; color: var(--text-muted);">${filteredSkills.length}개</span>
      </div>
      <div class="skill-stats-list">
        ${filteredSkills.map((skill, index) => {
          // 비율 계산 (전체 랭커 수 대비)
          const highPct = (skill.high_tier_count / totalRankers) * 100;
          const midPct = (skill.mid_tier_count / totalRankers) * 100;
          const lowPct = (skill.low_tier_count / totalRankers) * 100;
          
          // 표시할 채용률 (액티브/패시브는 20+, 스티그마는 15+ 기준)
          let displayRate;
          if (cat.key === 'stigma') {
            // 스티그마: 15레벨 이상 (High)
            displayRate = highPct;
          } else {
            // 액티브/패시브: 20레벨 이상 (High)
            displayRate = highPct;
          }
          
          const iconUrl = (skill.icon_url && skill.icon_url.trim()) ? skill.icon_url : SKILL_ICON_PLACEHOLDER;
          const itemId = `skill-stats-item-${cat.key}-${index}`;

          return `
          <div class="skill-stats-item" id="${itemId}" data-skill-name="${skill.name}" data-skill-type="${cat.key}">
            <div class="skill-stats-meta">
              <img src="${iconUrl}" alt="${skill.name}" class="skill-stats-icon" onerror="this.onerror=null;this.src='${SKILL_ICON_PLACEHOLDER}';">
              <div class="skill-stats-header">
                <span class="skill-stats-name">${skill.name} </span>
                <span class="skill-stats-rate"> 고투자율: ${displayRate.toFixed(1)}%</span>
              </div>
            </div>
            <div class="skill-stats-bars">
              <div class="skill-stats-bar-segment skill-stats-bar-high" style="width: ${highPct}%"></div>
              <div class="skill-stats-bar-segment skill-stats-bar-mid" style="width: ${midPct}%"></div>
              <div class="skill-stats-bar-segment skill-stats-bar-low" style="width: ${lowPct}%"></div>
            </div>
            <div class="skill-stats-details">
              <span>고 ${skill.high_tier_count}명</span>
              <span>중 ${skill.mid_tier_count}명</span>
              <span>저 ${skill.low_tier_count}명</span>
            </div>
          </div>
          `;
        }).join('')}
      </div>
    `;
    container.appendChild(col);
    
    // 각 스킬 아이템에 툴팁 추가
    if (job) {
      filteredSkills.forEach((skill, index) => {
        const itemId = `skill-stats-item-${cat.key}-${index}`;
        const skillItem = document.getElementById(itemId);
        if (skillItem) {
          skillItem.style.position = 'relative';
          const skillType = cat.key === 'active' ? 'active' : (cat.key === 'passive' ? 'passive' : 'stigma');
          const tooltip = createSkillTooltip(skill.name, job, skillType, null);
          if (tooltip) {
            skillItem.appendChild(tooltip);
          }
        }
      });
    }
  });
}

// 통계 로드 함수
async function loadStatistics() {
  const jobContainer = document.getElementById('job-statistics-container');
  if (!jobContainer) return;

  try {
    const params = new URLSearchParams();
    if (typeof statisticsState.range.min === 'number') {
      params.append('min_power', statisticsState.range.min);
    }
    if (typeof statisticsState.range.max === 'number') {
      params.append('max_power', statisticsState.range.max);
    }
    
    const cacheKey = params.toString();
    
    // 메모리 캐시 확인
    const now = Date.now();
    if (statisticsDataCache && statisticsDataCacheTime && 
        statisticsDataCache.cacheKey === cacheKey &&
        (now - statisticsDataCacheTime) < STATISTICS_CACHE_DURATION) {
      // 캐시된 데이터 사용
      const result = statisticsDataCache.data;
      if (result.success && result.data) {
        // 업데이트 시간 표시
        const updateInfoEl = document.getElementById('job-statistics-update-info');
        if (updateInfoEl && result.data.last_updated) {
          updateInfoEl.textContent = `최근 업데이트: ${result.data.last_updated}`;
        } else if (updateInfoEl) {
          updateInfoEl.textContent = '';
        }
        
        applyStatisticsMeta(result.data);
        displayJobStatistics(result.data.job_stats, result.data.filtered_count, jobContainer);
      }
      return;
    }


    jobContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>';

    const response = await fetch(`/api/statistics?${params.toString()}`, {
      cache: 'default', // 브라우저 캐시 활용
      headers: {
        'Cache-Control': 'max-age=3600' // 1시간 캐시
      }
    });
    const result = await response.json();

    if (result.success && result.data) {
      // 메모리 캐시에 저장
      statisticsDataCache = {
        cacheKey: cacheKey,
        data: result
      };
      statisticsDataCacheTime = Date.now();
      
      // 업데이트 시간 표시
      const updateInfoEl = document.getElementById('job-statistics-update-info');
      if (updateInfoEl && result.data.last_updated) {
        updateInfoEl.textContent = `최근 업데이트: ${result.data.last_updated}`;
      } else if (updateInfoEl) {
        updateInfoEl.textContent = '';
      }
      
      applyStatisticsMeta(result.data);
      displayJobStatistics(result.data.job_stats, result.data.filtered_count, jobContainer);
    } else {
      jobContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">통계 데이터를 불러올 수 없습니다.</p>';
    }
  } catch (error) {
    jobContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">통계 데이터를 불러오는 중 오류가 발생했습니다.</p>';
  }
}

function applyStatisticsMeta(data) {
  const bounds = data.bounds || {};
  statisticsState.bounds = {
    min: typeof bounds.min === 'number' ? bounds.min : 0,
    max: typeof bounds.max === 'number' ? bounds.max : 0
  };

  if (!statisticsState.initialized) {
    const fallbackMax = statisticsState.bounds.max || 4999;
    statisticsState.range.min = Math.max(0, statisticsState.bounds.min);
    statisticsState.range.max = Math.min(fallbackMax, 4999);
    if (statisticsState.range.max <= statisticsState.range.min) {
      statisticsState.range.max = statisticsState.range.min + STAT_MIN_GAP;
    }
    statisticsState.initialized = true;
  }

  if (data.range) {
    if (typeof data.range.min === 'number') {
      statisticsState.range.min = data.range.min;
    }
    if (typeof data.range.max === 'number') {
      statisticsState.range.max = data.range.max;
    }
  }

  statisticsState.filteredCount = data.filtered_count || 0;
  enforceRangeWithinBounds();
  syncRangeUI();
  updateRangeSummary(statisticsState.filteredCount);
}

// 직업 통계 표시 함수
function displayJobStatistics(jobStats, filteredCount, container) {
  if (!jobStats || jobStats.length === 0 || !filteredCount) {
    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">선택된 전투력 구간의 데이터가 없습니다.</p>';
    return;
  }
  
  const sortedStats = [...jobStats].sort((a, b) => b.count - a.count);
  const maxPercentage = sortedStats.length > 0 ? sortedStats[0].percentage : 100;
  
  let html = '<div style="display: grid; gap: 0.75rem;">';
  
  sortedStats.forEach((stat, index) => {
    const percentage = stat.percentage || 0;
    const gaugeWidth = index === 0 ? 100 : (maxPercentage > 0 ? (percentage / maxPercentage * 100) : 0);
    
    html += `
      <div style="background: var(--card-bg); border: 1px solid var(--card-border); border-radius: 12px; padding: 1rem; display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: space-between; align-items: center;">
        <div style="flex: 1; min-width: 180px;">
          <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.25rem;">${stat.job}</div>
          <div style="font-size: 0.85rem; color: var(--text-muted);">${stat.count.toLocaleString()}명 (${percentage}%)</div>
        </div>
        <div class="statistics-gauge-bg" style="width: 200px; height: 8px; border-radius: 4px; overflow: hidden;">
          <div class="statistics-gauge-bar" style="width: ${gaugeWidth}%; height: 100%; transition: width 0.3s ease; background: linear-gradient(90deg, rgba(157, 140, 255, 0.8), rgba(236, 72, 153, 0.8)) !important; background-image: linear-gradient(90deg, rgba(157, 140, 255, 0.8), rgba(236, 72, 153, 0.8)) !important;"></div>
        </div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
}

function initializeStatisticsControls() {
  const controls = statisticsControls;
  if (!controls.minInput || !controls.maxInput || !controls.minRange || !controls.maxRange || !controls.track || !controls.applyButton) {
    return;
  }

  controls.minInput.addEventListener('input', (e) => handleNumericInput('min', e.target.value));
  controls.maxInput.addEventListener('input', (e) => handleNumericInput('max', e.target.value));
  controls.minRange.addEventListener('input', (e) => handleRangeInput('min', e.target.value));
  controls.maxRange.addEventListener('input', (e) => handleRangeInput('max', e.target.value));
  controls.applyButton.addEventListener('click', () => loadStatistics());

  syncRangeUI();
}

function handleNumericInput(type, rawValue) {
  const value = parseInt(rawValue, 10);
  if (Number.isNaN(value)) return;

  // 스냅 포인트로 조정
  const snappedValue = snapToPowerPoint(value);

  if (type === 'min') {
    statisticsState.range.min = snappedValue;
  } else {
    statisticsState.range.max = snappedValue;
  }
  enforceRangeWithinBounds();
  syncRangeUI();
}

function handleRangeInput(type, rawValue) {
  const value = parseInt(rawValue, 10);
  if (Number.isNaN(value)) return;

  // 스냅 포인트로 조정
  const snappedValue = snapToPowerPoint(value);

  if (type === 'min') {
    statisticsState.range.min = snappedValue;
  } else {
    statisticsState.range.max = snappedValue;
  }
  enforceRangeWithinBounds();
  syncRangeUI();
}

function enforceRangeWithinBounds() {
  const bounds = statisticsState.bounds || { min: 0, max: 0 };
  let minBound = typeof bounds.min === 'number' ? bounds.min : 0;
  let maxBound = typeof bounds.max === 'number' ? bounds.max : minBound + STAT_MIN_GAP;

  if (maxBound <= minBound) {
    maxBound = minBound + STAT_MIN_GAP;
  }

  let minValue = typeof statisticsState.range.min === 'number' ? statisticsState.range.min : minBound;
  let maxValue = typeof statisticsState.range.max === 'number' ? statisticsState.range.max : maxBound;

  minValue = Math.max(minValue, minBound);
  maxValue = Math.min(maxValue, maxBound);

  if (maxValue - minValue < STAT_MIN_GAP) {
    maxValue = Math.min(maxBound, minValue + STAT_MIN_GAP);
    if (maxValue > maxBound) {
      maxValue = maxBound;
      minValue = Math.max(minBound, maxValue - STAT_MIN_GAP);
    }
  }

  statisticsState.range.min = minValue;
  statisticsState.range.max = maxValue;
}

function syncRangeUI() {
  const controls = statisticsControls;
  enforceRangeWithinBounds();
  applyBoundsToInputs();

  if (controls.minInput) controls.minInput.value = statisticsState.range.min;
  if (controls.maxInput) controls.maxInput.value = statisticsState.range.max;
  if (controls.minRange) controls.minRange.value = statisticsState.range.min;
  if (controls.maxRange) controls.maxRange.value = statisticsState.range.max;

  updateRangeTrack();
  updateRangeSummary(statisticsState.filteredCount);
}

function applyBoundsToInputs() {
  const controls = statisticsControls;
  const bounds = statisticsState.bounds;
  if (!bounds) return;

  const minBound = typeof bounds.min === 'number' ? bounds.min : 0;
  const maxBound = typeof bounds.max === 'number' ? bounds.max : 0;

  if (controls.minInput) {
    controls.minInput.min = minBound;
    controls.minInput.max = maxBound;
  }
  if (controls.maxInput) {
    controls.maxInput.min = minBound;
    controls.maxInput.max = maxBound;
  }
  if (controls.minRange) {
    controls.minRange.min = minBound;
    controls.minRange.max = maxBound;
  }
  if (controls.maxRange) {
    controls.maxRange.min = minBound;
    controls.maxRange.max = maxBound;
  }
}

function updateRangeTrack() {
  const track = statisticsControls.track;
  const bounds = statisticsState.bounds;
  if (!track || !bounds) return;

  const minBound = typeof bounds.min === 'number' ? bounds.min : 0;
  const maxBound = typeof bounds.max === 'number' ? bounds.max : minBound + STAT_MIN_GAP;
  const span = maxBound - minBound || 1;

  const startPercent = ((statisticsState.range.min - minBound) / span) * 100;
  const endPercent = ((statisticsState.range.max - minBound) / span) * 100;

  const gradientValue = `linear-gradient(90deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.15) ${startPercent}%, rgba(157, 140, 255, 0.9) ${startPercent}%, rgba(236, 72, 153, 0.9) ${endPercent}%, rgba(255,255,255,0.15) ${endPercent}%, rgba(255,255,255,0.15) 100%)`;
  track.style.setProperty('background', gradientValue, 'important');
  track.style.setProperty('background-image', gradientValue, 'important');
}

function updateRangeSummary(count) {
  if (!statisticsControls.summary) return;
  const minLabel = formatPowerValue(statisticsState.range.min);
  const maxLabel = formatPowerValue(statisticsState.range.max);
  const countLabel = count ? `${count.toLocaleString()}명 기준` : '데이터 없음';
  statisticsControls.summary.textContent = `${minLabel} ~ ${maxLabel} 전투력 · ${countLabel}`;
}

function formatPowerValue(value) {
  if (value === null || value === undefined) return '0';
  return Number(value).toLocaleString();
}

// ====== 타이머 카드 ======
const SHUGO_INTERVAL_MINUTES = [15, 45];
const RIFT_HOURS = [2, 5, 8, 11, 14, 17, 20, 23];
// 중복 선언 방지
if (typeof countdownTimer === 'undefined') {
  var countdownTimer = null;
}

function startEventCountdowns() {
  updateEventCountdowns();
  if (countdownTimer) {
    clearInterval(countdownTimer);
    countdownTimer = null;
  }
  countdownTimer = setInterval(updateEventCountdowns, 1000);
}

// 타이머 정리 함수
function cleanupEventCountdowns() {
  if (countdownTimer) {
    clearInterval(countdownTimer);
    countdownTimer = null;
  }
}

function updateEventCountdowns() {
  const now = new Date();
  const shugoEl = document.getElementById('shugo-countdown');
  const riftEl = document.getElementById('rift-countdown');

  if (shugoEl) {
    const nextShugo = calculateNextShugo(now);
    const shugoDiffMs = nextShugo - now;
    const shugoRemainingSeconds = Math.max(0, Math.floor(shugoDiffMs / 1000));
    
    shugoEl.textContent = formatCountdown(shugoDiffMs);
    
    // 3분(180초) 남았을 때부터 반짝거리기
    if (shugoRemainingSeconds <= 180) {
      shugoEl.classList.add('countdown-blink');
    } else {
      shugoEl.classList.remove('countdown-blink');
    }
  }

  if (riftEl) {
    const nextRift = calculateNextRift(now);
    const riftDiffMs = nextRift - now;
    const riftRemainingSeconds = Math.max(0, Math.floor(riftDiffMs / 1000));
    
    riftEl.textContent = formatCountdown(riftDiffMs);
    
    // 10분(600초) 남았을 때부터 반짝거리기
    if (riftRemainingSeconds <= 600) {
      riftEl.classList.add('countdown-blink');
    } else {
      riftEl.classList.remove('countdown-blink');
    }
  }
}

function calculateNextShugo(now) {
  const next = new Date(now);
  next.setSeconds(0, 0);
  const currentMinutes = now.getMinutes();

  if (currentMinutes < SHUGO_INTERVAL_MINUTES[0]) {
    next.setMinutes(SHUGO_INTERVAL_MINUTES[0]);
  } else if (currentMinutes < SHUGO_INTERVAL_MINUTES[1]) {
    next.setMinutes(SHUGO_INTERVAL_MINUTES[1]);
  } else {
    next.setHours(next.getHours() + 1);
    next.setMinutes(SHUGO_INTERVAL_MINUTES[0]);
  }
  return next;
}

function calculateNextRift(now) {
  for (const hour of RIFT_HOURS) {
    const candidate = new Date(now);
    candidate.setHours(hour, 0, 0, 0);
    if (candidate > now) {
      return candidate;
    }
  }
  const tomorrow = new Date(now);
  tomorrow.setDate(now.getDate() + 1);
  tomorrow.setHours(RIFT_HOURS[0], 0, 0, 0);
  return tomorrow;
}

function formatCountdown(diffMs) {
  let totalSeconds = Math.max(0, Math.floor(diffMs / 1000));
  const hours = Math.floor(totalSeconds / 3600);
  totalSeconds %= 3600;
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;

  const pad = (num) => String(num).padStart(2, '0');
  if (hours > 0) {
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
  }
  return `${pad(minutes)}:${pad(seconds)}`;
}

// ★ "x시간 전" 형식으로 시간 표시하는 유틸리티 함수
function formatTimeAgo(isoDateString) {
  if (!isoDateString) {
    console.log('[formatTimeAgo] isoDateString이 없음:', isoDateString);
    return '';
  }
  
  try {
    // DB에 저장된 시간은 UTC이므로, 'Z' 또는 '+00:00'을 붙여서 UTC로 파싱
    let dateStr = isoDateString;
    if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('-', 10)) {
      dateStr = dateStr + 'Z'; // UTC로 명시
    }
    const date = new Date(dateStr);
    
    // 현재 시간 (브라우저 로컬 시간 = 한국 시간)
    const now = new Date();
    const diffMs = now - date;
    const diffSeconds = Math.floor(diffMs / 1000);
    const diffMinutes = Math.floor(diffSeconds / 60);
    const diffHours = Math.floor(diffMinutes / 60);
    const diffDays = Math.floor(diffHours / 24);
    
    let result = '';
    if (diffDays > 30) {
      result = `${Math.floor(diffDays / 30)}달 전`;
    } else if (diffDays > 0) {
      result = `${diffDays}일 전`;
    } else if (diffHours > 0) {
      result = `${diffHours}시간 전`;
    } else if (diffMinutes > 0) {
      result = `${diffMinutes}분 전`;
    } else {
      result = '방금 전';
    }
    
    return result;
  } catch (e) {
    console.error('[formatTimeAgo] 에러:', e);
    return '';
  }
}

// 전체 서버 검색 결과 표시 함수
function displayAllServersResults(results, race, searchKeyword) {
  const container = document.getElementById('character-all-servers-result');
  const listContainer = document.getElementById('all-servers-result-list');
  
  if (!container || !listContainer) return;
  
  // 검색어와 정확히 일치하는지 확인하기 위한 함수
  const isExactMatch = (nickname, keyword) => {
    return nickname.toLowerCase() === keyword.toLowerCase();
  };
  
  // 서버 순서 정의 (천족/마족 순서대로)
  const serverOrder = ['시엘', '이스라펠', '네자칸', '지켈', '바이젤', '트리니엘', '카이시넬', '루미엘', '유스티엘', '마르쿠탄', '아리엘', '아스펠', '프레기온', '에레슈키갈', '메스람타에다', '브리트라', '히타니에', '네몬', '나니아', '하달', '타하바타', '루드라', '루터스', '울고른', '페르노스', '무닌', '다미누', '오다르', '카사카', '젠카카', '바바룬', '크로메데', '챈가룽', '콰이링', '코치룽', '바바룽', '이슈타르', '파프니르', '티아마트', '인드나흐', '포에타', '이스할겐'];
  
  // 검색 결과 정렬
  const sortedResults = [...results].sort((a, b) => {
    const nicknameA = a.nickname || '';
    const nicknameB = b.nickname || '';
    const keyword = searchKeyword || '';
    
    // 1. 정확히 일치하는 닉네임 우선
    const exactMatchA = isExactMatch(nicknameA, keyword);
    const exactMatchB = isExactMatch(nicknameB, keyword);
    
    if (exactMatchA && !exactMatchB) return -1;
    if (!exactMatchA && exactMatchB) return 1;
    
    // 2. 아툴점수 높은 순 (아툴점수가 있는 경우)
    const combatScoreA = parseFloat(a.combat_score || 0);
    const combatScoreB = parseFloat(b.combat_score || 0);
    
    if (combatScoreA !== combatScoreB) {
      return combatScoreB - combatScoreA;
    }
    
    // 3. 아툴점수가 같으면 전투력 높은 순
    const combatPowerA = parseInt(a.combat_power || 0);
    const combatPowerB = parseInt(b.combat_power || 0);
    
    if (combatPowerA !== combatPowerB) {
      return combatPowerB - combatPowerA;
    }
    
    // 4. 전투력도 같으면 레벨 내림차순
    const levelA = parseInt(a.level || 0);
    const levelB = parseInt(b.level || 0);
    
    if (levelA !== levelB) {
      return levelB - levelA;
    }
    
    // 5. 레벨도 같으면 서버 순서대로
    const serverA = a.server_name || a.server || '';
    const serverB = b.server_name || b.server || '';
    const indexA = serverOrder.indexOf(serverA);
    const indexB = serverOrder.indexOf(serverB);
    
    if (indexA === -1 && indexB === -1) {
      return serverA.localeCompare(serverB);
    }
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    
    return indexA - indexB;
  });
  
  // 최대 12개만 표시
  const displayResults = sortedResults.slice(0, 12);
  
  
  let html = '';
  displayResults.forEach((result, index) => {
    const nickname = result.nickname || '';
    const serverName = result.server_name || result.server || '';
    const level = result.level || 0;
    const avatarUrl = result.avatar_url || result.image_url || '';
    const serverId = result.server_id || '';
    // race가 빈 문자열이면 result에서 race 정보 가져오기
    let raceName = '';
    if (race === '1') {
      raceName = '천족';
    } else if (race === '2') {
      raceName = '마족';
    } else {
      // result에서 race 정보 가져오기
      raceName = result.race || '';
    }
    // race 값도 result에서 가져오기 (카드 클릭 시 사용)
    const resultRace = result.race === '천족' ? '1' : (result.race === '마족' ? '2' : race);
    
    // 캐릭터 검색 URL 생성 (쿼리 파라미터 형식 사용)
    const characterUrl = `/?nickname=${encodeURIComponent(nickname)}&race=${resultRace}&server=${serverId}`;
    const href = characterUrl;
    
    html += `
      <a class="character-search-card" href="${href}" data-server-id="${serverId}" data-nickname="${nickname}" data-race="${resultRace}" style="
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 10px;
        padding: 0.6rem;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        display: flex;
        flex-direction: row;
        gap: 0.6rem;
        align-items: stretch;
        min-width: 0;
        overflow: hidden;
        text-decoration: none;
        color: inherit;
      " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(157, 140, 255, 0.25)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">
        ${avatarUrl ? `<img src="${avatarUrl}" alt="${nickname}" style="width: 60px; height: 90px; object-fit: cover; border-radius: 8px; border: 1px solid rgba(157, 140, 255, 0.4); flex-shrink: 0;">` : '<div style="width: 60px; height: 90px; background: linear-gradient(135deg, rgba(157, 140, 255, 0.15), rgba(157, 140, 255, 0.05)); border-radius: 8px; display: flex; align-items: center; justify-content: center; color: var(--text-muted); font-size: 0.65rem; flex-shrink: 0; text-align: center; line-height: 1.2; border: 1px solid rgba(157, 140, 255, 0.2);">이미지<br>없음</div>'}
        <div style="flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 0.05rem; overflow: hidden; justify-content: center;">
          <div style="font-weight: 600; font-size: 0.85rem; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${nickname}</div>
          <div style="font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
            <span style="color: ${raceName === '천족' ? '#5eb3f6' : '#ff5757'}; font-weight: 600;">${serverName}</span>
          </div>
          ${result.combat_power ? `<div style="font-size: 0.68rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><span style="color: #ff9d4e; font-weight: 600;">전투력</span> <span style="color: #ffd700;">${result.combat_power.toLocaleString()}</span></div>` : ''}
          ${result.combat_score ? `<div style="font-size: 0.68rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><span style="color: #4ade80; font-weight: 600;">아툴점수</span> <span style="color: #6ee7b7;">${Math.round(result.combat_score).toLocaleString()}</span></div>` : ''}
          ${result.updated_at ? `<div style="font-size: 0.58rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #9ca3af; margin-top: 0.15rem;">🕐 ${formatTimeAgo(result.updated_at)}</div>` : ''}
        </div>
      </a>
    `;
  });
  
  listContainer.innerHTML = html;
  container.style.display = 'block';
  
  // 결과 표시 완료 후 로딩 오버레이 숨김
  setTimeout(() => {
    const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
    if (loadingOverlay) {
      loadingOverlay.style.display = 'none';
    }
  }, 200); // 카드 렌더링 완료 대기
  
  // 카드 클릭 이벤트 리스너 추가 (URL로 이동하도록 허용)
  listContainer.querySelectorAll('.character-search-card').forEach(card => {
    card.addEventListener('click', function(e) {
      // 마우스 휠 클릭(중간 클릭)이나 Ctrl+클릭, Shift+클릭(새 탭/새 창)은 기본 동작 허용
      if (e.button === 1 || e.ctrlKey || e.metaKey || e.shiftKey) {
        return; // 기본 동작 허용 (새 탭으로 열기)
      }
      
      // 일반 클릭은 preventDefault하고 직접 검색 수행
      e.preventDefault();
      
      const nickname = this.getAttribute('data-nickname');
      const race = this.getAttribute('data-race');
      const serverId = this.getAttribute('data-server-id');
      
      if (nickname && race && serverId) {
        // 로딩 표시를 먼저 설정
        document.getElementById('character-result').style.display = 'none';
        document.getElementById('character-all-servers-result').style.display = 'none';
        document.getElementById('character-loading').style.display = 'block';
        const cardLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
        if (cardLoadingOverlay) {
          cardLoadingOverlay.style.display = 'flex';
        }
        
        // 캐릭터 검색 탭으로 이동 (이미 캐릭터 탭이지만 명시적으로 설정)
        const characterTab = document.getElementById('tab-character');
        if (characterTab) {
          characterTab.checked = true;
          characterTab.dispatchEvent(new Event('change'));
          updateSidebarVisibility();
          
          // 종족 버튼 업데이트
          if (race) {
            updateRaceSelection(race, true);
          }
          
          // 검색 폼에 값 설정
          const serverSelect = document.getElementById('server-select');
          const keywordInput = document.getElementById('character-keyword');
          
          // 서버 선택이 활성화될 때까지 대기
          setTimeout(() => {
            if (serverSelect) {
              serverSelect.value = serverId;
              if (keywordInput) keywordInput.value = nickname;
              
              // 로딩 표시 유지
              document.getElementById('character-loading').style.display = 'block';
              const cardLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
              if (cardLoadingOverlay2) {
                cardLoadingOverlay2.style.display = 'flex';
              }
              
              // 검색 실행
              performSearch();
            }
          }, 300);
        }
      }
    });
  });
}

// 전체 검색 함수 (천족 + 마족 모두 검색)
function performSearchAllRaces(keyword, serverId) {
  // ★ 서버가 선택된 경우: 종족을 자동 감지하여 바로 상세 검색으로 이동
  if (serverId && serverId !== 'all' && serverId !== '') {
    const selectedServerId = serverId; // 서버 ID 기억
    
    // 로딩 표시
    document.getElementById('character-loading').style.display = 'block';
    const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
    if (loadingOverlay) {
      loadingOverlay.style.display = 'flex';
    }
    document.getElementById('search-button').disabled = true;
    
    // 먼저 천족(race=1)으로 검색 시도
    fetch('/api/character/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ race: 1, server_id: parseInt(serverId), keyword: keyword })
    })
    .then(r => r.json())
    .then(data => {
      if (data.success && data.data && data.data.nickname) {
        // 천족에서 찾음 - 종족 버튼을 천족으로 설정
        document.getElementById('character-loading').style.display = 'none';
        document.getElementById('search-button').disabled = false;
        if (loadingOverlay) loadingOverlay.style.display = 'none';
        
        updateRaceSelection('1', true);
        // 서버 ID 복원 후 performSearch 재호출
        setTimeout(() => {
          document.getElementById('server-select').value = selectedServerId;
          performSearch();
        }, 50);
      } else {
        // 천족에서 못 찾음 - 마족(race=2)으로 검색 시도
        fetch('/api/character/search', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ race: 2, server_id: parseInt(serverId), keyword: keyword })
        })
        .then(r => r.json())
        .then(data2 => {
          document.getElementById('character-loading').style.display = 'none';
          document.getElementById('search-button').disabled = false;
          if (loadingOverlay) loadingOverlay.style.display = 'none';
          
          if (data2.success && data2.data && data2.data.nickname) {
            // 마족에서 찾음
            updateRaceSelection('2', true);
            // 서버 ID 복원 후 performSearch 재호출
            setTimeout(() => {
              document.getElementById('server-select').value = selectedServerId;
              performSearch();
            }, 50);
          } else {
            // 둘 다 못 찾음
            alert('검색 결과가 없습니다. 닉네임을 확인해주세요.');
          }
        })
        .catch(err => {
          document.getElementById('character-loading').style.display = 'none';
          document.getElementById('search-button').disabled = false;
          if (loadingOverlay) loadingOverlay.style.display = 'none';
          alert('검색 중 오류가 발생했습니다.');
        });
      }
    })
    .catch(err => {
      document.getElementById('character-loading').style.display = 'none';
      document.getElementById('search-button').disabled = false;
      if (loadingOverlay) loadingOverlay.style.display = 'none';
      alert('검색 중 오류가 발생했습니다.');
    });
    return;
  }
  
  // 전역 변수 초기화
  window.attackPowerResult = null;
  window.combatSpeedResult = null;
  window.damageAmplificationResult = null;
  window.skillDamageResult = null;
  window.cooldownReductionResult = null;
  window.daevanionData = null;
  window.currentEquipment = null;
  window.currentAccessories = null;
  window.currentStatData = null;
  window.currentSkills = null;
  window.currentStigmas = null;
  window.currentTitles = null;
  window.cachedCombatScore = undefined;
  window.isCacheMiss = false;
  window.logCharacterInfoCalled = false;
  // ★ 추가: 더 많은 전역 변수 초기화 (이전 캐릭터 데이터 잔류 방지)
  window.perfectResult = null;
  window.stunHitResult = null;
  window.multiHitResult = null;
  window.criticalHitResult = null;
  window.weaponMinAttack = 0;
  window.weaponMaxAttack = 0;
  window.currentCombatScoreMax = null;
  window.currentCombatPower = null;
  
  // 검색 요청 ID 생성 (동시 검색 시 데이터 충돌 방지)
  window.currentSearchId = Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  
  // UI 상태 변경
  document.getElementById('character-result').style.display = 'none';
  document.getElementById('character-all-servers-result').style.display = 'none';
  
  // 로딩 표시
  document.getElementById('character-loading').style.display = 'block';
  const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
  if (loadingOverlay) {
    loadingOverlay.style.display = 'flex';
  }
  document.getElementById('search-button').disabled = true;
  
  // 전체 서버 검색: 천족과 마족 모두 검색
  Promise.all([
    fetch('/api/character/search-all-servers', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ race: 1, keyword: keyword })
    }).then(r => r.json()),
    fetch('/api/character/search-all-servers', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ race: 2, keyword: keyword })
    }).then(r => r.json())
  ])
  .then(([elyosData, asmodianData]) => {
    document.getElementById('character-loading').style.display = 'none';
    document.getElementById('search-button').disabled = false;
    
    // 결과 합치기
    let allResults = [];
    if (elyosData.success && elyosData.data) {
      allResults = allResults.concat(elyosData.data);
    }
    if (asmodianData.success && asmodianData.data) {
      allResults = allResults.concat(asmodianData.data);
    }
    
    if (allResults.length === 0) {
      // 검색 결과가 없을 때만 로딩 오버레이 숨김
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
      alert('검색 결과가 없습니다.');
      return;
    }
    
    // 결과 표시 (정렬은 displayAllServersResults에서 처리)
    displayAllServersResults(allResults, '', keyword);
    
    // 결과 표시 완료 후 로딩 오버레이 숨김
    setTimeout(() => {
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
    }, 100);
  })
  .catch(error => {
    document.getElementById('character-loading').style.display = 'none';
    const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
    if (loadingOverlay) {
      loadingOverlay.style.display = 'none';
    }
    document.getElementById('search-button').disabled = false;
    alert('검색 중 오류가 발생했습니다.');
    console.error('검색 오류:', error);
  });
}

// 검색 버튼 클릭 이벤트
document.getElementById('search-button').addEventListener('click', function() {
  performSearch();
});

// 엔터키로 검색
document.getElementById('character-keyword').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    performSearch();
  }
});

function performSearch() {
  // 종족 버튼에서 선택된 값 가져오기
  const activeRaceButton = document.querySelector('.race-button.active');
  const race = activeRaceButton ? activeRaceButton.getAttribute('data-race') : '';
  const serverId = document.getElementById('server-select').value;
  const keyword = document.getElementById('character-keyword').value.trim();
  
  // 유효성 검사 - 검색어만 필수
  if (!keyword) {
    alert('캐릭터 닉네임을 입력해주세요.');
    return;
  }
  
  // 전체 검색인 경우 (race가 빈 문자열)
  if (!race) {
    performSearchAllRaces(keyword, serverId);
    return;
  }
  
  // 전역 변수 초기화 (이전 캐릭터 데이터가 남지 않도록)
  window.attackPowerResult = null;
  window.combatSpeedResult = null;
  window.damageAmplificationResult = null;
  window.skillDamageResult = null;
  window.cooldownReductionResult = null;
  window.daevanionData = null;
  window.currentEquipment = null;
  window.currentAccessories = null;
  window.currentStatData = null;
  window.currentSkills = null;
  window.currentStigmas = null;
  window.currentTitles = null;
  window.cachedCombatScore = undefined;
  window.isCacheMiss = false;
  window.logCharacterInfoCalled = false;
  // ★ 추가: 더 많은 전역 변수 초기화 (이전 캐릭터 데이터 잔류 방지)
  window.perfectResult = null;
  window.stunHitResult = null;
  window.multiHitResult = null;
  window.criticalHitResult = null;
  window.weaponMinAttack = 0;
  window.weaponMaxAttack = 0;
  window.currentCombatScoreMax = null;
  window.currentCombatPower = null;
  
  // 검색 요청 ID 생성 (동시 검색 시 데이터 충돌 방지)
  window.currentSearchId = Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  
  // UI 상태 변경
  document.getElementById('character-result').style.display = 'none';
  document.getElementById('character-all-servers-result').style.display = 'none';
  
  // 로딩 중에는 스트리머 섹션 숨김
  const streamerSection = document.getElementById('streamer-section');
  const streamerTitle = document.getElementById('streamer-title');
  if (streamerSection) {
    streamerSection.style.display = 'none';
  }
  if (streamerTitle) {
    streamerTitle.style.display = 'none';
  }
  document.getElementById('character-error').style.display = 'none';
  document.getElementById('character-loading').style.display = 'block';
  
  // 전체 화면 로딩 오버레이 표시
  const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
  if (loadingOverlay) {
    loadingOverlay.style.display = 'flex';
  }
  
  // [추가됨] 검색을 시작하면 숨겨져 있던 대시보드를 보이게 설정
  const mainDashboard = document.getElementById('main-dashboard');
  if (mainDashboard) {
      mainDashboard.style.display = 'block';
  }
  
  document.getElementById('search-button').disabled = true;
  updateCompanionBadges(null, null);
  
  // 전체 서버 검색인 경우
  if (serverId === 'all' || !serverId) {
    fetch('/api/character/search-all-servers', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        race: parseInt(race),
        keyword: keyword
      })
    })
    .then(response => response.json())
    .then(data => {
      document.getElementById('character-loading').style.display = 'none';
      document.getElementById('search-button').disabled = false;
      
      if (data.success && data.data && data.data.length > 0) {
        // 전체 서버 검색 결과 카드 표시
        displayAllServersResults(data.data, race, keyword);
        
        // 결과 표시 완료 후 로딩 오버레이 숨김
        setTimeout(() => {
          const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
          if (loadingOverlay) {
            loadingOverlay.style.display = 'none';
          }
        }, 100);
      } else {
        // 검색 결과가 없을 때만 로딩 오버레이 숨김
        const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
        alert('검색 결과가 없습니다.');
      }
    })
    .catch(error => {
      document.getElementById('character-loading').style.display = 'none';
      // 로딩 오버레이 숨김
      const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
      document.getElementById('search-button').disabled = false;
      alert('검색 중 오류가 발생했습니다.');
      
      // 오류 발생 시에도 즐겨찾기 카드 다시 활성화
      if (window.isFavoriteSearching) {
        window.isFavoriteSearching = false;
        // 쿨다운은 별도로 관리 (4초 후 해제)
        enableFavoriteCardsAfterCooldown();
      }
    });
    return;
  }
  
  // 특정 서버 검색인 경우 (기존 로직)
  // API 호출
  const requestBody = {
    race: parseInt(race),
    server_id: parseInt(serverId),
    keyword: keyword
  };
  
  // 일일 검색 랭킹에서 온 클릭인 경우에만 search_count 증가 방지
  // 플래그를 확인하고 즉시 제거 (한 번만 사용)
  if (window.skipSearchCount === true) {
    requestBody.skip_search_count = true;
    window.skipSearchCount = false; // 플래그 즉시 제거
  }
  
  // 강제 갱신 플래그 확인 (갱신하기 버튼 클릭 시)
  const isForceRefresh = window.forceCharacterRefresh === true;
  if (isForceRefresh) {
    requestBody.force_refresh = true;
    requestBody.timestamp = Date.now(); // 캐시 방지용 타임스탬프
    window.lastSearchRequestTime = Date.now(); // 응답 시간 측정용
    // 플래그는 응답 처리 후 초기화
  }
  
  fetch('/api/character/search', {
    method: 'POST',
    cache: 'no-store',
    headers: {
      'Content-Type': 'application/json',
      'Pragma': 'no-cache',
      'Cache-Control': 'no-cache'
    },
    body: JSON.stringify(requestBody)
  })
  .then(response => {
    if (!response.ok) {
      return response.json().then(errData => {
        throw new Error(errData.error || `HTTP ${response.status}: ${response.statusText}`);
      });
    }
    return response.json();
  })
  .then(data => {
    document.getElementById('character-loading').style.display = 'none';
    document.getElementById('search-button').disabled = false;
    
    if (data.success && data.data) {
      // 검색 결과
      const result = data.data;
      
      // 강제 갱신 여부 확인
      const wasForceRefresh = window.forceCharacterRefresh === true;
      // 전역 변수에 저장 (calculateDpsScore에서 사용)
      window.wasForceRefresh = wasForceRefresh;
      
      // 캐시 히트/미스 플래그 설정 (캐시 미스일 때만 전투 점수 저장)
      // 서버의 실제 cached 값을 우선 (서버가 실제로 크롤링을 수행했는지 여부를 반영)
      // 강제 갱신을 요청했지만 서버가 cached=true를 반환했다면, 서버가 크롤링을 수행하지 않았거나 실패한 것
      if (!data.cached) {
        // 서버가 실제로 새 데이터를 가져온 경우 (캐시 미스)
        window.isCacheMiss = true;
      } else {
        // 서버가 캐시된 데이터를 반환한 경우 (캐시 히트)
        window.isCacheMiss = false;
      }
      // 강제 갱신 플래그 초기화 (이미 API 요청에 반영되었으므로 초기화)
      window.forceCharacterRefresh = false;
      // wasForceRefresh는 calculateDpsScore가 실행된 후 초기화되어야 하므로 여기서는 유지
      
      // 캐시된 전투 점수가 있으면 저장 (캐시 히트 시)
      if (data.cached && result.combat_score !== undefined && result.combat_score !== null) {
        window.cachedCombatScore = result.combat_score;
      } else {
        window.cachedCombatScore = undefined;
      }
      
      // combat_score_max를 전역 변수에 저장 (calculateDpsScore에서 사용)
      if (result.combat_score_max !== undefined && result.combat_score_max !== null && result.combat_score_max > 0) {
        window.currentCombatScoreMax = result.combat_score_max;
      } else {
        window.currentCombatScoreMax = null;
      }
      
      // 캐시 히트 시 서버에서 받은 랭킹 정보와 전투력 구간 정보 사용 (API 호출 없음)
      if (data.cached && result.nickname && result.server && result.race) {
        // 서버에서 받은 랭킹 정보가 있으면 사용
        if (data.combat_score_rankings) {
          displayCombatScoreRankingsInfo(data.combat_score_rankings);
        }
        // 서버에서 받은 전투력 구간 정보가 있으면 사용
        if (data.combat_score_power_range && result.combat_score) {
          displayCombatScorePowerRangeInfo(data.combat_score_power_range);
        }
        // 달성 최고 점수 표시 (있으면 표시, 없으면 숨김)
        if (result.combat_score_max !== undefined && result.combat_score_max !== null && result.combat_score_max > 0) {
          displayCombatScoreMaxInfo(result.combat_score_max);
        } else {
          displayCombatScoreMaxInfo(null); // 없으면 숨김
        }
      } else {
        // 캐시 미스 시에도 달성 최고 점수 초기화 (새 캐릭터 검색 시 이전 값이 남지 않도록)
        displayCombatScoreMaxInfo(null);
      }
      // 강제 갱신 시에는 calculateDpsScore에서 combat_score 저장 후 랭킹 정보 로드
      
      // URL 업데이트
      const characterURL = buildCharacterURL(result.nickname, serverId, race);
      if (characterURL) {
        // 전체 URL로 변경 (페이지 리로드 없이)
        window.history.pushState(null, '', `/char/serverid=${serverId}/${encodeURIComponent(result.nickname)}`);
      }
      
      // 캐릭터 검색 결과 표시 시 좌우 카드 숨김
      const mainLayout = document.querySelector('.main-layout');
      if (mainLayout) {
        mainLayout.classList.add('show-character-result');
      }
      
      // 검색 결과 표시
      document.getElementById('result-nickname').textContent = result.nickname;
      
      // 즐겨찾기 섹션 업데이트 (show-character-result 클래스 추가 후)
      setTimeout(() => {
        renderFavorites();
      }, 100);
      
      // 즐겨찾기 별표 업데이트
      updateFavoriteStar(result);
      
      // 즐겨찾기 별표 버튼 클릭 이벤트
      const favoriteStarBtn = document.getElementById('favorite-star-btn');
      if (favoriteStarBtn) {
        favoriteStarBtn.onclick = (e) => {
          e.stopPropagation();
          if (isFavorite(result)) {
            removeFavorite(result);
            // 즐겨찾기 제거 시 로컬스토리지에서 삭제 (이미 removeFavorite 함수에서 처리됨)
          } else {
            addFavorite(result);
          }
          updateFavoriteStar(result);
          // 즐겨찾기 섹션 즉시 업데이트 (홈화면에서 바로 반영되도록)
          renderFavorites();
        };
      }
      
      // 업데이트 시간 표시 및 갱신 버튼 설정
      setupCharacterRefreshButton(result, data.cached, data.cache_timestamp);
      
      // 스트리머 뱃지 표시
      const streamerBadgeContainer = document.getElementById('streamer-badge-container');
      if (result.streamer && streamerBadgeContainer) {
        const streamer = result.streamer;
        const platform = streamer.platform;
        const streamerName = streamer.streamer_name || '';
        
        // 플랫폼별 색상 및 이미지 설정
        let badgeColor, badgeBg, badgeBorder, platformName, iconUrl;
        if (platform === 'chzzk') {
          badgeColor = '#00ff00';
          badgeBg = 'rgba(0, 255, 0, 0.2)';
          badgeBorder = 'rgba(0, 255, 0, 0.4)';
          platformName = '치지직';
          // CHZZK 아이콘 이미지
          iconUrl = 'https://play-lh.googleusercontent.com/wvo3IB5dTJHyjpIHvkdzpgbFnG3LoVsqKdQ7W3IoRm-EVzISMz9tTaIYoRdZm1phL_8';
        } else if (platform === 'soop') {
          badgeColor = '#3b82f6';
          badgeBg = 'rgba(59, 130, 246, 0.2)';
          badgeBorder = 'rgba(59, 130, 246, 0.4)';
          platformName = '숲';
          // SOOP 아이콘 이미지
          iconUrl = 'https://play-lh.googleusercontent.com/p9zXgkP4pkCDVR-dQ2HfcHyD5vg9MTjDLFVpckObdHI9dGiiMO9TldFJ7kc5bgEGwYjo';
        }
        
        if (badgeColor) {
          const isLive = streamer.is_live || false;
          
          // 방송 URL 생성 (LIVE일 때만)
          let streamUrl = '';
          let clickHandler = '';
          let cursorStyle = 'cursor: default;';
          let hoverStyles = '';
          
          if (isLive) {
            if (platform === 'chzzk') {
              streamUrl = `https://chzzk.naver.com/live/${streamer.channel_id}`;
            } else if (platform === 'soop' || platform === 'afreeca') {
              streamUrl = `https://play.afreecatv.com/${streamer.channel_id}`;
            }
            clickHandler = `onclick="window.open('${streamUrl}', '_blank')"`;
            cursorStyle = 'cursor: pointer;';
            hoverStyles = `onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'" onmouseout="this.style.transform=''; this.style.boxShadow=''"`;
          }
          
          // LIVE 뱃지 HTML (is_live가 true일 때만)
          const liveBadge = isLive ? `
            <span style="display: inline-flex; align-items: center; justify-content: center; padding: 0.15rem 0.4rem; border-radius: 4px; background: rgba(239, 68, 68, 0.2); border: 1px solid rgba(239, 68, 68, 0.5); color: #ef4444; font-size: 0.75rem; font-weight: 700; margin-left: 0.25rem; text-align: center; min-width: fit-content;">
              LIVE
            </span>
          ` : '';
          
          streamerBadgeContainer.innerHTML = `
            <div ${clickHandler} style="display: flex; align-items: center; gap: 0.25rem; padding: 0.35rem 0.6rem; border-radius: 6px; background: ${badgeBg}; border: 1px solid ${badgeBorder}; color: ${badgeColor}; font-size: 1rem; font-weight: 600; ${cursorStyle} transition: all 0.2s ease;" ${hoverStyles}>
              <img src="${iconUrl}" alt="${platformName}" style="width: 20px; height: 20px; object-fit: contain;">
              <span>${streamerName}</span>
              ${liveBadge}
            </div>
          `;
          streamerBadgeContainer.style.display = 'flex';
        }
      } else if (streamerBadgeContainer) {
        streamerBadgeContainer.style.display = 'none';
        streamerBadgeContainer.innerHTML = '';
      }
      
      updateCompanionBadges(result.pet || null, result.wing || null);
      
      // 서브타이틀 숨김 (이미 HTML에서 display: none으로 설정됨)
      
      // 캐릭터 아바타 이미지 표시
      const avatarContainer = document.getElementById('result-avatar-container');
      const avatarImg = document.getElementById('result-avatar');
      
      if (result.avatar_url) {
        avatarImg.src = result.avatar_url;
        avatarImg.alt = result.nickname || '캐릭터 이미지';
        avatarImg.style.display = 'block';
        avatarContainer.style.display = 'flex';
      } else {
        avatarImg.style.display = 'none';
        avatarContainer.style.display = 'none';
      }
      
      // 종족 색상 설정 (천족: 파란색, 마족: 빨간색)
      const raceElement = document.getElementById('result-race');
      raceElement.textContent = result.race;
      if (result.race === '천족') {
        raceElement.style.color = '#4a90e2';
      } else if (result.race === '마족') {
        raceElement.style.color = '#e24a4a';
      } else {
        raceElement.style.color = 'var(--text-primary)';
      }
      
      document.getElementById('result-server').textContent = result.server;
      
      // 직업 이미지 표시
      const jobImage = document.getElementById('result-job-image');
      const jobText = document.getElementById('result-job');
      if (result.job_image_url) {
        jobImage.src = result.job_image_url;
        jobImage.alt = result.job || '';
        jobImage.style.display = 'block'; // flex 컨테이너 내에서 block으로 표시
        jobText.textContent = result.job || '-';
      } else {
        jobImage.style.display = 'none';
        jobText.textContent = result.job || '-';
      }
      
      // 레기온 표시
      const guildElement = document.getElementById('result-guild');
      const guildRankElement = document.getElementById('result-guild-rank');
      const regionSearchLink = document.getElementById('region-search-link');
      const regionSearchLinkMobile = document.getElementById('region-search-link-mobile');
      if (guildElement) {
        guildElement.textContent = result.guild || '-';
      }
      
      // 레기온 서버 랭킹 표시
      if (guildRankElement) {
        if (result.server_rank !== null && result.server_rank !== undefined && 
            result.server_rank_percent !== null && result.server_rank_percent !== undefined) {
          guildRankElement.textContent = `서버 ${result.server_rank}위 (상위 ${result.server_rank_percent}%)`;
          guildRankElement.style.display = 'block';
        } else {
          guildRankElement.textContent = '';
          guildRankElement.style.display = 'none';
        }
      }
      
      // 레기온 검색 링크 설정 함수
      const setupRegionSearchLink = (linkElement) => {
        if (linkElement && result.guild && result.guild !== '-' && result.server) {
          linkElement.style.display = 'block';
          linkElement.onclick = function(e) {
            e.preventDefault();
            // 레기온 랭킹 탭으로 이동하고 해당 레기온 상세 페이지로 바로 이동
            const rankingTab = document.getElementById('tab-ranking');
            if (rankingTab) {
              rankingTab.checked = true;
              rankingTab.dispatchEvent(new Event('change'));
              updateSidebarVisibility();
              
              setTimeout(() => {
                // 레기온 랭킹 서브탭 활성화
                const regionTab = document.querySelector('#panel-ranking .statistics-sub-tab-btn[data-target="region-ranking"]');
                if (regionTab) {
                  regionTab.click();
                }
                
                setTimeout(() => {
                  // 바로 레기온 상세 페이지로 이동
                  if (typeof loadRegionDetail === 'function') {
                    loadRegionDetail(result.server, result.guild);
                    // URL 업데이트
                    const serverEncoded = encodeURIComponent(result.server);
                    const guildEncoded = encodeURIComponent(result.guild);
                    updateURL(`region/${serverEncoded}/${guildEncoded}`);
                  }
                }, 300);
              }, 200);
            }
          };
        } else if (linkElement) {
          linkElement.style.display = 'none';
        }
      };
      
      // 데스크톱과 모바일 링크 모두 설정
      setupRegionSearchLink(regionSearchLink);
      setupRegionSearchLink(regionSearchLinkMobile);
      
      // 스탯 값들 초기화 (즐겨찾기 캐릭터 클릭 시 이전 값이 남지 않도록)
      // 모든 계산이 완료될 때까지 '-'로 표시하고 섹션 숨김
      const attackPowerValue = document.getElementById('attack-power-value');
      const combatSpeedValue = document.getElementById('combat-speed-value');
      const damageAmpValue = document.getElementById('damage-amplification-value');
      const skillDamageValue = document.getElementById('skill-damage-value');
      const cooldownReductionValue = document.getElementById('cooldown-reduction-value');
      const dpsScoreValue = document.getElementById('dps-score-value');
      const dpsStatsInfo = document.getElementById('dps-stats-info');
      if (attackPowerValue) attackPowerValue.textContent = '-';
      if (combatSpeedValue) combatSpeedValue.textContent = '-';
      if (damageAmpValue) damageAmpValue.textContent = '-';
      if (skillDamageValue) skillDamageValue.textContent = '-';
      if (cooldownReductionValue) cooldownReductionValue.textContent = '-';
      if (dpsScoreValue) dpsScoreValue.textContent = '-';
      const multiHitValue = document.getElementById('multi-hit-value');
      if (multiHitValue) multiHitValue.textContent = '+0.0%';
      const multiHitContainer = document.getElementById('multi-hit-container');
      if (multiHitContainer) multiHitContainer.style.display = 'block';
      // 전투 점수 섹션도 숨김 (계산 완료 후 표시)
      if (dpsStatsInfo) dpsStatsInfo.style.display = 'none';
      // 광고도 숨김
      const adContainer = document.getElementById('character-search-ad');
      if (adContainer) adContainer.style.display = 'none';
      // 달성 최고 점수 초기화
      const combatScoreMaxInfo = document.getElementById('combat-score-max-info');
      if (combatScoreMaxInfo) {
        combatScoreMaxInfo.style.display = 'none';
        combatScoreMaxInfo.innerHTML = '';
      }
      // 전투력 구간 정보도 초기화
      const combatScorePowerRangeInfo = document.getElementById('combat-score-power-range-info');
      if (combatScorePowerRangeInfo) {
        combatScorePowerRangeInfo.style.display = 'none';
        combatScorePowerRangeInfo.innerHTML = '';
      }
      // 랭킹 정보도 초기화
      const combatScoreRankingsInfo = document.getElementById('combat-score-rankings-info');
      if (combatScoreRankingsInfo) {
        combatScoreRankingsInfo.style.display = 'none';
      }
      const combatScoreRankingNotice = document.getElementById('combat-score-ranking-notice');
      if (combatScoreRankingNotice) {
        combatScoreRankingNotice.style.display = 'none';
      }
      
      // 전투력 표시 (0이면 별도 API 호출로 보정 시도)
      const initialCombatPower = parseInt(String(result.combat_power || 0).replace(/,/g, '')) || 0;
      document.getElementById('result-combat-power').textContent = initialCombatPower.toLocaleString();
      
      // 전투력이 0이면 DB에서 최신 전투력 조회 시도 (캐시 히트 시에만)
      if (initialCombatPower === 0 && !window.isCacheMiss && result.nickname && result.server && result.race) {
        
        // DB에서 최신 전투력 조회
        const raceValue = result.race === '천족' ? '1' : result.race === '마족' ? '2' : '';
        if (raceValue && result.server_id) {
          fetch('/api/character/combat-power', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              race: raceValue,
              server_id: result.server_id,
              keyword: result.nickname,
              server_name: result.server,
              race_name: result.race
            })
          })
          .then(res => res.json())
          .then(combatData => {
            if (combatData.success && combatData.combat_power && combatData.combat_power > 0) {
              const correctedPower = parseInt(combatData.combat_power);
              document.getElementById('result-combat-power').textContent = correctedPower.toLocaleString();
              window.currentCombatPower = correctedPower;
            } else {
            }
          })
          .catch(err => {
          });
        }
      }
      
      document.getElementById('character-result').style.display = 'grid';
      
      // 검색 결과 표시 완료 후 로딩 오버레이 숨김 (모든 렌더링 완료 대기)
      setTimeout(() => {
        const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
        if (loadingOverlay) {
          loadingOverlay.style.display = 'none';
        }
      }, 500); // 모든 렌더링 작업 완료 대기
      
      // 즐겨찾기 카드 다시 활성화 (검색 완료 시)
      if (window.isFavoriteSearching) {
        window.isFavoriteSearching = false;
        // 쿨다운은 별도로 관리 (4초 후 해제)
        enableFavoriteCardsAfterCooldown();
      }
      
      // 검색 결과가 표시되면 스트리머 섹션 숨김
      const streamerSection = document.getElementById('streamer-section');
      const streamerTitle = document.getElementById('streamer-title');
      if (streamerSection) {
        streamerSection.style.display = 'none';
      }
      if (streamerTitle) {
        streamerTitle.style.display = 'none';
      }
      
      // characterId, serverId, job 전역 변수에 저장 (개별 아이템 상세 API 호출 및 데바니온에 필요)
      window.currentCharacterId = result.character_id || '';
      window.currentServerId = result.server_id || 0;
      window.currentJobName = result.job || '';  // 직업 이름 (한글, 예: "살성")
      window.currentCharacterJob = result.job || '';  // 스킬 점수 계산용
      window.currentJobImageUrl = result.job_image_url || '';  // 직업 이미지 URL
      
      // 데바니온 데이터 저장 (검색 시 미리 수집된 데이터 사용)
      // 데바니온 데이터가 실제로 유효한지 확인 (nodeList가 있는지 체크)
      if (result.daevanion_data && Object.keys(result.daevanion_data).length > 0) {
        // 각 보드의 데이터가 실제로 유효한지 확인 (nodeList가 있는지 체크)
        let validBoardCount = 0;
        for (const boardId in result.daevanion_data) {
          const boardData = result.daevanion_data[boardId];
          if (boardData && boardData.nodeList && Array.isArray(boardData.nodeList) && boardData.nodeList.length > 0) {
            validBoardCount++;
          }
        }
        
        if (validBoardCount >= 4) {
          window.daevanionData = result.daevanion_data;
        } else {
          window.daevanionData = null;
        }
      } else {
        window.daevanionData = null;
      }
      
      // 성장기록 조회를 위한 전역 변수 저장
      window.currentCharacterNickname = result.nickname || '';
      window.currentCharacterServer = result.server || '';
      window.currentCharacterRace = result.race || '';
      
      // 캐시 히트/미스 플래그는 performSearch()에서 이미 설정되었으므로 덮어쓰지 않음
      // window.isCacheMiss는 performSearch()의 응답 처리에서 설정된 값을 유지해야 함
      
      // 전투력 전역 변수 저장 (영혼 각인 점수 퍼센타일 계산용)
      const combatPowerValue = parseInt(String(result.combat_power || 0).replace(/,/g, '')) || 0;
      window.currentCombatPower = combatPowerValue;
      
      // 내 캐릭터랑 비교 버튼 설정
      const compareBtn = document.getElementById('compare-with-mine-button');
      if (compareBtn) {
        if (result && result.nickname && result.race && result.server) {
          compareBtn.style.display = 'inline-flex';
          const raceValue =
            result.race === '천족' ? '1' :
            result.race === '마족' ? '2' :
            '';
          // href 설정 (새 탭에서 열기 지원)
          const params = new URLSearchParams();
          if (raceValue) params.append('race1', raceValue);
          if (result.server) params.append('server1Name', result.server);
          if (result.server_id) params.append('server1Id', result.server_id);
          if (result.nickname) params.append('nickname1', result.nickname);
          compareBtn.href = '/compare?' + params.toString();
          
          // 일반 클릭은 기본 동작 (현재 탭에서 열기)
          compareBtn.onclick = function (e) {
            e.preventDefault();
            window.location.href = compareBtn.href;
          };
        } else {
          compareBtn.style.display = 'none';
        }
      }
      
      // 장비 정보 표시
      const equipmentData = displayEquipment(result.equipment || [], result.accessories || []);
      
      // 전역 변수에 장비/장신구/아르카나 데이터 저장 (스킬 breakdown 계산용)
      window.currentEquipment = result.equipment || [];
      window.currentAccessories = result.accessories || [];
      window.currentStatData = result.stat || null;
      
      // 타이틀 정보 표시
      const titleCount = displayTitles(result.titles || [], result.title_summary || null);
      
      // 타이틀 데이터 전역 변수에 저장 (피해 증폭 계산용)
      window.currentTitles = result.titles || [];
      
      // 스킬 데이터 전역 변수에 저장 (스킬 딜증 계산용) - displaySkills 호출 전에 설정해야 함
      window.currentSkills = result.skills || [];
      window.currentStigmas = result.stigmas || [];
      window.currentSkillPriorities = result.skill_priorities || null;
      
      // 스킬 정보 표시 (직업 정보 전달) - window.currentSkillPriorities가 설정된 후 호출
      const stigmaShards = displaySkills(result.skills || [], result.stigmas || [], result.job || '');
      
      // 스탯 정보 표시
      const totalStatValue = displayStats(result.stat || null);
      
      // 전투 점수와 스탯 값들은 데바니온 데이터 로드 및 계산 완료 후에만 표시
      // 이전 캐릭터의 잘못된 정보가 잠깐 보이는 것을 방지하기 위해
      // displayCharacterResult 시작 부분에서 이미 '-'로 초기화했으므로
      // 여기서는 계산만 수행하고 표시는 하지 않음
      
      // 데바니온 데이터가 이미 있으면 updateAllDaevanionSkillPoints 호출 (데바니온 탭 클릭과 동일한 로직)
      // 이 함수는 저장된 데바니온 데이터로 포인트 계산 및 모든 스탯 계산을 수행
      // 전역 변수들이 설정된 후 호출되도록 setTimeout 사용
      if (window.daevanionData && Object.keys(window.daevanionData).length >= 4) {
        // 데바니온 데이터가 완전히 로드된 경우 (4개 보드 이상)
        // updateAllDaevanionSkillPoints 호출 (데바니온 탭 클릭 시와 동일한 로직)
        // 이 함수는 저장된 데바니온 데이터를 사용하여 API 호출 없이 모든 스탯 계산
        
        // 캐시 히트 시 전투 점수가 있으면 나중에 캐시된 값으로 대체
        // 단, 갱신하기를 눌렀으면 무조건 새로 계산
        const wasForceRefresh = window.wasForceRefresh === true;
        const isCacheHit = !window.isCacheMiss && !wasForceRefresh;
        const cachedCombatScore = isCacheHit && result.combat_score !== undefined && result.combat_score !== null && result.combat_score > 0 
          ? result.combat_score 
          : null;
        
        // 전역 변수들이 설정된 후 updateAllDaevanionSkillPoints 호출
        setTimeout(() => {
          // updateAllDaevanionSkillPoints 호출 (이 함수 내부에서 모든 스탯 계산 및 전투 점수 계산 수행)
          updateAllDaevanionSkillPoints(false);
          
          // 캐시 히트이고 전투 점수가 있으며, 갱신하기를 누르지 않은 경우에만 캐시된 값으로 대체
          if (cachedCombatScore && !wasForceRefresh) {
            setTimeout(() => {
              const dpsScoreValue = document.getElementById('dps-score-value');
              if (dpsScoreValue) {
                dpsScoreValue.textContent = Math.round(cachedCombatScore).toLocaleString();
              }
              // 딜증 배지 업데이트
              updateAllDamageIncreaseBadges();
              // 랭킹 정보도 로드
              if (result.nickname && result.server && result.race) {
                loadCombatScoreRankingsInfo(result.nickname, result.server, result.race);
              }
              // 전투력 구간 정보 표시 (서버에서 받은 데이터 사용)
              if (data.combat_score_power_range && result.combat_score) {
                displayCombatScorePowerRangeInfo(data.combat_score_power_range);
              } else if (result.combat_score_power_range && result.combat_score) {
                displayCombatScorePowerRangeInfo(result.combat_score_power_range);
              }
              // 달성 최고 점수 표시 (있으면 표시, 없으면 숨김)
              if (result.combat_score_max !== undefined && result.combat_score_max !== null && result.combat_score_max > 0) {
                displayCombatScoreMaxInfo(result.combat_score_max);
              } else {
                displayCombatScoreMaxInfo(null);
              }
            }, 500); // updateAllDaevanionSkillPoints 완료 후 실행
          }
        }, 200); // 전역 변수 설정 후 실행
      } else {
        // 데바니온 데이터가 없거나 불완전한 경우
        // 캐시 히트이고 전투 점수가 있으며, 갱신하기를 누르지 않은 경우에만 전투 점수 표시
        const wasForceRefresh = window.wasForceRefresh === true;
        const isCacheHit = !window.isCacheMiss && !wasForceRefresh;
        if (isCacheHit && result.combat_score !== undefined && result.combat_score !== null && result.combat_score > 0) {
          const dpsScoreValue = document.getElementById('dps-score-value');
          const sectionContainer = document.getElementById('dps-stats-info');
          if (dpsScoreValue) {
            dpsScoreValue.textContent = Math.round(result.combat_score).toLocaleString();
          }
          if (sectionContainer) {
            sectionContainer.style.display = 'block';
          }
          // 광고 표시 및 초기화
          const adContainer = document.getElementById('character-search-ad');
          if (adContainer && adContainer.style.display === 'none') {
            adContainer.style.display = 'block';
            // 광고 초기화 (한 번만 실행)
            try {
              (adsbygoogle = window.adsbygoogle || []).push({});
            } catch (e) {
              console.error('AdSense error:', e);
            }
          }
          // 딜증 배지 업데이트
          updateAllDamageIncreaseBadges();
          // 전투력 구간 정보 표시 (서버에서 받은 데이터 사용)
          if (data.combat_score_power_range && result.combat_score) {
            displayCombatScorePowerRangeInfo(data.combat_score_power_range);
          } else if (result.combat_score_power_range && result.combat_score) {
            displayCombatScorePowerRangeInfo(result.combat_score_power_range);
          }
          // 달성 최고 점수 표시 (있으면 표시, 없으면 숨김)
          if (result.combat_score_max !== undefined && result.combat_score_max !== null && result.combat_score_max > 0) {
            displayCombatScoreMaxInfo(result.combat_score_max);
          } else {
            displayCombatScoreMaxInfo(null); // 없으면 숨김
          }
          // 랭킹 정보도 로드
          if (result.nickname && result.server && result.race) {
            loadCombatScoreRankingsInfo(result.nickname, result.server, result.race);
          }
        }
        // 데바니온 데이터가 없으면 updateAllDaevanionSkillPoints에서 로드 후 계산
      }
      
      // 랭킹 정보 가져오기 (비동기)
      if (result.nickname && result.server && result.race) {
        loadCharacterRankingInfo(result.nickname, result.server, result.race);
      }
      
      // 캐릭터 정보 로그 출력
      window.logCharacterInfoCalled = true; // 데바니온 포인트 계산 완료 시 로그 출력을 위한 플래그
      
      // 전역 변수에 저장 (DB 업데이트용)
      window.currentTotalStatValue = totalStatValue || null;
      window.currentStigmaShards = stigmaShards || null;
      window.currentTitleCount = titleCount || null;
      window.currentArcanaSetOption = (equipmentData && equipmentData.arcanaSetOption) ? equipmentData.arcanaSetOption : null;
      window.currentWeaponNames = (equipmentData && equipmentData.weaponNames) ? equipmentData.weaponNames : null;
      window.currentArmorNames = (equipmentData && equipmentData.armorNames) ? equipmentData.armorNames : null;
      window.currentAccessoryNames = (equipmentData && equipmentData.accessoryNames) ? equipmentData.accessoryNames : null;
      
      logCharacterInfo({
        totalStatValue: totalStatValue || 0,
        stigmaShards: stigmaShards || 0,
        titleCount: titleCount || 0,
        arcanaSetOption: (equipmentData && equipmentData.arcanaSetOption) ? equipmentData.arcanaSetOption : '',
        weaponNames: (equipmentData && equipmentData.weaponNames) ? equipmentData.weaponNames : [],
        armorNames: (equipmentData && equipmentData.armorNames) ? equipmentData.armorNames : [],
        accessoryNames: (equipmentData && equipmentData.accessoryNames) ? equipmentData.accessoryNames : []
      });
      
      // 데바니온 포인트 계산 시작 (비동기)
      // 계산 완료 후 한 번에 모든 정보를 DB에 저장
      // 이미 계산된 값이 있으면 즉시 출력 및 저장, 없으면 계산 후 저장
      if (window.daevanionSharedPoints !== undefined && 
          window.daevanionArielPoints !== undefined && 
          window.daevanionAspelPoints !== undefined) {
        
        // 이미 계산된 데바니온 포인트가 있으면 즉시 DB에 저장
        if (result.nickname && result.server && result.race) {
          // 캡처된 캐릭터 정보 (동시 검색 시 데이터 충돌 방지)
          const capturedInfo = {
            nickname: result.nickname,
            server: result.server,
            race: result.race
          };
          updateCharacterInfoInDB({
            total_stat_value: window.currentTotalStatValue || null,
            stigma_shards: window.currentStigmaShards || null,
            title_count: window.currentTitleCount || null,
            arcana_set_option: window.currentArcanaSetOption || null,
            weapon_names: window.currentWeaponNames || null,
            armor_names: window.currentArmorNames || null,
            accessory_names: window.currentAccessoryNames || null,
            daevanion_crystal: window.daevanionSharedPoints,
            daevanion_crystal_ariel: window.daevanionArielPoints,
            daevanion_crystal_aspel: window.daevanionAspelPoints,
            soul_score: window.currentSoulScore || null
          }, capturedInfo);
        }
      } else {
        // 데바니온 포인트 계산 시작 (데바니온 탭을 열지 않아도 계산)
        // 계산 완료 후 자동으로 DB에 저장됨
        // 강제 갱신 시에는 forceRefresh=true로 전달하여 중복 호출 방지 무시
        const forceRefresh = window.forceCharacterRefresh || false;
        updateAllDaevanionSkillPoints(forceRefresh);
      }
      
      // 컨텐츠 랭킹 정보 표시
      displayContentRankings(result.content_rankings || {});
      
      // 랭킹 정보 조회
      loadCharacterRanking(result.nickname, result.server, result.race);
      
      // 일일 검색 랭킹 갱신
      setTimeout(() => {
        loadDailySearchRanking();
        loadPowerTop5();
        loadServerStats();
      }, 500);
      
      // 탭 상태 초기화 (기본 정보 탭으로 리셋)
      resetCharacterTabs();
      
      // 탭 전환 이벤트 리스너 설정
      setupCharacterTabs();
    } else {
      // 모든 검색 관련 컨테이너 숨김
      const loadingMsg = document.getElementById('character-loading');
      if (loadingMsg) {
        loadingMsg.style.display = 'none';
      }
      
      const errorMsg = document.getElementById('character-error');
      if (errorMsg) {
        errorMsg.style.display = 'none';
        errorMsg.textContent = '';
        errorMsg.innerHTML = '';
      }
      
      const resultContainer = document.getElementById('character-result');
      if (resultContainer) {
        resultContainer.style.display = 'none';
      }
      
      // 로딩 오버레이 숨김
      const loadingOverlay = document.getElementById('fullscreen-loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
      }
      
      // 팝업으로 오류 메시지 표시
      alert('종족/서버/닉네임을 확인해주세요');
      
      // 레이아웃 클래스 제거 (스트리머 섹션을 다시 표시하기 위해)
      const mainLayout = document.querySelector('.main-layout');
      if (mainLayout) {
        mainLayout.classList.remove('show-character-result');
      }
      
      // 홈 화면으로 리셋 (캐릭터 검색 탭 활성화 및 홈 화면 표시)
      const characterTab = document.getElementById('tab-character');
      if (characterTab) {
        characterTab.checked = true;
        characterTab.dispatchEvent(new Event('change'));
        // updateSidebarVisibility가 스트리머 섹션을 다시 표시하도록 함
        updateSidebarVisibility();
      }
    }
  })
  .catch(error => {
    
    document.getElementById('character-loading').style.display = 'none';
    document.getElementById('search-button').disabled = false;
    
    // 모든 검색 관련 컨테이너 숨김
    const loadingMsg = document.getElementById('character-loading');
    if (loadingMsg) {
      loadingMsg.style.display = 'none';
    }
    
    const errorMsg = document.getElementById('character-error');
    if (errorMsg) {
      errorMsg.style.display = 'none';
      errorMsg.textContent = '';
      errorMsg.innerHTML = '';
    }
    
    const resultContainer = document.getElementById('character-result');
    if (resultContainer) {
      resultContainer.style.display = 'none';
    }
    
    // 로딩 오버레이 숨김
    const errorLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
    if (errorLoadingOverlay) {
      errorLoadingOverlay.style.display = 'none';
    }
    
    // 팝업으로 오류 메시지 표시
    alert('종족/서버/닉네임을 확인해주세요');
    
    // 레이아웃 클래스 제거 (스트리머 섹션을 다시 표시하기 위해)
    const mainLayout = document.querySelector('.main-layout');
    if (mainLayout) {
      mainLayout.classList.remove('show-character-result');
    }
    
    // 홈 화면으로 리셋 (캐릭터 검색 탭 활성화 및 홈 화면 표시)
    const characterTab = document.getElementById('tab-character');
    if (characterTab) {
      characterTab.checked = true;
      characterTab.dispatchEvent(new Event('change'));
      // updateSidebarVisibility가 스트리머 섹션을 다시 표시하도록 함
      updateSidebarVisibility();
    }
  });
}

function updateCompanionBadges(petInfo, wingInfo) {
  const row = document.getElementById('companion-badges');
  const hasPet = applyCompanionBadge('pet', petInfo);
  const hasWing = applyCompanionBadge('wing', wingInfo);
  if (row) {
    row.style.display = (hasPet || hasWing) ? 'flex' : 'none';
  }
}

function applyCompanionBadge(prefix, info) {
  const badge = document.getElementById(`${prefix}-badge`);
  const nameEl = document.getElementById(`${prefix}-name`);
  const iconEl = document.getElementById(`${prefix}-icon`);
  const hasInfo = info && (info.name || info.icon_url);
  if (!badge || !nameEl || !iconEl) return false;
  if (!hasInfo) {
    badge.style.display = 'none';
    return false;
  }
  nameEl.textContent = info.name || '-';
  if (info.grade) {
    const gradeColor = getGradeColor(info.grade) || null;
    nameEl.style.color = gradeColor || 'var(--text-primary)';
  } else {
    nameEl.style.color = 'var(--text-primary)';
  }
  if (info.icon_url) {
    iconEl.src = info.icon_url;
    iconEl.style.display = 'block';
  } else {
    iconEl.style.display = 'none';
  }
  badge.style.display = 'flex';
  return true;
}

// 스킬 정보 표시 함수
function displaySkills(skills, stigmas, job = '') {
  const skillInfo = document.getElementById('skill-info');
  const activeSection = document.getElementById('skills-active-section');
  const passiveSection = document.getElementById('skills-passive-section');
  const stigmaSection = document.getElementById('skills-stigma-section');
  const activeContainer = document.getElementById('skills-active-container');
  const passiveContainer = document.getElementById('skills-passive-container');
  const stigmasContainer = document.getElementById('stigmas-container');
  const recommendButton = document.getElementById('skill-recommend-button');

  [activeContainer, passiveContainer, stigmasContainer].forEach(container => {
    if (container) container.innerHTML = '';
  });

  const hasSkills = Array.isArray(skills) && skills.length > 0;
  const hasStigmas = Array.isArray(stigmas) && stigmas.length > 0;

  if (!hasSkills && !hasStigmas) {
    if (skillInfo) skillInfo.style.display = 'none';
    if (recommendButton) recommendButton.style.display = 'none';
    return;
  }
  if (skillInfo) skillInfo.style.display = 'block';

  const activeSkills = [];
  const passiveSkills = [];

  if (hasSkills) {
    // 스킬을 타입별로 분류
    skills.forEach(skill => {
      const group = detectSkillGroup(skill);
      if (group === 'passive') {
        passiveSkills.push(skill);
      } else {
        activeSkills.push(skill);
      }
    });
    
    // 스킬을 캐릭터가 찍은 레벨 높은 순으로 정렬
    activeSkills.sort((a, b) => {
      const levelA = a.level_int || parseInt(a.level || '0', 10) || 0;
      const levelB = b.level_int || parseInt(b.level || '0', 10) || 0;
      return levelB - levelA;
    });
    
    passiveSkills.sort((a, b) => {
      const levelA = a.level_int || parseInt(a.level || '0', 10) || 0;
      const levelB = b.level_int || parseInt(b.level || '0', 10) || 0;
      return levelB - levelA;
    });
  }

  // 추천 버튼 표시 및 이벤트 설정
  if (job && (hasSkills || hasStigmas)) {
    if (recommendButton) {
      recommendButton.style.display = 'block';
      recommendButton.href = `#statistics-skill-${encodeURIComponent(job)}`;
      recommendButton.onclick = function (e) {
        e.preventDefault();
        navigateToSkillStats(job);
      };
    }
  } else {
    if (recommendButton) recommendButton.style.display = 'none';
  }

  const hasActiveRendered = renderSkillCategory(activeSkills, activeContainer, activeSection, '액티브 스킬 정보가 없습니다.');
  const hasPassiveRendered = renderSkillCategory(passiveSkills, passiveContainer, passiveSection, '패시브 스킬 정보가 없습니다.');

  let hasStigmaRendered = false;
  if (hasStigmas) {
    // 스티그마를 캐릭터가 찍은 레벨 높은 순으로 정렬
    let sortedStigmas = [...stigmas];
    sortedStigmas.sort((a, b) => {
      const levelA = a.level_int || parseInt(a.level || '0', 10) || 0;
      const levelB = b.level_int || parseInt(b.level || '0', 10) || 0;
      return levelB - levelA;
    });
    
    hasStigmaRendered = renderSkillCategory(sortedStigmas, stigmasContainer, stigmaSection, '스티그마 정보가 없습니다.');
    
    // 스티그마 스킬 포인트 계산
    const totalStigmaShards = calculateTotalStigmaShards(sortedStigmas);
    const stigmaHeader = document.getElementById('stigma-header');
    if (stigmaHeader) {
      stigmaHeader.innerHTML = `스티그마 <span style="font-size: 0.85rem; color: var(--text-muted); margin-left: 0.5rem;">(사용된 스티그마 샤드: ${totalStigmaShards}개)</span>`;
    }
  } else {
    hasStigmaRendered = renderSkillCategory([], stigmasContainer, stigmaSection, '스티그마 정보가 없습니다.');
    const stigmaHeader = document.getElementById('stigma-header');
    if (stigmaHeader) {
      stigmaHeader.innerHTML = '스티그마';
    }
  }

  // 스킬 렌더링 후 통계 로드 및 순위 표시 (비활성화 - renderSkillCategory에서 priority 기반으로 처리)
  // if (job && (hasActiveRendered || hasPassiveRendered || hasStigmaRendered)) {
  //   setTimeout(() => {
  //     loadSkillRanksAndDisplay(job);
  //   }, 100);
  // }

  if (!(hasActiveRendered || hasPassiveRendered || hasStigmaRendered) && skillInfo) {
    skillInfo.style.display = 'none';
  } else if (skillInfo) {
    skillInfo.style.display = 'block';
  }
  
  // 스티그마 샤드 반환
  if (hasStigmas) {
    const sortedStigmas = [...stigmas].sort((a, b) => {
      const levelA = a.level_int || parseInt(a.level || '0');
      const levelB = b.level_int || parseInt(b.level || '0');
      return levelB - levelA;
    });
    return calculateTotalStigmaShards(sortedStigmas);
  }
  return 0;
}

// 캐릭터 갱신 버튼 설정 함수
function setupCharacterRefreshButton(result, isCached, cacheTimestamp) {
  const updateInfo = document.getElementById('character-update-info');
  const updateTime = document.getElementById('character-update-time');
  const refreshBtn = document.getElementById('character-refresh-btn');
  const refreshCooldown = document.getElementById('character-refresh-cooldown');
  
  if (!updateInfo || !updateTime || !refreshBtn) {
    return;
  }
  
  updateInfo.style.display = 'flex';
  
  // 캐릭터별 마지막 갱신 시간 저장 키 생성
  const characterKey = `${result.race}_${result.server}_${result.nickname}`;
  const lastUpdateKey = `character_last_update_${characterKey}`;
  
  let timeString;
  if (isCached && cacheTimestamp) {
    // 캐시된 데이터일 때는 서버에서 받은 캐시 생성 시간 사용
    // cacheTimestamp 형식: "2025. 12. 05. 14:15:37"
    timeString = cacheTimestamp;
  } else if (isCached) {
    // 캐시된 데이터지만 타임스탬프가 없는 경우 (구 형식 캐시)
    // localStorage에 저장된 마지막 갱신 시간 사용
    const storedTime = localStorage.getItem(lastUpdateKey);
    if (storedTime) {
      const lastUpdateTime = new Date(parseInt(storedTime));
      timeString = lastUpdateTime.toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
        timeZone: 'Asia/Seoul'
      });
    } else {
      // 저장된 시간이 없으면 현재 시간 사용 (첫 검색)
      const now = new Date();
      timeString = now.toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false,
        timeZone: 'Asia/Seoul'
      });
      localStorage.setItem(lastUpdateKey, now.getTime().toString());
    }
  } else {
    // 새로 갱신한 데이터일 때는 현재 시간 사용 및 저장
    const now = new Date();
    timeString = now.toLocaleString('ko-KR', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
      timeZone: 'Asia/Seoul'
    });
    localStorage.setItem(lastUpdateKey, now.getTime().toString());
  }
  
  updateTime.textContent = `최근 업데이트 시간: ${timeString}`;
  
  // 갱신 버튼 클릭 이벤트 (1분 쿨다운)
  const COOLDOWN_TIME = 60 * 1000; // 1분 = 60초
  const COOLDOWN_STORAGE_KEY = 'character_refresh_cooldown';
  
  // 쿨다운 상태 확인 및 복원
  function checkCooldown() {
    const storedTime = localStorage.getItem(COOLDOWN_STORAGE_KEY);
    if (storedTime) {
      const lastRefreshTime = parseInt(storedTime);
      const currentTime = Date.now();
      const timeSinceLastRefresh = currentTime - lastRefreshTime;
      
      if (timeSinceLastRefresh < COOLDOWN_TIME) {
        // 아직 쿨다운 중
        const remainingSeconds = Math.ceil((COOLDOWN_TIME - timeSinceLastRefresh) / 1000);
        refreshBtn.disabled = true;
        refreshBtn.style.opacity = '0.5';
        refreshBtn.style.cursor = 'not-allowed';
        refreshBtn.textContent = '갱신하기';
        
        if (refreshCooldown) {
          refreshCooldown.style.display = 'inline';
          refreshCooldown.textContent = `(${remainingSeconds}초 후 다시 가능)`;
          
          // 카운트다운 시작
          let countdown = remainingSeconds;
          const cooldownInterval = setInterval(() => {
            countdown--;
            if (countdown > 0) {
              refreshCooldown.textContent = `(${countdown}초 후 다시 가능)`;
            } else {
              clearInterval(cooldownInterval);
              localStorage.removeItem(COOLDOWN_STORAGE_KEY);
              refreshBtn.disabled = false;
              refreshBtn.style.opacity = '1';
              refreshBtn.style.cursor = 'pointer';
              if (refreshCooldown) {
                refreshCooldown.style.display = 'none';
              }
            }
          }, 1000);
        }
        return true; // 쿨다운 중
      } else {
        // 쿨다운 완료
        localStorage.removeItem(COOLDOWN_STORAGE_KEY);
      }
    }
    return false; // 쿨다운 없음
  }
  
  // 페이지 로드 시 쿨다운 상태 확인
  if (checkCooldown()) {
    // 쿨다운 중이면 이미 처리됨
  } else {
    // 쿨다운 없으면 버튼 활성화
    refreshBtn.disabled = false;
    refreshBtn.style.opacity = '1';
    refreshBtn.style.cursor = 'pointer';
    if (refreshCooldown) {
      refreshCooldown.style.display = 'none';
    }
  }
  
  // 쿨다운 interval 전역 변수로 관리 (중복 방지)
  let cooldownIntervalId = null;
  
  refreshBtn.onclick = function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // 이미 쿨다운 중이면 무시
    if (refreshBtn.disabled) {
      return false;
    }
    
    const currentTime = Date.now();
    const storedTime = localStorage.getItem(COOLDOWN_STORAGE_KEY);
    
    if (storedTime) {
      const lastRefreshTime = parseInt(storedTime);
      const timeSinceLastRefresh = currentTime - lastRefreshTime;
      
      if (timeSinceLastRefresh < COOLDOWN_TIME) {
        const remainingSeconds = Math.ceil((COOLDOWN_TIME - timeSinceLastRefresh) / 1000);
        return false;
      }
    }
    
    // 갱신 시작 - 즉시 버튼 비활성화
    refreshBtn.disabled = true;
    refreshBtn.style.opacity = '0.5';
    refreshBtn.style.cursor = 'not-allowed';
    refreshBtn.textContent = '갱신 중...';
    
    // 쿨다운 시간 저장
    localStorage.setItem(COOLDOWN_STORAGE_KEY, currentTime.toString());
    
    // 쿨다운 표시 및 카운트다운
    if (refreshCooldown) {
      refreshCooldown.style.display = 'inline';
      let remainingSeconds = 60;
      refreshCooldown.textContent = `(${remainingSeconds}초 후 다시 가능)`;
      
      // 기존 interval 정리
      if (cooldownIntervalId) {
        clearInterval(cooldownIntervalId);
      }
      
      cooldownIntervalId = setInterval(() => {
        remainingSeconds--;
        if (remainingSeconds > 0) {
          refreshCooldown.textContent = `(${remainingSeconds}초 후 다시 가능)`;
        } else {
          clearInterval(cooldownIntervalId);
          cooldownIntervalId = null;
          localStorage.removeItem(COOLDOWN_STORAGE_KEY);
          refreshBtn.disabled = false;
          refreshBtn.style.opacity = '1';
          refreshBtn.style.cursor = 'pointer';
          refreshBtn.textContent = '갱신하기';
          if (refreshCooldown) {
            refreshCooldown.style.display = 'none';
          }
        }
      }, 1000);
    }
    
    // 캐시 무시하고 강제 갱신
    const race = result.race === '천족' ? '1' : result.race === '마족' ? '2' : '';
    const serverId = result.server_id || window.currentServerId;
    const keyword = result.nickname;
    
    if (race && serverId && keyword) {
      // 강제 갱신 플래그 설정
      window.forceCharacterRefresh = true;
      
      // 화면 초기화 - 캐릭터 정보 영역 숨기고 로딩 표시
      const characterResult = document.getElementById('character-result');
      if (characterResult) {
        characterResult.style.display = 'none';
      }
      const characterLoading = document.getElementById('character-loading');
      if (characterLoading) {
        characterLoading.style.display = 'block';
      }
      
      // 폼 값 업데이트 (performSearch가 올바른 값을 사용하도록)
      const serverSelect = document.getElementById('server-select');
      const keywordInput = document.getElementById('character-keyword');
      
      // 종족 버튼 업데이트 (URL 파라미터로 로드된 것이므로 localStorage에 저장하지 않음)
      if (race) {
        updateRaceSelection(race, true);
      }
      if (serverSelect) {
        serverSelect.value = serverId;
      }
      if (keywordInput) keywordInput.value = keyword;
      
      // 전역 변수 초기화 (이전 데이터가 남아있지 않도록)
      window.daevanionData = null;
      window.attackPowerResult = null;
      window.combatSpeedResult = null;
      window.damageAmplificationResult = null;
      window.skillDamageResult = null;
      window.cooldownReductionResult = null;
      window.currentEquipment = null;
      window.currentAccessories = null;
      window.currentStatData = null;
      window.currentSkills = null;
      window.currentStigmas = null;
      window.currentTitles = null;
      // ★ 추가: 더 많은 전역 변수 초기화 (이전 캐릭터 데이터 잔류 방지)
      window.perfectResult = null;
      window.stunHitResult = null;
      window.multiHitResult = null;
      window.criticalHitResult = null;
      window.weaponMinAttack = 0;
      window.weaponMaxAttack = 0;
      window.currentCombatScoreMax = null;
      window.currentCombatPower = null;
      // 데바니온 포인트 변수 초기화 (updateAllDaevanionSkillPoints가 다시 호출되도록)
      window.daevanionSharedPoints = undefined;
      window.daevanionArielPoints = undefined;
      window.daevanionAspelPoints = undefined;
      
      // 데바니온 포인트 업데이트 플래그 초기화 (갱신 시 다시 계산되도록)
      if (typeof isUpdatingDaevanionPoints !== 'undefined') {
        isUpdatingDaevanionPoints = false;
      }
      
      // performSearch를 호출하여 강제 갱신 수행
      // performSearch 내부에서 window.forceCharacterRefresh를 확인하고
      // API 요청에 force_refresh: true를 포함시킵니다.
      performSearch();
    }
  };
  
  // 초기 상태는 checkCooldown()에서 설정됨
}

// 캐릭터 정보 DB 업데이트 함수
// capturedInfo 파라미터 필수: { nickname, server, race } (동시 검색 시 데이터 충돌 방지)
// ⚠️ 전역 변수 사용 금지 - 반드시 capturedInfo를 통해 캐릭터 정보 전달
function updateCharacterInfoInDB(characterInfo, capturedInfo) {
  try {
    // capturedInfo 필수 검증 - 전역 변수 사용하지 않음 (경쟁 조건 방지)
    if (!capturedInfo || typeof capturedInfo !== 'object') {
      console.warn('[updateCharacterInfoInDB] capturedInfo 객체가 필요합니다. 전역 변수는 사용하지 않습니다.');
      return;
    }
    
    const nickname = capturedInfo.nickname;
    const server = capturedInfo.server;
    const race = capturedInfo.race;
    
    // 필수 파라미터 검증 (빈 문자열 포함)
    if (!nickname || !server || !race) {
      console.warn('[updateCharacterInfoInDB] 필수 파라미터 누락으로 건너뜀:', { nickname, server, race });
      return;
    }
    
    // race 값 검증 - 숫자가 아닌 문자열("천족" 또는 "마족")이어야 함
    if (race === '1' || race === '2' || race === 1 || race === 2) {
      console.warn('[updateCharacterInfoInDB] race 값이 숫자입니다. 문자열("천족"/"마족")이어야 합니다:', race);
      return;
    }
    
    fetch('/api/character/update-info', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        nickname: nickname,
        server: server,
        race: race,
        character_info: characterInfo
      })
    })
    .then(response => {
      if (!response.ok) {
        return response.json().then(data => {
          throw new Error(data.error || `HTTP ${response.status}`);
        });
      }
      return response.json();
    })
    .then(data => {
      if (data.success) {
      } else {
      }
    })
    .catch(error => {
    });
  } catch (error) {
  }
}

// 캐릭터 정보 로그 출력 함수
function logCharacterInfo(info) {
}

// 스티그마 스킬 포인트 계산 함수
function calculateStigmaShards(level) {
  const levelInt = parseInt(level || '0');
  if (levelInt <= 0) return 0;
  
  let total = 0;
  
  // 1~5레벨: 1개씩
  if (levelInt >= 1) {
    const level1to5 = Math.min(levelInt, 5);
    total += level1to5 * 1;
  }
  
  // 6~10레벨: 2개씩
  if (levelInt >= 6) {
    const level6to10 = Math.min(levelInt - 5, 5);
    total += level6to10 * 2;
  }
  
  // 11~15레벨: 5개씩
  if (levelInt >= 11) {
    const level11to15 = Math.min(levelInt - 10, 5);
    total += level11to15 * 4;
  }
  
  // 16~20레벨: 8개씩
  if (levelInt >= 16) {
    const level16to20 = Math.min(levelInt - 15, 5);
    total += level16to20 * 8;
  }
  
  return total;
}

// 총 스티그마 스킬 포인트 계산
function calculateTotalStigmaShards(stigmas) {
  if (!Array.isArray(stigmas) || stigmas.length === 0) {
    return 0;
  }
  
  let total = 0;
  stigmas.forEach(stigma => {
    const level = stigma.level_int || parseInt(stigma.level || '0');
    if (level > 0) {
      total += calculateStigmaShards(level);
    }
  });
  
  return total;
}

// 스탯 정보 표시
function displayStats(statData) {
  const statsSection = document.getElementById('stats-section');
  const statsContainer = document.getElementById('stats-container');
  
  if (!statsSection || !statsContainer) {
    return 0;
  }
  
  statsContainer.innerHTML = '';
  
  if (!statData) {
    statsSection.style.display = 'none';
    return 0;
  }
  
  if (!statData.statList || !Array.isArray(statData.statList)) {
    statsSection.style.display = 'none';
    return 0;
  }
  
  // 신성 능력치 타입 정의
  const divineStatTypes = [
    'Justice',      // 정의
    'Freedom',      // 자유
    'Illusion',    // 환상
    'Life',        // 생명
    'Time',        // 시간
    'Destruction', // 파괴
    'Death',       // 죽음
    'Wisdom',      // 지혜
    'Destiny',     // 운명
    'Space'        // 공간
  ];
  
  // 신성 능력치만 필터링
  const divineStats = statData.statList.filter(stat => {
    return divineStatTypes.includes(stat.type);
  });
  
  if (divineStats.length === 0) {
    statsSection.style.display = 'none';
    return 0;
  }
  
  // 타입 순서대로 정렬
  const sortedStats = divineStats.sort((a, b) => {
    const indexA = divineStatTypes.indexOf(a.type);
    const indexB = divineStatTypes.indexOf(b.type);
    return indexA - indexB;
  });
  
  // 총 스탯 합계 계산
  const totalStatValue = sortedStats.reduce((sum, stat) => {
    const value = parseInt(stat.value || 0);
    return sum + value;
  }, 0);
  
  // 헤더에 총합 표시
  const statsHeader = document.getElementById('stats-header');
  if (statsHeader) {
    statsHeader.innerHTML = `주신 스탯 <span style="font-size: 0.85rem; color: var(--text-muted); margin-left: 0.5rem;">(총합: ${totalStatValue})</span>`;
  }
  
  // 스탯 카드 생성
  sortedStats.forEach(stat => {
    
    const statCard = document.createElement('div');
    statCard.className = 'stat-card';
    
    // 스탯 이름
    const nameDiv = document.createElement('div');
    nameDiv.className = 'stat-name';
    nameDiv.textContent = stat.name || stat.type;
    statCard.appendChild(nameDiv);
    
    // 레벨 표시
    const levelDiv = document.createElement('div');
    levelDiv.className = 'stat-level';
    levelDiv.textContent = `${stat.value || 0}`;
    statCard.appendChild(levelDiv);
    
    // 효과 목록 계산 (스탯 값 × 0.1% × 배율)
    const statValue = parseFloat(stat.value || 0);
    if (statValue > 0 && stat.statSecondList && Array.isArray(stat.statSecondList) && stat.statSecondList.length > 0) {
      const effectsDiv = document.createElement('div');
      effectsDiv.className = 'stat-effects';
      
      // 각 주신 스탯별 효과 배율 정의
      // 기본: 수치 1당 +0.1% (일부는 -0.1%)
      // 각 효과는 스탯 값 × 0.1 × 배율로 계산
      const statType = stat.type;
      let effectMultipliers = [];
      
      if (statType === 'Justice') {
        // 정의[네자칸]: 방어력 증가, 완벽 (각각 2배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Freedom') {
        // 자유[바이젤]: 정확도 증가, 회피 증가 (각각 4배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Illusion') {
        // 환상[카이시넬]: 재사용 시간 감소(-), 철벽 관통 (각각 4배, 첫 번째는 음수)
        effectMultipliers = [-2, 2];
      } else if (statType === 'Life') {
        // 생명[유스티엘]: HP 증가, 재생 (각각 4배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Time') {
        // 시간[시엘]: 전투 속도, 치명타 저항 (각각 2배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Destruction') {
        // 파괴[지켈]: 공격력 증가, 완벽 저항 (각각 2배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Death') {
        // 죽음[트리니엘]: 치명타 증가, 재생 관통 (각각 4배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Wisdom') {
        // 지혜[루미엘]: 정신력 소모 감소(-), 치명타 (각각 4배, 첫 번째는 음수)
        effectMultipliers = [-2, 2];
      } else if (statType === 'Destiny') {
        // 운명[마르쿠탄]: 정신력 증가, 철벽 (각각 4배)
        effectMultipliers = [2, 2];
      } else if (statType === 'Space') {
        // 공간[이스라펠]: 이동 속도, 블록 증가 (각각 4배)
        effectMultipliers = [2, 2];
      } else {
        // 기본값: 2배
        effectMultipliers = [2, 2];
      }
      
      stat.statSecondList.forEach((effect, index) => {
        const effectItem = document.createElement('div');
        effectItem.className = 'stat-effect-item';
        
        // 효과 텍스트에서 숫자 부분을 찾아서 스탯 값 기반으로 재계산
        const multiplier = effectMultipliers[index] !== undefined ? effectMultipliers[index] : (effectMultipliers[0] || 2);
        const isNegative = multiplier < 0;
        const calculatedPercent = (statValue * 0.1 * Math.abs(multiplier)).toFixed(1).replace(/\.0$/, '');
        
        // 효과 텍스트에서 숫자 부분을 찾아서 교체
        // 예: "방어력 증가 12.6%" → "방어력 증가 X%" (X는 계산된 값)
        // 음수인 경우: "재사용 시간 감소 -13.6%" → "재사용 시간 감소 -X%"
        let calculatedEffect = effect.replace(/([+-]?\d+\.?\d*)/g, (match) => {
          // 기존 숫자를 계산된 값으로 교체
          // 음수 배율인 경우 부호 포함
          return isNegative ? `-${calculatedPercent}` : calculatedPercent;
        });
        
        effectItem.textContent = calculatedEffect;
        effectsDiv.appendChild(effectItem);
      });
      
      statCard.appendChild(effectsDiv);
    }
    
    statsContainer.appendChild(statCard);
  });
  
  statsSection.style.display = 'block';
  
  // 일반 스탯도 표시
  displayNormalStats(statData);
  
  return totalStatValue;
}

// 일반 스탯 정보 표시
function displayNormalStats(statData) {
  const normalStatsSection = document.getElementById('normal-stats-section');
  const normalStatsContainer = document.getElementById('normal-stats-container');
  
  if (!normalStatsSection || !normalStatsContainer) {
    return;
  }
  
  normalStatsContainer.innerHTML = '';
  
  if (!statData) {
    normalStatsSection.style.display = 'none';
    return;
  }
  
  if (!statData.statList || !Array.isArray(statData.statList)) {
    normalStatsSection.style.display = 'none';
    return;
  }
  
  // 일반 스탯 타입 정의 및 한글 이름 매핑
  const normalStatTypes = ['STR', 'DEX', 'INT', 'CON', 'AGI', 'WIS'];
  const normalStatNames = {
    'STR': '위력',
    'DEX': '민첩',
    'INT': '지식',
    'CON': '체력',
    'AGI': '정확',
    'WIS': '의지'
  };
  
  // 일반 스탯만 필터링
  const normalStats = statData.statList.filter(stat => {
    return normalStatTypes.includes(stat.type);
  });
  
  if (normalStats.length === 0) {
    normalStatsSection.style.display = 'none';
    return;
  }
  
  // 타입 순서대로 정렬
  const sortedStats = normalStats.sort((a, b) => {
    const indexA = normalStatTypes.indexOf(a.type);
    const indexB = normalStatTypes.indexOf(b.type);
    return indexA - indexB;
  });
  
  // 스탯 카드 생성
  sortedStats.forEach(stat => {
    const statCard = document.createElement('div');
    statCard.className = 'normal-stat-card';
    
    // 스탯 이름 (한글 이름 사용)
    const nameDiv = document.createElement('div');
    nameDiv.className = 'stat-name';
    nameDiv.textContent = normalStatNames[stat.type] || stat.name || stat.type;
    statCard.appendChild(nameDiv);
    
    // 스탯 값 표시
    const valueDiv = document.createElement('div');
    valueDiv.className = 'stat-level';
    valueDiv.textContent = `${stat.value || 0}`;
    statCard.appendChild(valueDiv);
    
    // 효과 목록
    if (stat.statSecondList && Array.isArray(stat.statSecondList) && stat.statSecondList.length > 0) {
      const effectsDiv = document.createElement('div');
      effectsDiv.className = 'stat-effects';
      
      stat.statSecondList.forEach(effect => {
        const effectItem = document.createElement('div');
        effectItem.className = 'stat-effect-item';
        // 일반 스탯은 2배로 곱하지 않음 (주신 스탯만 2배)
        effectItem.textContent = effect;
        effectsDiv.appendChild(effectItem);
      });
      
      statCard.appendChild(effectsDiv);
    }
    
    normalStatsContainer.appendChild(statCard);
  });
  
  normalStatsSection.style.display = 'block';
}

// 공격력 계산 함수
function calculateAttackPower(equipment, accessories, statData, daevanionData) {
  // 중복 계산 방지: 이미 계산 중이면 스킵
  if (window.isCalculatingAttackPower) {
    return null;
  }
  
  window.isCalculatingAttackPower = true;
  
  let totalIntegerAttack = 0; // 정수 절대값 증가
  let totalPercentAttack = 0; // 퍼센트 증가
  
  // Breakdown 정보 추적
  let daevanionAttackTotal = 0; // 데바니온으로 인한 공격력 증가 (4개 보드)
  let daevanionArielAttackTotal = 0; // 데바니온 아리엘 보드로 인한 공격력 증가 (PVE/보스 공격력)
  let equipmentAttackTotal = 0; // 장비/장신구로 인한 공격력 증가 (초월 포함 전체)
  let equipmentAttackBase = 0; // 장비/장신구 기본 공격력 (초월 없이)
  let equipmentTranscendAttack = 0; // 장비/장신구 초월로 인한 공격력 증가 (정수 증가분 + 퍼센트 증가분)
  let totalTranscendInteger = 0; // 모든 장비/장신구 초월 정수 증가분 합산
  let totalBaseAttackForTranscend = 0; // 초월 계산용: (기본 옵션 공격력 + 초월 정수) 합산
  let totalTranscendPercent = 0; // 모든 장비/장신구 초월 퍼센트 합산
  let destructionPercent = 0; // 주신 스탯 파괴로 인한 퍼센트 증가
  let powerPercent = 0; // 위력으로 인한 퍼센트 증가 (일반 스탯 + 영혼 각인 합산)
  let normalStatPowerPercent = 0; // 일반 스탯 위력으로 인한 퍼센트 증가
  let soulPowerPercent = 0; // 영혼 각인 위력으로 인한 퍼센트 증가
  
  const logs = [];
  
  // 1. 메인 무기/가더의 기본 옵션 (정수, 강화에 따른 수치 포함)
  // 무기/가더 판별: slotPos 사용 (1=메인 무기, 2=가더) 또는 첫번째 장비가 무기
  const weaponAndGauntlet = [...(equipment || [])].filter((item, idx) => {
    // slotPos, slot_pos, slot_index, slot, raw_data.slotPos 등 다양한 경로 확인
    let slotPos = -1;
    
    if (item.slotPos !== undefined && item.slotPos !== null) slotPos = item.slotPos;
    else if (item.slot_pos !== undefined && item.slot_pos !== null) slotPos = item.slot_pos;
    else if (item.slot_index !== undefined && item.slot_index !== null) slotPos = item.slot_index;
    else if (item.slot !== undefined && item.slot !== null) slotPos = item.slot;
    else if (item.raw_data && item.raw_data.slotPos !== undefined && item.raw_data.slotPos !== null) slotPos = item.raw_data.slotPos;
    
    // slotPos가 1이면 메인 무기, 2이면 가더
    // 문자열일 수도 있으므로 == 비교 사용하거나 변환 후 비교
    const isSlotMatch = slotPos == 1 || slotPos == 2;
    
    // 또는 첫번째 장비는 무기로 간주 (장비 리스트에서 무기가 첫번째로 오는 경우)
    // 또는 이름에 무기 키워드가 포함된 경우
    const weaponKeywords = ['검', '도끼', '활', '창', '지팡이', '마도서', '권갑', '단검', '대검', '석궁', '건', '오브', '메이스', '할버드'];
    const itemName = (item.name || '').toLowerCase();
    const isWeaponByName = idx === 0 || weaponKeywords.some(keyword => itemName.includes(keyword));
    
    return isSlotMatch || (idx === 0 && isWeaponByName);
  });
  
  weaponAndGauntlet.forEach((item, index) => {
    const itemName = item.name || '알 수 없음';
    const enhanceLevel = parseInt(item.enhance_level || item.enchantLevel || 0);
    const exceedLevel = parseInt(item.exceed_level || item.exceedLevel || 0);
    
    // 무기/가더 판별: slotPos 사용 (1=메인 무기, 2=가더) 또는 첫번째 장비
    let slotPos = -1;
    if (item.slotPos !== undefined && item.slotPos !== null) slotPos = item.slotPos;
    else if (item.slot_pos !== undefined && item.slot_pos !== null) slotPos = item.slot_pos;
    else if (item.slot_index !== undefined && item.slot_index !== null) slotPos = item.slot_index;
    else if (item.slot !== undefined && item.slot !== null) slotPos = item.slot;
    else if (item.raw_data && item.raw_data.slotPos !== undefined) slotPos = item.raw_data.slotPos;
    
    // 첫번째 장비(index 0)는 무기로 간주
    const isWeapon = slotPos == 1 || slotPos === '1' || index === 0;
    const isGauntlet = slotPos == 2 || slotPos === '2';
    
    // mainStats에서 공격력 추출
    let baseAttack = 0;
    let enhanceBonus = 0;
    let minAttack = 0; // 최소 공격력
    let maxAttack = 0; // 최대 공격력
    
    // mainStats 검색
    if (item.main_stats) {
      // 배열인 경우 (createEquipmentItem과 동일한 방식)
      if (Array.isArray(item.main_stats)) {
        item.main_stats.forEach((stat, statIndex) => {
          if (!stat || typeof stat !== 'object') return;
          
          const statName = stat.name || stat.id || '';
          const statValue = stat.value || '';
          const statMinValue = stat.minValue || '';
          const statExtra = stat.extra || '0';
          
          // 공격력 찾기
          if (statName.includes('공격력') || statName.toLowerCase().includes('attack')) {
            // minValue에서 최소 공격력 추출
            if (statMinValue) {
              if (typeof statMinValue === 'string') {
                const minMatch = statMinValue.match(/(\d+)\s*\(\+(\d+)\)/);
                if (minMatch) {
                  minAttack += parseInt(minMatch[1]) || 0;
                  minAttack += parseInt(minMatch[2]) || 0;
                } else {
                  const minNum = parseInt(statMinValue.replace(/[^\d]/g, '')) || 0;
                  if (minNum > 0) {
                    minAttack += minNum;
                  }
                }
              } else if (typeof statMinValue === 'number') {
                minAttack += statMinValue;
              }
            }
            
            // value에서 최대 공격력 추출
            if (typeof statValue === 'string') {
              // "489 (+225)" 형식 처리
              const match = statValue.match(/(\d+)\s*\(\+(\d+)\)/);
              if (match) {
                const baseVal = parseInt(match[1]) || 0;
                const extraVal = parseInt(match[2]) || 0;
                baseAttack += baseVal;
                enhanceBonus += extraVal;
                // maxAttack은 base + extra 합계
                maxAttack += baseVal + extraVal;
              } else {
                // 숫자만 있는 경우
                const num = parseInt(statValue.replace(/[^\d]/g, '')) || 0;
                if (num > 0) {
                  baseAttack += num;
                  maxAttack += num;
                }
              }
            } else if (typeof statValue === 'number') {
              baseAttack += statValue;
              maxAttack += statValue;
            }
            
            // extra에서 강화 보너스 추출
            if (statExtra && statExtra !== '0' && statExtra !== 0 && statExtra !== '0%') {
              const extraNum = parseInt(statExtra.toString().replace(/[^\d]/g, '')) || 0;
              if (extraNum > 0) {
                enhanceBonus += extraNum;
              }
            }
          }
        });
      }
      // 객체인 경우
      else if (typeof item.main_stats === 'object' && !Array.isArray(item.main_stats)) {
        // 공격력 관련 키 찾기
        const attackKeys = ['attack', '공격력', 'attackPower', 'atk'];
        for (const key of Object.keys(item.main_stats)) {
          const keyLower = key.toLowerCase();
          if (attackKeys.some(ak => keyLower.includes(ak))) {
            const value = item.main_stats[key];
            if (typeof value === 'string') {
              // "535 (+225)" 형태 파싱
              const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
              if (match) {
                baseAttack += parseInt(match[1]) || 0;
                enhanceBonus += parseInt(match[2]) || 0;
              } else {
                // 숫자만 있는 경우
                const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                baseAttack += num;
              }
            } else if (typeof value === 'number') {
              baseAttack += value;
            }
          }
        }
      }
    }
    
    // options에서도 공격력 찾기 (더 포괄적으로)
    if (item.options) {
      // 배열인 경우
      if (Array.isArray(item.options)) {
        item.options.forEach(option => {
          if (typeof option === 'object' && option !== null) {
            for (const key in option) {
              const keyLower = String(key).toLowerCase();
              const value = option[key];
              
              if (keyLower.includes('공격력') || keyLower.includes('attack')) {
                if (typeof value === 'string') {
                  const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
                  if (match) {
                    baseAttack += parseInt(match[1]) || 0;
                    enhanceBonus += parseInt(match[2]) || 0;
                  } else {
                    const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                    baseAttack += num;
                  }
                } else if (typeof value === 'number') {
                  baseAttack += value;
                }
              }
            }
          }
        });
      }
      // 객체인 경우
      else if (typeof item.options === 'object' && !Array.isArray(item.options)) {
        for (const key of Object.keys(item.options)) {
          const keyLower = key.toLowerCase();
          if (keyLower.includes('공격력') || keyLower.includes('attack')) {
            const value = item.options[key];
            if (typeof value === 'string') {
              const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
              if (match) {
                baseAttack += parseInt(match[1]) || 0;
                enhanceBonus += parseInt(match[2]) || 0;
              } else {
                const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                baseAttack += num;
              }
            } else if (typeof value === 'number') {
              baseAttack += value;
            }
          }
        }
      }
    }
    
    // raw_data에서도 재귀적으로 찾기
    if (item.raw_data) {
      const findAttackInData = (data, path = '') => {
        if (typeof data === 'string') {
          const match = data.match(/(\d+)\s*\(\+(\d+)\)/);
          if (match && (data.includes('공격력') || data.includes('attack'))) {
            const base = parseInt(match[1]) || 0;
            const enhance = parseInt(match[2]) || 0;
            if (base > 0 || enhance > 0) {
              baseAttack += base;
              enhanceBonus += enhance;
            }
          }
        } else if (Array.isArray(data)) {
          data.forEach((item, idx) => {
            findAttackInData(item, `${path}[${idx}]`);
          });
        } else if (typeof data === 'object' && data !== null) {
          for (const key in data) {
            const keyLower = String(key).toLowerCase();
            if (keyLower.includes('공격력') || keyLower.includes('attack') || 
                keyLower.includes('main') || keyLower.includes('option')) {
              findAttackInData(data[key], path ? `${path}.${key}` : key);
            }
          }
        }
      };
      findAttackInData(item.raw_data);
    }
    
    // 초월 정수 보너스 계산 (무기/가더: 초월 +1당 +30)
    let exceedIntegerBonus = 0;
    if (exceedLevel > 0) {
      exceedIntegerBonus = exceedLevel * 30;
    }
    
    // 초월 퍼센트 (초월 +1 당 공격력 +1%)
    const exceedPercent = exceedLevel;
    
    // 무기(slotPos 1)의 최소/최대 공격력 저장 (완벽 계산용)
    if (isWeapon) {
      // maxAttack이 0이면 baseAttack + enhanceBonus 사용
      if (maxAttack === 0 && baseAttack > 0) {
        maxAttack = baseAttack + enhanceBonus;
      }
      
      // minAttack이 0이면 maxAttack의 85% 사용
      if (minAttack === 0 && maxAttack > 0) {
        minAttack = Math.floor(maxAttack * 0.85);
      }
      
      if (maxAttack > 0) {
        // 초월 보너스 적용 안 함 - 화면에 표시된 원래 값 그대로 저장
        window.weaponMinAttack = minAttack;
        window.weaponMaxAttack = maxAttack;
      }
    }
    
    // 기본 옵션 공격력 계산: baseAttack + enhanceBonus (초월 없이)
    if (baseAttack > 0 || enhanceBonus > 0) {
      const baseAttackOnly = baseAttack + enhanceBonus;
      
      totalIntegerAttack += baseAttackOnly;
      equipmentAttackBase += baseAttackOnly; // Breakdown 정보 저장 (기본)
      
      if (exceedLevel > 0) {
        // 초월 정수 증가분 합산
        totalTranscendInteger += exceedIntegerBonus;
        // 초월 계산용: (기본 옵션 공격력 + 초월 정수) 합산
        totalBaseAttackForTranscend += baseAttack + exceedIntegerBonus;
        totalTranscendPercent += exceedPercent;
        logs.push(`[${itemName}] 기본 옵션 공격력: ${baseAttack} + 강화 ${enhanceBonus} = ${baseAttackOnly} (돌파: ${exceedPercent}%, 돌파정수: ${exceedIntegerBonus}) (최소: ${minAttack}, 최대: ${maxAttack})`);
      } else {
        logs.push(`[${itemName}] 기본 옵션 공격력: ${baseAttack} + 강화 ${enhanceBonus} = ${baseAttackOnly} (최소: ${minAttack}, 최대: ${maxAttack})`);
      }
    } else if (exceedIntegerBonus > 0) {
      // baseAttack이 0이지만 초월 정수가 있는 경우
      totalTranscendInteger += exceedIntegerBonus;
      totalBaseAttackForTranscend += exceedIntegerBonus;
      totalTranscendPercent += exceedPercent;
    }
  });
  
  // 1-2. 장신구의 기본 옵션 공격력 추출
  const accessoriesList = [...(accessories || [])];
  accessoriesList.forEach(item => {
    const itemName = item.name || '알 수 없음';
    
    
    let baseAttack = 0;
    let enhanceBonus = 0;
    
    // mainStats 검색 (무기/가더와 동일한 로직)
    if (item.main_stats) {
      // 배열인 경우
      if (Array.isArray(item.main_stats)) {
        item.main_stats.forEach(stat => {
          if (typeof stat === 'object' && stat !== null) {
            // name 필드가 '공격력'인 경우
            const statName = String(stat.name || '').toLowerCase();
            if (statName.includes('공격력') || statName.includes('attack')) {
              // value 필드를 우선 사용 (실제 기본 공격력), 없으면 minValue 사용
              const baseValue = parseInt(stat.value || stat.minValue || 0);
              // extra 필드에서 강화 보너스 추출
              const extraValue = parseInt(stat.extra || 0);
              
              if (baseValue > 0 || extraValue > 0) {
                baseAttack += baseValue;
                enhanceBonus += extraValue;
              }
            }
            
            // 기존 방식: 모든 필드에서 공격력 찾기 (백업)
            for (const key in stat) {
              const keyLower = String(key).toLowerCase();
              const value = stat[key];
              
              // 이미 처리한 필드는 스킵
              if (key === 'name' || key === 'minValue' || key === 'value' || key === 'extra') {
                continue;
              }
              
              if (keyLower.includes('공격력') || keyLower.includes('attack')) {
                if (typeof value === 'string') {
                  const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
                  if (match) {
                    baseAttack += parseInt(match[1]) || 0;
                    enhanceBonus += parseInt(match[2]) || 0;
                  } else {
                    const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                    baseAttack += num;
                  }
                } else if (typeof value === 'number') {
                  baseAttack += value;
                }
              }
            }
          }
        });
      }
      // 객체인 경우
      else if (typeof item.main_stats === 'object' && !Array.isArray(item.main_stats)) {
        // 공격력 관련 키 찾기
        const attackKeys = ['attack', '공격력', 'attackPower', 'atk'];
        for (const key of Object.keys(item.main_stats)) {
          const keyLower = key.toLowerCase();
          if (attackKeys.some(ak => keyLower.includes(ak))) {
            const value = item.main_stats[key];
            if (typeof value === 'string') {
              // "99 (+100)" 형태 파싱
              const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
              if (match) {
                baseAttack += parseInt(match[1]) || 0;
                enhanceBonus += parseInt(match[2]) || 0;
              } else {
                // 숫자만 있는 경우
                const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                baseAttack += num;
              }
            } else if (typeof value === 'number') {
              baseAttack += value;
            }
          }
        }
      }
    }
    
    // options에서도 공격력 찾기
    if (item.options) {
      // 배열인 경우
      if (Array.isArray(item.options)) {
        item.options.forEach(option => {
          if (typeof option === 'object' && option !== null) {
            for (const key in option) {
              const keyLower = String(key).toLowerCase();
              const value = option[key];
              
              if (keyLower.includes('공격력') || keyLower.includes('attack')) {
                if (typeof value === 'string') {
                  const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
                  if (match) {
                    baseAttack += parseInt(match[1]) || 0;
                    enhanceBonus += parseInt(match[2]) || 0;
                  } else {
                    const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                    baseAttack += num;
                  }
                } else if (typeof value === 'number') {
                  baseAttack += value;
                }
              }
            }
          }
        });
      }
      // 객체인 경우
      else if (typeof item.options === 'object' && !Array.isArray(item.options)) {
        for (const key of Object.keys(item.options)) {
          const keyLower = key.toLowerCase();
          if (keyLower.includes('공격력') || keyLower.includes('attack')) {
            const value = item.options[key];
            if (typeof value === 'string') {
              const match = value.match(/(\d+)\s*\(\+(\d+)\)/);
              if (match) {
                baseAttack += parseInt(match[1]) || 0;
                enhanceBonus += parseInt(match[2]) || 0;
              } else {
                const num = parseInt(value.replace(/[^\d]/g, '')) || 0;
                baseAttack += num;
              }
            } else if (typeof value === 'number') {
              baseAttack += value;
            }
          }
        }
      }
    }
    
    // raw_data에서도 재귀적으로 찾기
    if (item.raw_data) {
      const findAttackInData = (data, path = '') => {
        if (typeof data === 'string') {
          const match = data.match(/(\d+)\s*\(\+(\d+)\)/);
          if (match && (data.includes('공격력') || data.includes('attack'))) {
            const base = parseInt(match[1]) || 0;
            const enhance = parseInt(match[2]) || 0;
            if (base > 0 || enhance > 0) {
              baseAttack += base;
              enhanceBonus += enhance;
            }
          }
        } else if (Array.isArray(data)) {
          data.forEach((item, idx) => {
            findAttackInData(item, `${path}[${idx}]`);
          });
        } else if (typeof data === 'object' && data !== null) {
          for (const key in data) {
            const keyLower = String(key).toLowerCase();
            if (keyLower.includes('공격력') || keyLower.includes('attack') || 
                keyLower.includes('main') || keyLower.includes('option')) {
              findAttackInData(data[key], path ? `${path}.${key}` : key);
            }
          }
        }
      };
      findAttackInData(item.raw_data);
    }
    
    // 초월 정수 보너스 계산 (장신구: 초월 +1당 +20)
    const exceedLevel = parseInt(item.exceed_level || 0);
    let exceedIntegerBonus = 0;
    if (exceedLevel > 0) {
      exceedIntegerBonus = exceedLevel * 20;
    }
    
    // 초월 퍼센트 (초월 +1 당 공격력 +1%)
    const exceedPercent = exceedLevel;
    
    // 기본 옵션 공격력 계산: baseAttack + enhanceBonus (초월 없이)
    if (baseAttack > 0 || enhanceBonus > 0) {
      const baseAttackOnly = baseAttack + enhanceBonus;
      
      totalIntegerAttack += baseAttackOnly;
      equipmentAttackBase += baseAttackOnly; // Breakdown 정보 저장 (기본)
      
      if (exceedLevel > 0) {
        // 초월 정수 증가분 합산
        totalTranscendInteger += exceedIntegerBonus;
        // 초월 계산용: (기본 옵션 공격력 + 초월 정수) 합산
        totalBaseAttackForTranscend += baseAttack + exceedIntegerBonus;
        totalTranscendPercent += exceedPercent;
        logs.push(`[${itemName}] 기본 옵션 공격력 (장신구): ${baseAttack} + 강화 ${enhanceBonus} = ${baseAttackOnly} (돌파: ${exceedPercent}%, 돌파정수: ${exceedIntegerBonus})`);
      } else {
        logs.push(`[${itemName}] 기본 옵션 공격력 (장신구): ${baseAttack} + 강화 ${enhanceBonus} = ${baseAttackOnly}`);
      }
    } else if (exceedIntegerBonus > 0) {
      // baseAttack이 0이지만 초월 정수가 있는 경우
      totalTranscendInteger += exceedIntegerBonus;
      totalBaseAttackForTranscend += exceedIntegerBonus;
      totalTranscendPercent += exceedPercent;
    }
  });
  
  // 2. 초월 수치에 따른 증가량은 이미 기본 옵션에 포함되었으므로 제거
  // (초월 정수 보너스와 퍼센트는 각 아이템의 기본 옵션 계산 시 적용됨)
  
  // 3. 영혼 각인 및 마석 각인에서 정수 공격력 추출 + 무기/가더 영혼 각인에서 위력 추출
  let weaponPower = 0; // 무기 영혼 각인 위력
  let gauntletPower = 0; // 가더 영혼 각인 위력
  
  const allItems = [...(equipment || []), ...(accessories || [])];
  allItems.forEach(item => {
    const itemName = item.name || '알 수 없음';
    const itemNameLower = itemName.toLowerCase();
    const categoryName = (item.category_name || '').toLowerCase();
    const itemType = (item.type || '').toLowerCase();
    
    // slotPos 확인 - 다양한 경로 시도
    let slotPos = -1;
    if (item.slotPos !== undefined && item.slotPos !== null) slotPos = item.slotPos;
    else if (item.slot_pos !== undefined && item.slot_pos !== null) slotPos = item.slot_pos;
    else if (item.slot_index !== undefined && item.slot_index !== null) slotPos = item.slot_index;
    else if (item.slot !== undefined && item.slot !== null) slotPos = item.slot;
    
    // 무기/가더 판별: slotPos 사용 (1=메인 무기, 2=가더)
    const isWeapon = slotPos === 1 || slotPos === '1';
    const isGauntlet = slotPos === 2 || slotPos === '2';
    
    // subStats (영혼 각인)에서 공격력 및 위력 추출
    if (item.sub_stats) {
      let soulAttack = 0;
      let soulPower = 0;
      
      if (Array.isArray(item.sub_stats)) {
        item.sub_stats.forEach(stat => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseInt(stat.value || stat.amount || 0);
            
            // 공격력 추출
            if ((name.includes('공격력') || name.includes('attack')) && value > 0) {
              soulAttack += value;
            }
            
            // 위력 추출
            if (name.includes('위력') || name.includes('power') || name.includes('might')) {
              if (value > 0) {
                if (isWeapon) {
                  weaponPower += value;
                  soulPower += value;
                } else if (isGauntlet) {
                  gauntletPower += value;
                  soulPower += value;
                }
              }
            }
          }
        });
      } else if (typeof item.sub_stats === 'object') {
        for (const key of Object.keys(item.sub_stats)) {
          const keyLower = key.toLowerCase();
          const value = parseInt(item.sub_stats[key] || 0);
          
          // 공격력 추출
          if ((keyLower.includes('공격력') || keyLower.includes('attack')) && value > 0) {
            soulAttack += value;
          }
          
          // 위력 추출
          if (keyLower.includes('위력') || keyLower.includes('power') || keyLower.includes('might')) {
            if (value > 0) {
              if (isWeapon) {
                weaponPower += value;
                soulPower += value;
              } else if (isGauntlet) {
                gauntletPower += value;
                soulPower += value;
              }
            }
          }
        }
      }
      
      if (soulAttack > 0) {
        totalIntegerAttack += soulAttack;
        equipmentAttackTotal += soulAttack; // Breakdown 정보 저장 (전체)
        equipmentAttackBase += soulAttack; // Breakdown 정보 저장 (기본 - 초월과 무관)
        logs.push(`[${itemName}] 영혼 각인 공격력: +${soulAttack}`);
      }
      
      if (soulPower > 0) {
        if (isWeapon) {
          logs.push(`[${itemName}] 영혼 각인 위력 (무기): +${soulPower}`);
        } else if (isGauntlet) {
          logs.push(`[${itemName}] 영혼 각인 위력 (가더): +${soulPower}`);
        } else {
          logs.push(`[${itemName}] 영혼 각인 위력: +${soulPower}`);
        }
      }
    }
    
    // magic_stone_stat (마석 각인)에서 공격력 추출
    if (item.magic_stone_stat) {
      let stoneAttack = 0;
      if (Array.isArray(item.magic_stone_stat)) {
        item.magic_stone_stat.forEach(stat => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseInt(stat.value || stat.amount || 0);
            if ((name.includes('공격력') || name.includes('attack')) && value > 0) {
              stoneAttack += value;
            }
          }
        });
      } else if (typeof item.magic_stone_stat === 'object') {
        for (const key of Object.keys(item.magic_stone_stat)) {
          const keyLower = key.toLowerCase();
          if (keyLower.includes('공격력') || keyLower.includes('attack')) {
            const value = parseInt(item.magic_stone_stat[key] || 0);
            if (value > 0) {
              stoneAttack += value;
            }
          }
        }
      }
      
      if (stoneAttack > 0) {
        totalIntegerAttack += stoneAttack;
        equipmentAttackTotal += stoneAttack; // Breakdown 정보 저장 (전체)
        equipmentAttackBase += stoneAttack; // Breakdown 정보 저장 (기본 - 초월과 무관)
        logs.push(`[${itemName}] 마석 각인 공격력: +${stoneAttack}`);
      }
    }
  });
  
  // 4. 데바니온 (아리엘, 아스펠 제외) 4개 보드에서의 추가 공격력
  const daevanionBoardIds = [41, 42, 43, 44]; // 네자칸, 지켈, 바이젤, 트리니엘
  const daevanionBoardNames = { 41: '네자칸', 42: '지켈', 43: '바이젤', 44: '트리니엘' };
  let daevanionAttack = 0;
  const daevanionAttackLogs = [];
  
  if (daevanionData) {
    daevanionBoardIds.forEach(boardId => {
      const boardName = daevanionBoardNames[boardId] || `보드${boardId}`;
      const boardData = daevanionData[boardId];
      let boardAttack = 0;
      
      if (boardData && boardData.nodeList) {
        // open 값이 1, "1", true 등일 수 있으므로 유연하게 처리
        const activeNodes = boardData.nodeList.filter(n => n.open == 1 || n.open === true || n.open === 'true');
        
        activeNodes.forEach((node, nodeIndex) => {
          let nodeAttack = 0;
          let foundInField = null;
          
          // 노드의 모든 필드를 순회하며 검색
          for (const key in node) {
            const value = node[key];
            
            // 문자열인 경우 패턴 검색
            if (typeof value === 'string' && value.trim()) {
              const text = value;
              
              // 다양한 패턴 시도
              // 1. "추가 공격력 +5" 패턴
              let matches = text.match(/(?:추가\s*)?공격력\s*[+＋]\s*(\d+)/gi);
              if (!matches) {
                // 2. "공격력 +5" 패턴 (더 넓은 패턴)
                matches = text.match(/공격력\s*[+＋]\s*(\d+)/gi);
              }
              if (!matches) {
                // 3. "추가 공격력+5" (공백 없음)
                matches = text.match(/추가\s*공격력\s*[+＋](\d+)/gi);
              }
              if (!matches) {
                // 4. "공격력+5" (공백 없음)
                matches = text.match(/공격력\s*[+＋](\d+)/gi);
              }
              
              if (matches) {
                matches.forEach(match => {
                  const numMatch = match.match(/(\d+)/);
                  if (numMatch) {
                    const attackValue = parseInt(numMatch[1]) || 0;
                    if (attackValue > 0) {
                      nodeAttack += attackValue;
                      if (!foundInField) foundInField = key;
                    }
                  }
                });
              }
            }
            
            // 배열인 경우 (statList, effectList 등)
            if (Array.isArray(value) && value.length > 0) {
              value.forEach((item, itemIndex) => {
                if (typeof item === 'object' && item !== null) {
                  // 객체의 모든 필드 검색
                  for (const itemKey in item) {
                    const itemValue = item[itemKey];
                    if (typeof itemValue === 'string' && itemValue.trim()) {
                      let matches = itemValue.match(/(?:추가\s*)?공격력\s*[+＋]\s*(\d+)/gi);
                      if (!matches) {
                        matches = itemValue.match(/공격력\s*[+＋]\s*(\d+)/gi);
                      }
                      if (!matches) {
                        matches = itemValue.match(/추가\s*공격력\s*[+＋](\d+)/gi);
                      }
                      if (!matches) {
                        matches = itemValue.match(/공격력\s*[+＋](\d+)/gi);
                      }
                      
                      if (matches) {
                        matches.forEach(match => {
                          const numMatch = match.match(/(\d+)/);
                          if (numMatch) {
                            const attackValue = parseInt(numMatch[1]) || 0;
                            if (attackValue > 0) {
                              nodeAttack += attackValue;
                              if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                            }
                          }
                        });
                      }
                    }
                    
                    // value나 amount 필드가 숫자인 경우
                    if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                      const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                      if (itemName.includes('공격력') || itemName.includes('attack')) {
                        nodeAttack += itemValue;
                        if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                      }
                    }
                  }
                } else if (typeof item === 'string' && item.trim()) {
                  let matches = item.match(/(?:추가\s*)?공격력\s*[+＋]\s*(\d+)/gi);
                  if (!matches) {
                    matches = item.match(/공격력\s*[+＋]\s*(\d+)/gi);
                  }
                  if (matches) {
                    matches.forEach(match => {
                      const numMatch = match.match(/(\d+)/);
                      if (numMatch) {
                        const attackValue = parseInt(numMatch[1]) || 0;
                        if (attackValue > 0) {
                          nodeAttack += attackValue;
                          if (!foundInField) foundInField = `${key}[${itemIndex}]`;
                        }
                      }
                    });
                  }
                }
              });
            }
            
            // 객체인 경우 재귀적으로 검색
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
              for (const subKey in value) {
                const subValue = value[subKey];
                if (typeof subValue === 'string' && subValue.trim()) {
                  let matches = subValue.match(/(?:추가\s*)?공격력\s*[+＋]\s*(\d+)/gi);
                  if (!matches) {
                    matches = subValue.match(/공격력\s*[+＋]\s*(\d+)/gi);
                  }
                  if (matches) {
                    matches.forEach(match => {
                      const numMatch = match.match(/(\d+)/);
                      if (numMatch) {
                        const attackValue = parseInt(numMatch[1]) || 0;
                        if (attackValue > 0) {
                          nodeAttack += attackValue;
                          if (!foundInField) foundInField = `${key}.${subKey}`;
                        }
                      }
                    });
                  }
                }
              }
            }
          }
          
          if (nodeAttack > 0) {
            boardAttack += nodeAttack;
            const nodeName = node.name || node.desc || node.effect || `노드${nodeIndex}`;
            daevanionAttackLogs.push(`  [${boardName}] ${nodeName} (${foundInField || '알 수 없음'}): +${nodeAttack}`);
          }
        });
        
        if (boardAttack > 0) {
          daevanionAttack += boardAttack;
        }
      }
    });
  }
  
  if (daevanionAttack > 0) {
    totalIntegerAttack += daevanionAttack;
    daevanionAttackTotal = daevanionAttack; // Breakdown 정보 저장 (4개 보드)
    logs.push(`[데바니온] 4개 보드 추가 공격력: +${daevanionAttack}`);
    // 상세 로그 추가
    daevanionAttackLogs.forEach(log => logs.push(log));
  } else if (daevanionData) {
    daevanionAttackTotal = 0;
    logs.push(`[데바니온] 4개 보드 추가 공격력: +0 (추가 공격력 노드 없음)`);
  }
  
  // 4-1. 데바니온 아리엘 보드에서 PVE 공격력, 보스 공격력 추출
  let daevanionArielAttack = 0;
  const daevanionArielAttackLogs = [];
  
  if (daevanionData && daevanionData[45]) {
    const boardData = daevanionData[45];
    let boardArielAttack = 0;
    
    if (boardData && boardData.nodeList) {
      const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
      
      activeNodes.forEach((node, nodeIndex) => {
        let nodeArielAttack = 0;
        let foundInField = null;
        
        // 노드의 모든 필드를 순회하며 검색
        for (const key in node) {
          const value = node[key];
          
          // 문자열인 경우 패턴 검색 (PVE 공격력, 보스 공격력)
          if (typeof value === 'string' && value.trim()) {
            const text = value;
            
            // "PVE 공격력 +5", "보스 공격력 +5" 패턴 검색
            let matches = text.match(/(?:PVE\s*공격력|보스\s*공격력)\s*[+＋]\s*(\d+)/gi);
            if (!matches) {
              matches = text.match(/(?:PVE공격력|보스공격력)\s*[+＋]\s*(\d+)/gi);
            }
            if (!matches) {
              matches = text.match(/(?:pve\s*attack|boss\s*attack)\s*[+＋]\s*(\d+)/gi);
            }
            
            if (matches) {
              matches.forEach(match => {
                const numMatch = match.match(/(\d+)/);
                if (numMatch) {
                  const attackValue = parseInt(numMatch[1]) || 0;
                  if (attackValue > 0) {
                    nodeArielAttack += attackValue;
                    if (!foundInField) foundInField = key;
                  }
                }
              });
            }
          }
          
          // 배열인 경우
          if (Array.isArray(value) && value.length > 0) {
            value.forEach((item, itemIndex) => {
              if (typeof item === 'object' && item !== null) {
                for (const itemKey in item) {
                  const itemValue = item[itemKey];
                  if (typeof itemValue === 'string' && itemValue.trim()) {
                    let matches = itemValue.match(/(?:PVE\s*공격력|보스\s*공격력)\s*[+＋]\s*(\d+)/gi);
                    if (!matches) {
                      matches = itemValue.match(/(?:PVE공격력|보스공격력)\s*[+＋]\s*(\d+)/gi);
                    }
                    if (!matches) {
                      matches = itemValue.match(/(?:pve\s*attack|boss\s*attack)\s*[+＋]\s*(\d+)/gi);
                    }
                    
                    if (matches) {
                      matches.forEach(match => {
                        const numMatch = match.match(/(\d+)/);
                        if (numMatch) {
                          const attackValue = parseInt(numMatch[1]) || 0;
                          if (attackValue > 0) {
                            nodeArielAttack += attackValue;
                            if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                          }
                        }
                      });
                    }
                  }
                  
                  // value나 amount 필드가 숫자인 경우
                  if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                    const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                    if (itemName.includes('pve 공격력') || itemName.includes('보스 공격력') || 
                        itemName.includes('pve attack') || itemName.includes('boss attack')) {
                      nodeArielAttack += itemValue;
                      if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                    }
                  }
                }
              }
            });
          }
          
          // 객체인 경우 재귀적으로 검색
          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            for (const subKey in value) {
              const subValue = value[subKey];
              if (typeof subValue === 'string' && subValue.trim()) {
                let matches = subValue.match(/(?:PVE\s*공격력|보스\s*공격력)\s*[+＋]\s*(\d+)/gi);
                if (!matches) {
                  matches = subValue.match(/(?:PVE공격력|보스공격력)\s*[+＋]\s*(\d+)/gi);
                }
                if (!matches) {
                  matches = subValue.match(/(?:pve\s*attack|boss\s*attack)\s*[+＋]\s*(\d+)/gi);
                }
                
                if (matches) {
                  matches.forEach(match => {
                    const numMatch = match.match(/(\d+)/);
                    if (numMatch) {
                      const attackValue = parseInt(numMatch[1]) || 0;
                      if (attackValue > 0) {
                        nodeArielAttack += attackValue;
                        if (!foundInField) foundInField = `${key}.${subKey}`;
                      }
                    }
                  });
                }
              }
            }
          }
        }
        
        if (nodeArielAttack > 0) {
          boardArielAttack += nodeArielAttack;
          const nodeName = node.name || node.desc || node.effect || `노드${nodeIndex}`;
          daevanionArielAttackLogs.push(`  [아리엘] ${nodeName} (${foundInField || '알 수 없음'}): +${nodeArielAttack}`);
        }
      });
      
      if (boardArielAttack > 0) {
        daevanionArielAttack = boardArielAttack;
      }
    }
  }
  
  if (daevanionArielAttack > 0) {
    totalIntegerAttack += daevanionArielAttack;
    daevanionArielAttackTotal = daevanionArielAttack; // Breakdown 정보 저장 (아리엘)
    logs.push(`[데바니온] 아리엘 보드 PVE/보스 공격력: +${daevanionArielAttack}`);
    daevanionArielAttackLogs.forEach(log => logs.push(log));
  } else if (daevanionData && daevanionData[45]) {
    daevanionArielAttackTotal = 0;
    logs.push(`[데바니온] 아리엘 보드 PVE/보스 공격력: +0 (PVE/보스 공격력 노드 없음)`);
  }
  
  // 5. 주신 스탯 중 파괴[지켈] 스탯 1당 공격력 +0.1%
  if (statData && statData.statList) {
    const destructionStat = statData.statList.find(stat => 
      stat.type === 'Destruction' || (stat.name && stat.name.includes('파괴'))
    );
    if (destructionStat) {
      const destructionValue = parseInt(destructionStat.value || 0);
      destructionPercent = destructionValue * 0.2; // Breakdown 정보 저장 (1당 0.2%, 2배 적용)
      totalPercentAttack += destructionPercent;
      logs.push(`[주신 스탯] 파괴[지켈] ${destructionValue}: +${destructionPercent.toFixed(1)}%`);
    }
  }
  
  // 6. 일반 스탯 중 위력 스탯 1당 공격력 +0.1% (영혼 각인 위력 제외 - 아이온2 12월17일 업데이트로 스탯 수치에 반영됨)
  let totalPower = 0; // 총 위력 (일반 스탯만, 영혼 각인 위력 제외)
  let normalStatPower = 0; // 일반 스탯 위력
  let soulPowerTotal = 0; // 영혼 각인 위력 합계 (표시용, 계산에는 사용 안 함)
  
  if (statData && statData.statList) {
    const powerStat = statData.statList.find(stat => stat.type === 'STR');
    if (powerStat) {
      normalStatPower = parseInt(powerStat.value || 0);
      totalPower = normalStatPower; // 일반 스탯 위력만 사용
      
      // 영혼 각인 위력은 표시용으로만 저장 (계산에는 사용 안 함)
      soulPowerTotal = weaponPower + gauntletPower;
      
      // 일반 스탯 위력만 계산 (영혼 각인 위력 제외)
      normalStatPowerPercent = normalStatPower * 0.1;
      soulPowerPercent = 0; // 영혼 각인 위력은 계산에서 제외
      powerPercent = totalPower * 0.1; // 일반 스탯 위력만 사용
      totalPercentAttack += powerPercent;
      
      logs.push(`[일반 스탯] 위력 ${totalPower}: +${powerPercent.toFixed(1)}%`);
    } else {
      // 일반 스탯 위력이 없으면 0
      normalStatPowerPercent = 0;
      soulPowerPercent = 0;
      powerPercent = 0;
    }
  } else {
    // statData가 없으면 0
    normalStatPowerPercent = 0;
    soulPowerPercent = 0;
    powerPercent = 0;
  }
  
  // 최종 장비/장신구 공격력 (기본만, 초월은 별도 계산)
  equipmentAttackTotal = equipmentAttackBase;
  
  // 새로운 계산식: (데바니온 + 장비장신구 + 초월 정수분) * (초월 퍼센티지 + 파괴 + 위력) + 데바니온 (아리엘 PVE)
  // 베이스 공격력 (정수)
  const baseAttack = daevanionAttackTotal + equipmentAttackBase + totalTranscendInteger;
  
  // 퍼센트 증가 (초월 퍼센트 + 파괴 + 위력)
  const percentMultiplier = totalTranscendPercent + destructionPercent + powerPercent;
  
  // 최종 계산
  const finalAttack = Math.floor(baseAttack * (1 + percentMultiplier / 100)) + daevanionArielAttackTotal;
  
  // 로그 추가
  if (totalTranscendInteger > 0 || totalTranscendPercent > 0) {
    logs.push(`[계산식] 베이스: ${baseAttack.toLocaleString()} = 데바니온(${daevanionAttackTotal}) + 장비/장신구(${equipmentAttackBase}) + 돌파정수(${totalTranscendInteger})`);
    logs.push(`[계산식] 퍼센트: ${percentMultiplier.toFixed(1)}% = 돌파퍼센트(${totalTranscendPercent}%) + 파괴(${destructionPercent.toFixed(1)}%) + 위력(${powerPercent.toFixed(1)}%)`);
    logs.push(`[계산식] 최종: ${baseAttack.toLocaleString()} * (1 + ${percentMultiplier.toFixed(1)}%) + 아리엘PVE(${daevanionArielAttackTotal}) = ${finalAttack.toLocaleString()}`);
  }
  
  // 로그 출력 제거 (프로덕션 최적화)
  
  // 계산 완료 플래그 해제
  window.isCalculatingAttackPower = false;
  
  const result = {
    integerAttack: totalIntegerAttack,
    percentAttack: totalPercentAttack,
    finalAttack: finalAttack,
    logs: logs,
    breakdown: {
      daevanionAttack: daevanionAttackTotal,
      daevanionArielAttack: daevanionArielAttackTotal,
      equipmentAttack: equipmentAttackTotal,
      equipmentAttackBase: equipmentAttackBase,
      equipmentTranscendAttack: equipmentTranscendAttack,
      transcendInteger: totalTranscendInteger,
      transcendPercent: totalTranscendPercent,
      destructionPercent: destructionPercent,
      powerPercent: powerPercent,
      normalStatPowerPercent: normalStatPowerPercent,
      soulPowerPercent: soulPowerPercent
    }
  };
  
  // 전역 변수에 저장 (표시용)
  window.attackPowerResult = result;
  
  // 공격력 표시 업데이트
  displayAttackPowerStats(result);
  
  // 전투 속도 계산 및 표시
  calculateCombatSpeed(equipment, accessories, statData, daevanionData, window.currentTitles || []);
  
  // 피해 증폭 계산 및 표시
  calculateDamageAmplification(equipment, accessories, daevanionData, window.currentTitles || []);
  
  // 치명타 계산 및 표시
  calculateCriticalHit(equipment, accessories, statData, daevanionData);
  
  // 강타 계산 및 표시 (타이틀, 지혜[루미엘])
  calculateStunHit(statData, window.currentTitles || []);
  
  // 완벽 계산 및 표시
  calculatePerfect(accessories, statData, window.currentTitles || []);
  
  // 다단 히트 적중 계산 및 표시
  calculateMultiHit(equipment, accessories, daevanionData);
  
  // 스킬 점수 계산 및 표시 (async)
  calculateSkillDamage(window.currentSkills || [], window.currentStigmas || []).catch(error => {
    console.error('[스킬 점수 계산] 오류:', error);
  });
  
  // 재사용 대기 시간 감소 계산 및 표시
  calculateCooldownReduction(statData, daevanionData, window.currentTitles || []);
  
  // DPS 점수 계산 및 표시 (모든 스탯 계산 완료 후)
  // 데바니온 데이터가 로드 중이면 나중에 updateAllDaevanionSkillPoints에서 호출됨
  // 데바니온 데이터가 이미 완전히 로드되었거나 로딩 중이 아닌 경우에만 여기서 호출
  // 검색 ID를 캡처하여 동시 검색 시 데이터 충돌 방지
  const capturedSearchId = window.currentSearchId;
  if (window.daevanionData && Object.keys(window.daevanionData).length >= 4) {
    // 데바니온 데이터가 이미 완전히 로드된 경우 (4개 보드 이상)
    setTimeout(() => {
      // 검색 ID가 변경되었으면 다른 캐릭터 검색이 진행 중이므로 무시
      if (capturedSearchId !== window.currentSearchId) return;
      calculateDpsScore(capturedSearchId);
    }, 200);
  } else if (!isUpdatingDaevanionPoints) {
    // 데바니온 데이터가 없고 로딩 중이 아닌 경우에만 계산
    setTimeout(() => {
      // 검색 ID가 변경되었으면 다른 캐릭터 검색이 진행 중이므로 무시
      if (capturedSearchId !== window.currentSearchId) return;
      calculateDpsScore(capturedSearchId);
    }, 200);
  }
  // 데바니온 데이터가 로딩 중이면 updateAllDaevanionSkillPoints에서 계산됨
  
  return result;
}

// 데바니온 데이터를 포함한 공격력 계산 (데바니온 데이터가 없을 수도 있음)
function calculateAttackPowerWithDaevanion(equipment, accessories, statData, daevanionData) {
  return calculateAttackPower(equipment, accessories, statData, daevanionData || null);
}

// 공격력 % 캡 계산 함수
function calculateAttackPowerCap() {
  // 초월 퍼센트, 파괴, 위력 값 가져오기
  const transcendPercent = parseFloat(document.getElementById('tooltip-equipment-transcend-percent')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
  const destructionPercent = parseFloat(document.getElementById('tooltip-destruction')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
  const powerPercent = parseFloat(document.getElementById('tooltip-power')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
  
  // 패시브 스킬로 인한 공격력 % 계산
  let passiveAttackPercent = 0;
  let passiveSkillName = '';
  let passiveSkillLevel = 0;
  
  const currentJob = window.currentJobName || '';
  const currentSkills = window.currentSkills || [];
  
  // 직업별 패시브 스킬 매핑
  const jobPassiveSkills = {
    '살성': { skillName: '공격 준비', percentPerLevel: 1 },
    '검성': { skillName: '공격 준비', percentPerLevel: 1 },
    '궁성': { skillName: '집중의 눈', percentPerLevel: 1.5 },
    '호법성': { skillName: '공격 준비', percentPerLevel: 1 },
    '마도성': { skillName: '불꽃의 로브', percentPerLevel: 1.5 },
    '정령성': { skillName: '정령 타격', percentPerLevel: 1 }
  };
  
  // 현재 직업의 패시브 스킬 확인
  const jobPassive = jobPassiveSkills[currentJob];
  if (jobPassive) {
    // 패시브 스킬 그룹에서 해당 스킬 찾기
    const passiveSkills = currentSkills.filter(skill => {
      const group = skill.group || '';
      return group.toLowerCase().includes('passive') || group === '패시브';
    });
    
    const targetSkill = passiveSkills.find(skill => skill.name === jobPassive.skillName);
    if (targetSkill) {
      passiveSkillLevel = targetSkill.level_int || parseInt(targetSkill.level || '0', 10) || 0;
      passiveAttackPercent = passiveSkillLevel * jobPassive.percentPerLevel;
      passiveSkillName = jobPassive.skillName;
    }
  }
  
  // 총 공격력 % 캡 계산
  const totalCapPercent = transcendPercent + destructionPercent + powerPercent + passiveAttackPercent;
  
  return {
    totalCapPercent,
    transcendPercent,
    destructionPercent,
    powerPercent,
    passiveAttackPercent,
    passiveSkillName,
    passiveSkillLevel,
    percentPerLevel: jobPassive ? jobPassive.percentPerLevel : 0
  };
}

// 공격력 % 캡 UI 업데이트 함수
function updateAttackPowerCapUI() {
  const capBadge = document.getElementById('attack-power-cap-badge');
  if (!capBadge) return;
  
  const capData = calculateAttackPowerCap();
  const { totalCapPercent } = capData;
  
  // 배지 표시
  capBadge.style.display = 'block';
  capBadge.textContent = `(보기) 공% 캡: ${totalCapPercent.toFixed(1)}%`;
  
  // 100% 이상이면 빨간색, 아니면 노란색
  if (totalCapPercent >= 100) {
    // 빨간색 배지
    capBadge.style.background = 'rgba(239, 68, 68, 0.15)';
    capBadge.style.color = '#ef4444';
    capBadge.style.border = '1px solid rgba(239, 68, 68, 0.3)';
  } else {
    // 노란색 배지
    capBadge.style.background = 'rgba(234, 179, 8, 0.15)';
    capBadge.style.color = '#eab308';
    capBadge.style.border = '1px solid rgba(234, 179, 8, 0.3)';
  }
}

// 공격력 정보 표시 함수
function displayAttackPowerStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const attackPowerValue = document.getElementById('attack-power-value');
  const sectionContainer = document.getElementById('dps-stats-info');
  const tooltipDaevanion = document.getElementById('tooltip-daevanion');
  const tooltipDaevanionAriel = document.getElementById('tooltip-daevanion-ariel');
  const tooltipEquipment = document.getElementById('tooltip-equipment');
  const tooltipDestruction = document.getElementById('tooltip-destruction');
  const tooltipPower = document.getElementById('tooltip-power');
  const attackPowerWarning = document.getElementById('attack-power-warning');
  
  if (!attackPowerValue || !sectionContainer) {
    return;
  }
  
  const { finalAttack, breakdown } = result;
  const { daevanionAttack, daevanionArielAttack, equipmentAttack, equipmentAttackBase, equipmentTranscendAttack, transcendInteger, transcendPercent, destructionPercent, powerPercent, normalStatPowerPercent, soulPowerPercent } = breakdown;
  
  // ★ 공격력 % 캡 계산 (100% 초과 시 캡 적용)
  // 패시브 스킬 공격력 %도 포함 (calculateAttackPowerCap에서 가져옴 - 단, UI 업데이트 전이라 직접 계산)
  let passiveAttackPercent = 0;
  const currentJob = window.currentJobName || '';
  const currentSkills = window.currentSkills || [];
  
  const jobPassiveSkills = {
    '살성': { skillName: '공격 준비', percentPerLevel: 1 },
    '검성': { skillName: '공격 준비', percentPerLevel: 1 },
    '궁성': { skillName: '집중의 눈', percentPerLevel: 1.5 },
    '호법성': { skillName: '공격 준비', percentPerLevel: 1 },
    '마도성': { skillName: '불꽃의 로브', percentPerLevel: 1.5 },
    '정령성': { skillName: '정령 타격', percentPerLevel: 1 }
  };
  
  const jobPassive = jobPassiveSkills[currentJob];
  if (jobPassive) {
    const passiveSkills = currentSkills.filter(skill => {
      const group = skill.group || '';
      return group.toLowerCase().includes('passive') || group === '패시브';
    });
    const targetSkill = passiveSkills.find(skill => skill.name === jobPassive.skillName);
    if (targetSkill) {
      const passiveSkillLevel = targetSkill.level_int || parseInt(targetSkill.level || '0', 10) || 0;
      passiveAttackPercent = passiveSkillLevel * jobPassive.percentPerLevel;
    }
  }
  
  const totalCapPercent = (transcendPercent || 0) + (destructionPercent || 0) + (normalStatPowerPercent || 0) + passiveAttackPercent;
  const CAP_LIMIT = 100; // 공격력 % 캡 한계
  
  let displayAttack = finalAttack;
  let cappedAttack = null;
  let isOverCap = false;
  
  if (totalCapPercent > CAP_LIMIT) {
    // 캡 초과: 실제 적용되는 공격력 계산
    // 현재 공격력: finalAttack = baseAttack * (1 + totalCapPercent/100)
    // 캡 적용 공격력: cappedAttack = baseAttack * (1 + CAP_LIMIT/100) = baseAttack * 2
    // 따라서: cappedAttack = finalAttack * (1 + CAP_LIMIT/100) / (1 + totalCapPercent/100)
    cappedAttack = Math.round(finalAttack * (1 + CAP_LIMIT / 100) / (1 + totalCapPercent / 100));
    isOverCap = true;
    
    // 전역 변수에 캡 적용 공격력 저장 (DPS 계산에서 사용)
    window.cappedAttackPower = cappedAttack;
    window.isAttackPowerOverCap = true;
  } else {
    window.cappedAttackPower = null;
    window.isAttackPowerOverCap = false;
  }
  
  // 최종 공격력 표시 (캡 초과 시 취소선 + 화살표 + 새 공격력)
  if (isOverCap && cappedAttack !== null) {
    attackPowerValue.innerHTML = `<span style="text-decoration: line-through; opacity: 0.6;">${finalAttack.toLocaleString()}</span> <span style="color: #9ca3af;">→</span> <span style="color: #fbbf24;">${cappedAttack.toLocaleString()}</span>`;
  } else {
    attackPowerValue.textContent = finalAttack.toLocaleString();
  }
  
  // 툴팁 내용 업데이트 (breakdown만)
  const tooltipEquipmentBase = document.getElementById('tooltip-equipment-base');
  const tooltipEquipmentTranscendInteger = document.getElementById('tooltip-equipment-transcend-integer');
  const tooltipEquipmentTranscendPercent = document.getElementById('tooltip-equipment-transcend-percent');
  
  if (tooltipDaevanion) tooltipDaevanion.textContent = `+${(daevanionAttack || 0).toLocaleString()}`;
  if (tooltipEquipmentBase) tooltipEquipmentBase.textContent = `+${(equipmentAttackBase || 0).toLocaleString()}`;
  
  // 초월 정수분 표시
  if (tooltipEquipmentTranscendInteger) {
    const transcendInt = transcendInteger || 0;
    tooltipEquipmentTranscendInteger.textContent = `+${transcendInt.toLocaleString()}`;
  }
  
  // 초월 퍼센트 표시
  if (tooltipEquipmentTranscendPercent) {
    const transcendPct = transcendPercent || 0;
    tooltipEquipmentTranscendPercent.textContent = `+${transcendPct.toFixed(1)}%`;
  }
  
  if (tooltipDestruction) tooltipDestruction.textContent = `+${destructionPercent.toFixed(1)}%`;
  if (tooltipPower) tooltipPower.textContent = `+${(normalStatPowerPercent || 0).toFixed(1)}%`;
  if (tooltipDaevanionAriel) tooltipDaevanionAriel.textContent = `+${(daevanionArielAttack || 0).toLocaleString()}`;
  
  // 섹션 표시
  sectionContainer.style.display = 'block';
  
  // 공격력 % 캡 UI 업데이트
  updateAttackPowerCapUI();
}

// 전투 속도 계산 함수 (로그 제거)
function calculateCombatSpeed(equipment, accessories, statData, daevanionData, titles) {
  let totalCombatSpeed = 0;
  let soulCombatSpeed = 0;
  let accessoryCombatSpeed = 0; // 장신구 기본 옵션 전투 속도
  let timeCombatSpeed = 0;
  let daevanionCombatSpeed = 0;
  
  const allItems = [...(equipment || []), ...(accessories || [])];
  allItems.forEach((item) => {
    const itemName = item.name || '알 수 없음';
    
    // 영혼 각인에서 전투 속도 추출 (sub_stats)
    if (item.sub_stats) {
      if (Array.isArray(item.sub_stats)) {
        item.sub_stats.forEach((stat) => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseFloat(stat.value || stat.amount || 0);
            
            if ((name.includes('전투 속도') || name.includes('전투속도') || name.includes('combat speed') || name.includes('combatspeed')) && value > 0) {
              soulCombatSpeed += value;
              totalCombatSpeed += value;
            }
          }
        });
      } else if (typeof item.sub_stats === 'object') {
        for (const key of Object.keys(item.sub_stats)) {
          const keyLower = key.toLowerCase();
          const value = parseFloat(item.sub_stats[key] || 0);
          
          if ((keyLower.includes('전투 속도') || keyLower.includes('전투속도') || keyLower.includes('combat speed') || keyLower.includes('combatspeed')) && value > 0) {
            soulCombatSpeed += value;
            totalCombatSpeed += value;
          }
        }
      }
    }
  });
  
  // 장신구 기본 옵션에서 전투 속도 추출 (main_stats)
  if (Array.isArray(accessories) && accessories.length > 0) {
    accessories.forEach((accessory) => {
      const accessoryName = accessory.name || '알 수 없음';
      
      if (accessory.main_stats) {
        if (Array.isArray(accessory.main_stats)) {
          accessory.main_stats.forEach((stat) => {
            if (typeof stat === 'object' && stat !== null) {
              const name = (stat.name || stat.type || '').toLowerCase();
              const value = parseFloat(stat.value || stat.minValue || 0);
              
              if ((name.includes('전투 속도') || name.includes('전투속도') || name.includes('combat speed') || name.includes('combatspeed')) && value > 0) {
                accessoryCombatSpeed += value;
                totalCombatSpeed += value;
              }
            }
          });
        } else if (typeof accessory.main_stats === 'object') {
          for (const key of Object.keys(accessory.main_stats)) {
            const keyLower = key.toLowerCase();
            const value = parseFloat(accessory.main_stats[key] || 0);
            
            if ((keyLower.includes('전투 속도') || keyLower.includes('전투속도') || keyLower.includes('combat speed') || keyLower.includes('combatspeed')) && value > 0) {
              accessoryCombatSpeed += value;
              totalCombatSpeed += value;
            }
          }
        }
      }
    });
  }
  
  if (statData && statData.statList) {
    const timeStat = statData.statList.find(stat => 
      stat.type === 'Time' || (stat.name && (stat.name.includes('시간') || stat.name.includes('Time') || stat.name.includes('시엘')))
    );
    
    if (timeStat) {
      // 시간 스탯의 값 찾기 (스탯 1당 0.2%, 2배 적용)
      const timeValue = parseInt(timeStat.value || 0);
      if (timeValue > 0) {
        timeCombatSpeed = timeValue * 0.2; // 스탯 1당 0.2%
        totalCombatSpeed += timeCombatSpeed;
      }
    }
  }
  
  if (daevanionData && daevanionData[41]) {
    const boardData = daevanionData[41];
    let boardCombatSpeed = 0;
    
    if (boardData && boardData.nodeList) {
      const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
      
      activeNodes.forEach((node) => {
        let nodeCombatSpeed = 0;
        
        for (const key in node) {
          const value = node[key];
          
          if (typeof value === 'string' && value.trim()) {
            const text = value;
            let matches = text.match(/전투\s*속도\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            if (!matches) {
              matches = text.match(/전투속도\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            if (!matches) {
              matches = text.match(/combat\s*speed\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            
            if (matches) {
              matches.forEach(match => {
                const numMatch = match.match(/(\d+\.?\d*)/);
                if (numMatch) {
                  const speedValue = parseFloat(numMatch[1]) || 0;
                  if (speedValue > 0) {
                    nodeCombatSpeed += speedValue;
                  }
                }
              });
            }
          }
          
          if (Array.isArray(value) && value.length > 0) {
            value.forEach((item) => {
              if (typeof item === 'object' && item !== null) {
                for (const itemKey in item) {
                  const itemValue = item[itemKey];
                  if (typeof itemValue === 'string' && itemValue.trim()) {
                    let matches = itemValue.match(/전투\s*속도\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    if (!matches) {
                      matches = itemValue.match(/전투속도\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    if (!matches) {
                      matches = itemValue.match(/combat\s*speed\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    
                    if (matches) {
                      matches.forEach(match => {
                        const numMatch = match.match(/(\d+\.?\d*)/);
                        if (numMatch) {
                          const speedValue = parseFloat(numMatch[1]) || 0;
                          if (speedValue > 0) {
                            nodeCombatSpeed += speedValue;
                          }
                        }
                      });
                    }
                  }
                  
                  if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                    const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                    if (itemName.includes('전투 속도') || itemName.includes('전투속도') || itemName.includes('combat speed')) {
                      nodeCombatSpeed += itemValue;
                    }
                  }
                }
              }
            });
          }
        }
        
        if (nodeCombatSpeed > 0) {
          boardCombatSpeed += nodeCombatSpeed;
        }
      });
      
      if (boardCombatSpeed > 0) {
        daevanionCombatSpeed = boardCombatSpeed;
        totalCombatSpeed += boardCombatSpeed;
      }
    }
  }
  
  // 타이틀에서 전투 속도 추출
  let titleCombatSpeed = 0;
  if (titles && Array.isArray(titles) && titles.length > 0) {
    titles.forEach((title) => {
      if (title && title.equip_effects && Array.isArray(title.equip_effects)) {
        title.equip_effects.forEach((effect) => {
          if (typeof effect === 'string') {
            // "전투 속도 +3.5%" 형식 찾기
            const match = effect.match(/전투\s*속도\s*[+＋]\s*(\d+\.?\d*)\s*%/i);
            if (match) {
              const speedValue = parseFloat(match[1]) || 0;
              if (speedValue > 0) {
                titleCombatSpeed += speedValue;
                totalCombatSpeed += speedValue;
              }
            }
          }
        });
      }
    });
  }
  
  const result = {
    totalCombatSpeed: totalCombatSpeed,
    breakdown: {
      soulCombatSpeed: soulCombatSpeed,
      accessoryCombatSpeed: accessoryCombatSpeed,
      timeCombatSpeed: timeCombatSpeed,
      daevanionCombatSpeed: daevanionCombatSpeed,
      titleCombatSpeed: titleCombatSpeed
    }
  };
  
  window.combatSpeedResult = result;
  displayCombatSpeedStats(result);
  
  return result;
}

// 피해 증폭 계산 함수 (4가지 피해 증폭을 각각 추적: 무기 피해 증폭, PVE 피해 증폭, 피해 증폭, 치명타 피해 증폭)
function calculateDamageAmplification(equipment, accessories, daevanionData, titles) {
  
  // 4가지 피해 증폭을 각각 추적
  // 1. 무기 피해 증폭
  let weaponDamageAmpPercent = 0;
  let weaponDamageAmpInteger = 0;
  let weaponSoulPercent = 0;
  let weaponEquipmentBasePercent = 0;
  let weaponStoneInteger = 0;
  let weaponDaevanionPercent = 0;
  let weaponDaevanionArielPercent = 0;
  let weaponTitlePercent = 0;
  
  // 2. PVE 피해 증폭
  let pveDamageAmpPercent = 0;
  let pveDamageAmpInteger = 0;
  let pveSoulPercent = 0;
  let pveEquipmentBasePercent = 0;
  let pveStoneInteger = 0;
  let pveDaevanionPercent = 0;
  let pveDaevanionArielPercent = 0;
  let pveTitlePercent = 0;
  
  // 3. 피해 증폭 (일반)
  let damageAmpPercent = 0;
  let damageAmpInteger = 0;
  let damageAmpSoulPercent = 0;
  let damageAmpEquipmentBasePercent = 0;
  let damageAmpStoneInteger = 0;
  let damageAmpDaevanionPercent = 0;
  let damageAmpDaevanionArielPercent = 0;
  let damageAmpTitlePercent = 0;
  
  // 4. 치명타 피해 증폭
  let criticalDamageAmpPercent = 0;
  let criticalDamageAmpInteger = 0;
  let criticalSoulPercent = 0;
  let criticalEquipmentBasePercent = 0;
  let criticalStoneInteger = 0;
  let criticalDaevanionPercent = 0;
  let criticalDaevanionArielPercent = 0;
  let criticalTitlePercent = 0;
  
  // 키워드 정의
  const weaponDamageAmpKeywords = ['무기 피해 증폭', '무기피해증폭', 'weapon damage amplification'];
  const pveDamageAmpKeywords = ['pve 피해 증폭', 'pve피해증폭', 'pve damage amplification'];
  const damageAmpKeywords = ['피해 증폭', 'damage amplification'];
  const criticalDamageAmpKeywords = ['치명타 피해 증폭', '치명타피해증폭', 'critical damage amplification'];
  
  // 장비 기본 옵션용 키워드
  const equipmentBaseWeaponKeywords = ['무기 피해 증폭', '무기피해증폭', 'weapon damage amplification'];
  const equipmentBasePveKeywords = ['pve 피해 증폭', 'pve피해증폭', 'pve damage amplification'];
  
  // 1. 장비 영혼 각인에서 피해 증폭 추출 (퍼센트) - 공격력 계산과 동일한 방식
  const allItems = [...(equipment || []), ...(accessories || [])];
  
  allItems.forEach((item, itemIndex) => {
    const itemName = item.name || '알 수 없음';
    
    // subStats (영혼 각인)에서 피해 증폭 추출 - 4가지 피해 증폭을 각각 추적
    if (item.sub_stats) {
      if (Array.isArray(item.sub_stats)) {
        item.sub_stats.forEach((stat, statIndex) => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseFloat(stat.value || stat.amount || 0);
            
            // 4가지 피해 증폭을 구분하여 추출
            if (value > 0) {
              if (weaponDamageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                weaponSoulPercent += value;
                weaponDamageAmpPercent += value;
              } else if (pveDamageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                pveSoulPercent += value;
                pveDamageAmpPercent += value;
              } else if (criticalDamageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                criticalSoulPercent += value;
                criticalDamageAmpPercent += value;
              } else if (damageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                // "피해 증폭"은 다른 키워드와 겹치지 않을 때만 (예: "무기 피해 증폭"이 아닐 때)
                if (!name.includes('무기') && !name.includes('pve') && !name.includes('치명타') && !name.includes('weapon') && !name.includes('critical')) {
                  damageAmpSoulPercent += value;
                  damageAmpPercent += value;
                }
              }
            }
          }
        });
      } else if (typeof item.sub_stats === 'object') {
        for (const key of Object.keys(item.sub_stats)) {
          const keyLower = key.toLowerCase();
          const value = parseFloat(item.sub_stats[key] || 0);
          
          // 4가지 피해 증폭을 구분하여 추출
          if (value > 0) {
            if (weaponDamageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              weaponSoulPercent += value;
              weaponDamageAmpPercent += value;
            } else if (pveDamageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              pveSoulPercent += value;
              pveDamageAmpPercent += value;
            } else if (criticalDamageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              criticalSoulPercent += value;
              criticalDamageAmpPercent += value;
            } else if (damageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              // "피해 증폭"은 다른 키워드와 겹치지 않을 때만
              if (!keyLower.includes('무기') && !keyLower.includes('pve') && !keyLower.includes('치명타') && !keyLower.includes('weapon') && !keyLower.includes('critical')) {
                damageAmpSoulPercent += value;
                damageAmpPercent += value;
              }
            }
          }
        }
      }
    }
    
    // main_stats (기본 옵션)에서 피해 증폭 추출 (퍼센트) - 4가지 피해 증폭을 각각 추적
    if (item.main_stats) {
      if (Array.isArray(item.main_stats)) {
        item.main_stats.forEach((stat) => {
          if (typeof stat === 'object' && stat !== null) {
            const name = (stat.name || stat.type || '').toLowerCase();
            const statValue = stat.value || stat.minValue || '';
            const statExtra = stat.extra || '';
            
            // 키워드 매칭 확인 및 값 추출
            let totalValue = 0;
            
            // value에서 기본 값 추출
            if (typeof statValue === 'string') {
              // "0.5% (+1.5%)" 또는 "0.5 (+1.5)" 형태 파싱
              const match = statValue.match(/(\d+\.?\d*)\s*%?\s*\(\+\s*(\d+\.?\d*)\s*%?\)/);
              if (match) {
                totalValue = parseFloat(match[1]) || 0;
                const bonusValue = parseFloat(match[2]) || 0;
                totalValue += bonusValue;
              } else {
                // 괄호가 없는 경우 일반 파싱
                const numMatch = statValue.match(/(\d+\.?\d*)/);
                if (numMatch) {
                  totalValue = parseFloat(numMatch[1]) || 0;
                }
              }
            } else {
              // 숫자인 경우
              totalValue = parseFloat(statValue) || 0;
            }
            
            // extra에서 추가 값 추출 (공격력 계산과 동일한 방식)
            if (statExtra && statExtra !== '0' && statExtra !== 0 && statExtra !== '0%') {
              if (typeof statExtra === 'string') {
                // "+1.5%" 또는 "+1.5" 형태 파싱
                const extraMatch = statExtra.match(/\+?\s*(\d+\.?\d*)\s*%?/);
                if (extraMatch) {
                  const extraValue = parseFloat(extraMatch[1]) || 0;
                  totalValue += extraValue;
                }
              } else {
                // 숫자인 경우
                const extraValue = parseFloat(statExtra) || 0;
                totalValue += extraValue;
              }
            }
            
            // 4가지 피해 증폭을 구분하여 추가
            if (totalValue > 0) {
              if (equipmentBaseWeaponKeywords.some(keyword => name.includes(keyword))) {
                weaponEquipmentBasePercent += totalValue;
                weaponDamageAmpPercent += totalValue;
              } else if (equipmentBasePveKeywords.some(keyword => name.includes(keyword))) {
                pveEquipmentBasePercent += totalValue;
                pveDamageAmpPercent += totalValue;
              }
            }
          }
        });
      } else if (typeof item.main_stats === 'object') {
        for (const key of Object.keys(item.main_stats)) {
          const keyLower = key.toLowerCase();
          const rawValue = item.main_stats[key];
          
          // 키워드 매칭 확인 및 값 추출
          let totalValue = 0;
          
          // 값이 문자열인 경우 괄호 안의 값도 파싱 (예: "0.5% (+1.5%)")
          if (typeof rawValue === 'string') {
            // "0.5% (+1.5%)" 또는 "0.5 (+1.5)" 형태 파싱
            const match = rawValue.match(/(\d+\.?\d*)\s*%?\s*\(\+\s*(\d+\.?\d*)\s*%?\)/);
            if (match) {
              totalValue = parseFloat(match[1]) || 0;
              const bonusValue = parseFloat(match[2]) || 0;
              totalValue += bonusValue;
            } else {
              // 괄호가 없는 경우 일반 파싱
              const numMatch = rawValue.match(/(\d+\.?\d*)/);
              if (numMatch) {
                totalValue = parseFloat(numMatch[1]) || 0;
              }
            }
          } else {
            // 숫자인 경우
            totalValue = parseFloat(rawValue) || 0;
          }
          
          // extra 필드가 별도로 있는 경우 확인
          const extraKey = key + '_extra';
          if (item.main_stats[extraKey]) {
            const extraValue = item.main_stats[extraKey];
            if (typeof extraValue === 'string') {
              const extraMatch = extraValue.match(/\+?\s*(\d+\.?\d*)\s*%?/);
              if (extraMatch) {
                totalValue += parseFloat(extraMatch[1]) || 0;
              }
            } else {
              totalValue += parseFloat(extraValue) || 0;
            }
          }
          
          // 4가지 피해 증폭을 구분하여 추가
          if (totalValue > 0) {
            if (equipmentBaseWeaponKeywords.some(keyword => keyLower.includes(keyword))) {
              weaponEquipmentBasePercent += totalValue;
              weaponDamageAmpPercent += totalValue;
            } else if (equipmentBasePveKeywords.some(keyword => keyLower.includes(keyword))) {
              pveEquipmentBasePercent += totalValue;
              pveDamageAmpPercent += totalValue;
            }
          }
        }
      }
    }
    
    // magic_stone_stat (마석 각인)에서 피해 증폭 추출 (정수) - 4가지 피해 증폭을 각각 추적
    if (item.magic_stone_stat) {
      if (Array.isArray(item.magic_stone_stat)) {
        item.magic_stone_stat.forEach((stat, statIndex) => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseInt(stat.value || stat.amount || 0);
            
            // 4가지 피해 증폭을 구분하여 추출
            if (value > 0) {
              if (weaponDamageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                weaponStoneInteger += value;
                weaponDamageAmpInteger += value;
              } else if (pveDamageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                pveStoneInteger += value;
                pveDamageAmpInteger += value;
              } else if (criticalDamageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                criticalStoneInteger += value;
                criticalDamageAmpInteger += value;
              } else if (damageAmpKeywords.some(keyword => name.includes(keyword.toLowerCase()))) {
                // "피해 증폭"은 다른 키워드와 겹치지 않을 때만
                if (!name.includes('무기') && !name.includes('pve') && !name.includes('치명타') && !name.includes('weapon') && !name.includes('critical')) {
                  damageAmpStoneInteger += value;
                  damageAmpInteger += value;
                }
              }
            }
          }
        });
      } else if (typeof item.magic_stone_stat === 'object') {
        for (const key of Object.keys(item.magic_stone_stat)) {
          const keyLower = key.toLowerCase();
          const value = parseInt(item.magic_stone_stat[key] || 0);
          
          // 4가지 피해 증폭을 구분하여 추출
          if (value > 0) {
            if (weaponDamageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              weaponStoneInteger += value;
              weaponDamageAmpInteger += value;
            } else if (pveDamageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              pveStoneInteger += value;
              pveDamageAmpInteger += value;
            } else if (criticalDamageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              criticalStoneInteger += value;
              criticalDamageAmpInteger += value;
            } else if (damageAmpKeywords.some(keyword => keyLower.includes(keyword.toLowerCase()))) {
              // "피해 증폭"은 다른 키워드와 겹치지 않을 때만
              if (!keyLower.includes('무기') && !keyLower.includes('pve') && !keyLower.includes('치명타') && !keyLower.includes('weapon') && !keyLower.includes('critical')) {
                damageAmpStoneInteger += value;
                damageAmpInteger += value;
              }
            }
          }
        }
      }
    }
  });
  
  // 2. 데바니온 지켈(42)과 바이젤(43) 보드에서 피해 증폭 추출
  // 지켈(42): 무기 피해 증폭, PVE 피해 증폭, 피해 증폭
  // 바이젤(43): 치명타 피해 증폭
  const daevanionBoardIds = [42, 43]; // 지켈, 바이젤
  const daevanionBoardNames = { 42: '지켈', 43: '바이젤' };
  
  if (daevanionData) {
    
    daevanionBoardIds.forEach(boardId => {
      const boardName = daevanionBoardNames[boardId] || `보드${boardId}`;
      const boardData = daevanionData[boardId];
      const isZikel = (boardId === 42);  // 지켈 보드
      const isVaizel = (boardId === 43); // 바이젤 보드
      
      let boardWeaponAmp = 0;
      let boardPveAmp = 0;
      let boardDamageAmp = 0;
      let boardCriticalAmp = 0;
      
      if (boardData && boardData.nodeList) {
        const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
        activeNodes.forEach((node, nodeIndex) => {
          let nodeWeaponAmp = 0;
          let nodePveAmp = 0;
          let nodeDamageAmp = 0;
          let nodeCriticalAmp = 0;
          let foundInField = null;
          
          // 노드의 모든 필드를 순회하며 검색
          for (const key in node) {
            const value = node[key];
            
            // 문자열인 경우 패턴 검색
            if (typeof value === 'string' && value.trim()) {
              const text = value;
              
              // 지켈에서는: 무기 피해 증폭, PVE 피해 증폭, 피해 증폭 검색
              if (isZikel) {
                // 무기 피해 증폭 패턴 검색
                let weaponMatches = text.match(/무기\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                if (!weaponMatches) {
                  weaponMatches = text.match(/무기피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (!weaponMatches) {
                  weaponMatches = text.match(/weapon\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (weaponMatches) {
                  weaponMatches.forEach(match => {
                    const numMatch = match.match(/(\d+\.?\d*)/);
                    if (numMatch) {
                      const ampValue = parseFloat(numMatch[1]) || 0;
                      if (ampValue > 0) {
                        nodeWeaponAmp += ampValue;
                        if (!foundInField) foundInField = key;
                      }
                    }
                  });
                }
                
                // PVE 피해 증폭 패턴 검색
                let pveMatches = text.match(/pve\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                if (!pveMatches) {
                  pveMatches = text.match(/pve피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (!pveMatches) {
                  pveMatches = text.match(/pve\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (pveMatches) {
                  pveMatches.forEach(match => {
                    const numMatch = match.match(/(\d+\.?\d*)/);
                    if (numMatch) {
                      const ampValue = parseFloat(numMatch[1]) || 0;
                      if (ampValue > 0) {
                        nodePveAmp += ampValue;
                        if (!foundInField) foundInField = key;
                      }
                    }
                  });
                }
                
                // 피해 증폭 패턴 검색 (다른 키워드와 겹치지 않을 때만)
                let damageMatches = text.match(/피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                if (!damageMatches) {
                  damageMatches = text.match(/피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (!damageMatches) {
                  damageMatches = text.match(/damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (damageMatches) {
                  damageMatches.forEach(match => {
                    const matchLower = match.toLowerCase();
                    // 다른 키워드와 겹치지 않을 때만 추가
                    if (!matchLower.includes('무기') && !matchLower.includes('pve') && !matchLower.includes('치명타') && !matchLower.includes('weapon') && !matchLower.includes('critical')) {
                      const numMatch = match.match(/(\d+\.?\d*)/);
                      if (numMatch) {
                        const ampValue = parseFloat(numMatch[1]) || 0;
                        if (ampValue > 0) {
                          nodeDamageAmp += ampValue;
                          if (!foundInField) foundInField = key;
                        }
                      }
                    }
                  });
                }
              }
              
              // 바이젤에서는: 치명타 피해 증폭만 검색
              if (isVaizel) {
                // 치명타 피해 증폭 패턴 검색
                let criticalMatches = text.match(/치명타\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                if (!criticalMatches) {
                  criticalMatches = text.match(/치명타피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (!criticalMatches) {
                  criticalMatches = text.match(/critical\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (criticalMatches) {
                  criticalMatches.forEach(match => {
                    const numMatch = match.match(/(\d+\.?\d*)/);
                    if (numMatch) {
                      const ampValue = parseFloat(numMatch[1]) || 0;
                      if (ampValue > 0) {
                        nodeCriticalAmp += ampValue;
                        if (!foundInField) foundInField = key;
                      }
                    }
                  });
                }
              }
            }
            
            // 배열인 경우 (statList, effectList 등) - 4가지 피해 증폭을 각각 추적
            if (Array.isArray(value) && value.length > 0) {
              value.forEach((item, itemIndex) => {
                if (typeof item === 'object' && item !== null) {
                  // 객체의 모든 필드 검색
                  for (const itemKey in item) {
                    const itemValue = item[itemKey];
                    if (typeof itemValue === 'string' && itemValue.trim()) {
                      // 무기 피해 증폭
                      let weaponMatches = itemValue.match(/무기\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      if (!weaponMatches) {
                        weaponMatches = itemValue.match(/무기피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (!weaponMatches) {
                        weaponMatches = itemValue.match(/weapon\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (weaponMatches) {
                        weaponMatches.forEach(match => {
                          const numMatch = match.match(/(\d+\.?\d*)/);
                          if (numMatch) {
                            const ampValue = parseFloat(numMatch[1]) || 0;
                            if (ampValue > 0) {
                              nodeWeaponAmp += ampValue;
                              if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                            }
                          }
                        });
                      }
                      
                      // PVE 피해 증폭
                      let pveMatches = itemValue.match(/pve\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      if (!pveMatches) {
                        pveMatches = itemValue.match(/pve피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (!pveMatches) {
                        pveMatches = itemValue.match(/pve\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (pveMatches) {
                        pveMatches.forEach(match => {
                          const numMatch = match.match(/(\d+\.?\d*)/);
                          if (numMatch) {
                            const ampValue = parseFloat(numMatch[1]) || 0;
                            if (ampValue > 0) {
                              nodePveAmp += ampValue;
                              if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                            }
                          }
                        });
                      }
                      
                      // 치명타 피해 증폭
                      let criticalMatches = itemValue.match(/치명타\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      if (!criticalMatches) {
                        criticalMatches = itemValue.match(/치명타피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (!criticalMatches) {
                        criticalMatches = itemValue.match(/critical\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (criticalMatches) {
                        criticalMatches.forEach(match => {
                          const numMatch = match.match(/(\d+\.?\d*)/);
                          if (numMatch) {
                            const ampValue = parseFloat(numMatch[1]) || 0;
                            if (ampValue > 0) {
                              nodeCriticalAmp += ampValue;
                              if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                            }
                          }
                        });
                      }
                      
                      // 피해 증폭 (다른 키워드와 겹치지 않을 때만)
                      let damageMatches = itemValue.match(/피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      if (!damageMatches) {
                        damageMatches = itemValue.match(/피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (!damageMatches) {
                        damageMatches = itemValue.match(/damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                      }
                      if (damageMatches) {
                        damageMatches.forEach(match => {
                          const matchLower = match.toLowerCase();
                          if (!matchLower.includes('무기') && !matchLower.includes('pve') && !matchLower.includes('치명타') && !matchLower.includes('weapon') && !matchLower.includes('critical')) {
                            const numMatch = match.match(/(\d+\.?\d*)/);
                            if (numMatch) {
                              const ampValue = parseFloat(numMatch[1]) || 0;
                              if (ampValue > 0) {
                                nodeDamageAmp += ampValue;
                                if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                              }
                            }
                          }
                        });
                      }
                    }
                    
                    // value나 amount 필드가 숫자인 경우
                    if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                      const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                      if (weaponDamageAmpKeywords.some(keyword => itemName.includes(keyword.toLowerCase()))) {
                        nodeWeaponAmp += itemValue;
                        if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                      } else if (pveDamageAmpKeywords.some(keyword => itemName.includes(keyword.toLowerCase()))) {
                        nodePveAmp += itemValue;
                        if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                      } else if (criticalDamageAmpKeywords.some(keyword => itemName.includes(keyword.toLowerCase()))) {
                        nodeCriticalAmp += itemValue;
                        if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                      } else if (damageAmpKeywords.some(keyword => itemName.includes(keyword.toLowerCase()))) {
                        if (!itemName.includes('무기') && !itemName.includes('pve') && !itemName.includes('치명타') && !itemName.includes('weapon') && !itemName.includes('critical')) {
                          nodeDamageAmp += itemValue;
                          if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                        }
                      }
                    }
                  }
                }
              });
            }
            
            // 객체인 경우 재귀적으로 검색 - 4가지 피해 증폭을 각각 추적
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
              for (const subKey in value) {
                const subValue = value[subKey];
                if (typeof subValue === 'string' && subValue.trim()) {
                  // 무기 피해 증폭
                  let weaponMatches = subValue.match(/무기\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  if (!weaponMatches) {
                    weaponMatches = subValue.match(/무기피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (!weaponMatches) {
                    weaponMatches = subValue.match(/weapon\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (weaponMatches) {
                    weaponMatches.forEach(match => {
                      const numMatch = match.match(/(\d+\.?\d*)/);
                      if (numMatch) {
                        const ampValue = parseFloat(numMatch[1]) || 0;
                        if (ampValue > 0) {
                          nodeWeaponAmp += ampValue;
                          if (!foundInField) foundInField = `${key}.${subKey}`;
                        }
                      }
                    });
                  }
                  
                  // PVE 피해 증폭
                  let pveMatches = subValue.match(/pve\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  if (!pveMatches) {
                    pveMatches = subValue.match(/pve피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (!pveMatches) {
                    pveMatches = subValue.match(/pve\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (pveMatches) {
                    pveMatches.forEach(match => {
                      const numMatch = match.match(/(\d+\.?\d*)/);
                      if (numMatch) {
                        const ampValue = parseFloat(numMatch[1]) || 0;
                        if (ampValue > 0) {
                          nodePveAmp += ampValue;
                          if (!foundInField) foundInField = `${key}.${subKey}`;
                        }
                      }
                    });
                  }
                  
                  // 치명타 피해 증폭
                  let criticalMatches = subValue.match(/치명타\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  if (!criticalMatches) {
                    criticalMatches = subValue.match(/치명타피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (!criticalMatches) {
                    criticalMatches = subValue.match(/critical\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (criticalMatches) {
                    criticalMatches.forEach(match => {
                      const numMatch = match.match(/(\d+\.?\d*)/);
                      if (numMatch) {
                        const ampValue = parseFloat(numMatch[1]) || 0;
                        if (ampValue > 0) {
                          nodeCriticalAmp += ampValue;
                          if (!foundInField) foundInField = `${key}.${subKey}`;
                        }
                      }
                    });
                  }
                  
                  // 피해 증폭 (다른 키워드와 겹치지 않을 때만)
                  let damageMatches = subValue.match(/피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  if (!damageMatches) {
                    damageMatches = subValue.match(/피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (!damageMatches) {
                    damageMatches = subValue.match(/damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                  }
                  if (damageMatches) {
                    damageMatches.forEach(match => {
                      const matchLower = match.toLowerCase();
                      if (!matchLower.includes('무기') && !matchLower.includes('pve') && !matchLower.includes('치명타') && !matchLower.includes('weapon') && !matchLower.includes('critical')) {
                        const numMatch = match.match(/(\d+\.?\d*)/);
                        if (numMatch) {
                          const ampValue = parseFloat(numMatch[1]) || 0;
                          if (ampValue > 0) {
                            nodeDamageAmp += ampValue;
                            if (!foundInField) foundInField = `${key}.${subKey}`;
                          }
                        }
                      }
                    });
                  }
                }
              }
            }
          }
          
          // 노드별 합계를 보드 합계에 추가
          if (nodeWeaponAmp > 0) {
            boardWeaponAmp += nodeWeaponAmp;
          }
          if (nodePveAmp > 0) {
            boardPveAmp += nodePveAmp;
          }
          if (nodeDamageAmp > 0) {
            boardDamageAmp += nodeDamageAmp;
          }
          if (nodeCriticalAmp > 0) {
            boardCriticalAmp += nodeCriticalAmp;
          }
        });
        
        // 보드별 합계를 전체 합계에 추가 (보드별 필터링 적용)
        // 지켈(42): 무기 피해 증폭, PVE 피해 증폭, 피해 증폭
        if (isZikel) {
          if (boardWeaponAmp > 0) {
            weaponDaevanionPercent += boardWeaponAmp;
            weaponDamageAmpPercent += boardWeaponAmp;
          }
          if (boardPveAmp > 0) {
            pveDaevanionPercent += boardPveAmp;
            pveDamageAmpPercent += boardPveAmp;
          }
          if (boardDamageAmp > 0) {
            damageAmpDaevanionPercent += boardDamageAmp;
            damageAmpPercent += boardDamageAmp;
          }
        }
        
        // 바이젤(43): 치명타 피해 증폭만
        if (isVaizel) {
          if (boardCriticalAmp > 0) {
            criticalDaevanionPercent += boardCriticalAmp;
            criticalDamageAmpPercent += boardCriticalAmp;
          }
        }
      }
    });
  }
  
  // 2-1. 데바니온 아리엘 보드에서 PVE 피해 증폭, 보스 피해 증폭 추출 (PVE 피해 증폭에만 추가)
  let daevanionArielPveAmp = 0;
  
  if (daevanionData && daevanionData[45]) {
    const boardData = daevanionData[45];
    let boardArielPveAmp = 0;
    
    if (boardData && boardData.nodeList) {
      const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
      
      activeNodes.forEach((node, nodeIndex) => {
        let nodeArielPveAmp = 0;
        let foundInField = null;
        
        // 노드의 모든 필드를 순회하며 검색
        for (const key in node) {
          const value = node[key];
          
          // 문자열인 경우 패턴 검색 (PVE 피해 증폭, 보스 피해 증폭)
          if (typeof value === 'string' && value.trim()) {
            const text = value;
            
            // "PVE 피해 증폭 +X%", "보스 피해 증폭 +X%", "보스 피해 증가 +X%" 패턴 검색
            let matches = text.match(/(?:PVE\s*피해\s*증폭|보스\s*피해\s*증폭|보스\s*피해\s*증가)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            if (!matches) {
              matches = text.match(/(?:PVE피해증폭|보스피해증폭|보스피해증가)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            if (!matches) {
              matches = text.match(/(?:pve\s*damage\s*amplification|boss\s*damage\s*amplification|boss\s*damage\s*increase)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            
            if (matches) {
              matches.forEach(match => {
                const numMatch = match.match(/(\d+\.?\d*)/);
                if (numMatch) {
                  const ampValue = parseFloat(numMatch[1]) || 0;
                  if (ampValue > 0) {
                    nodeArielPveAmp += ampValue;
                    if (!foundInField) foundInField = key;
                  }
                }
              });
            }
          }
          
          // 배열인 경우
          if (Array.isArray(value) && value.length > 0) {
            value.forEach((item, itemIndex) => {
              if (typeof item === 'object' && item !== null) {
                for (const itemKey in item) {
                  const itemValue = item[itemKey];
                  if (typeof itemValue === 'string' && itemValue.trim()) {
                    let matches = itemValue.match(/(?:PVE\s*피해\s*증폭|보스\s*피해\s*증폭|보스\s*피해\s*증가)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    if (!matches) {
                      matches = itemValue.match(/(?:PVE피해증폭|보스피해증폭|보스피해증가)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    if (!matches) {
                      matches = itemValue.match(/(?:pve\s*damage\s*amplification|boss\s*damage\s*amplification|boss\s*damage\s*increase)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    
                    if (matches) {
                      matches.forEach(match => {
                        const numMatch = match.match(/(\d+\.?\d*)/);
                        if (numMatch) {
                          const ampValue = parseFloat(numMatch[1]) || 0;
                          if (ampValue > 0) {
                            nodeArielPveAmp += ampValue;
                            if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                          }
                        }
                      });
                    }
                  }
                  
                  // value나 amount 필드가 숫자인 경우
                  if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                    const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                    if (itemName.includes('pve 피해 증폭') || itemName.includes('보스 피해 증폭') || itemName.includes('보스 피해 증가') || 
                        itemName.includes('pve damage amplification') || itemName.includes('boss damage amplification') || itemName.includes('boss damage increase')) {
                      nodeArielPveAmp += itemValue;
                      if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                    }
                  }
                }
              }
            });
          }
          
          // 객체인 경우 재귀적으로 검색
          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            for (const subKey in value) {
              const subValue = value[subKey];
              if (typeof subValue === 'string' && subValue.trim()) {
                let matches = subValue.match(/(?:PVE\s*피해\s*증폭|보스\s*피해\s*증폭|보스\s*피해\s*증가)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                if (!matches) {
                  matches = subValue.match(/(?:PVE피해증폭|보스피해증폭|보스피해증가)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                if (!matches) {
                  matches = subValue.match(/(?:pve\s*damage\s*amplification|boss\s*damage\s*amplification|boss\s*damage\s*increase)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                }
                
                if (matches) {
                  matches.forEach(match => {
                    const numMatch = match.match(/(\d+\.?\d*)/);
                    if (numMatch) {
                      const ampValue = parseFloat(numMatch[1]) || 0;
                      if (ampValue > 0) {
                        nodeArielPveAmp += ampValue;
                        if (!foundInField) foundInField = `${key}.${subKey}`;
                      }
                    }
                  });
                }
              }
            }
          }
        }
        
        if (nodeArielPveAmp > 0) {
          boardArielPveAmp += nodeArielPveAmp;
        }
      });
      
      if (boardArielPveAmp > 0) {
        daevanionArielPveAmp = boardArielPveAmp;
      }
    }
  }
  
  if (daevanionArielPveAmp > 0) {
    pveDaevanionArielPercent = daevanionArielPveAmp;
    pveDamageAmpPercent += daevanionArielPveAmp;
  } else if (daevanionData && daevanionData[45]) {
    pveDaevanionArielPercent = 0;
  }
  
  // 3. 타이틀 장착 효과에서 피해 증폭 추출 (PVP 피해 증폭 제외, 4가지 피해 증폭을 각각 추적)
  if (titles && Array.isArray(titles)) {
    titles.forEach((title) => {
      const titleName = title.name || '알 수 없음';
      
      if (title.equip_effects && Array.isArray(title.equip_effects)) {
        title.equip_effects.forEach((effect) => {
          const effectText = String(effect || '').toLowerCase();
          
          // PVP 피해 증폭은 제외 (PVE 전투 점수 계산이므로)
          if (effectText.includes('pvp 피해 증폭') || effectText.includes('pvp피해증폭') || effectText.includes('pvp damage amplification')) {
            return; // PVP 피해 증폭은 건너뛰기
          }
          
          // 무기 피해 증폭
          let weaponMatches = effectText.match(/무기\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          if (!weaponMatches) {
            weaponMatches = effectText.match(/무기피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          if (!weaponMatches) {
            weaponMatches = effectText.match(/weapon\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          if (weaponMatches) {
            weaponMatches.forEach(match => {
              const numMatch = match.match(/(\d+\.?\d*)/);
              if (numMatch) {
                const ampValue = parseFloat(numMatch[1]) || 0;
                if (ampValue > 0) {
                  weaponTitlePercent += ampValue;
                  weaponDamageAmpPercent += ampValue;
                }
              }
            });
          }
          
          // PVE 피해 증폭
          let pveMatches = effectText.match(/pve\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          if (!pveMatches) {
            pveMatches = effectText.match(/pve피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          if (!pveMatches) {
            pveMatches = effectText.match(/pve\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          if (pveMatches) {
            pveMatches.forEach(match => {
              const numMatch = match.match(/(\d+\.?\d*)/);
              if (numMatch) {
                const ampValue = parseFloat(numMatch[1]) || 0;
                if (ampValue > 0) {
                  pveTitlePercent += ampValue;
                  pveDamageAmpPercent += ampValue;
                }
              }
            });
          }
          
          // 치명타 피해 증폭
          let criticalMatches = effectText.match(/치명타\s*피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          if (!criticalMatches) {
            criticalMatches = effectText.match(/치명타피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          if (!criticalMatches) {
            criticalMatches = effectText.match(/critical\s*damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          if (criticalMatches) {
            criticalMatches.forEach(match => {
              const numMatch = match.match(/(\d+\.?\d*)/);
              if (numMatch) {
                const ampValue = parseFloat(numMatch[1]) || 0;
                if (ampValue > 0) {
                  criticalTitlePercent += ampValue;
                  criticalDamageAmpPercent += ampValue;
                }
              }
            });
          }
          
          // 피해 증폭 (다른 키워드와 겹치지 않을 때만)
          // 원본 effectText에서 먼저 치명타, 무기, PVE 키워드 확인
          if (!effectText.includes('무기') && !effectText.includes('pve') && !effectText.includes('치명타') && 
              !effectText.includes('weapon') && !effectText.includes('critical')) {
            let damageMatches = effectText.match(/피해\s*증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            if (!damageMatches) {
              damageMatches = effectText.match(/피해증폭\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            if (!damageMatches) {
              damageMatches = effectText.match(/damage\s*amplification\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            if (damageMatches) {
              damageMatches.forEach(match => {
                const numMatch = match.match(/(\d+\.?\d*)/);
                if (numMatch) {
                  const ampValue = parseFloat(numMatch[1]) || 0;
                  if (ampValue > 0) {
                    damageAmpTitlePercent += ampValue;
                    damageAmpPercent += ampValue;
                  }
                }
              });
            }
          }
        });
      }
    });
  }
  
  // 정수 합계를 퍼센트로 변환 (정수 10당 0.1%)
  const weaponIntegerToPercent = weaponDamageAmpInteger / 10 * 0.1;
  const pveIntegerToPercent = pveDamageAmpInteger / 10 * 0.1;
  const damageAmpIntegerToPercent = damageAmpInteger / 10 * 0.1;
  const criticalIntegerToPercent = criticalDamageAmpInteger / 10 * 0.1;
  
  // 최종 피해 증폭 퍼센트 = 기존 퍼센트 + 정수 변환 퍼센트
  const finalWeaponDamageAmpPercent = weaponDamageAmpPercent + weaponIntegerToPercent;
  const finalPveDamageAmpPercent = pveDamageAmpPercent + pveIntegerToPercent;
  const finalDamageAmpPercent = damageAmpPercent + damageAmpIntegerToPercent;
  const finalCriticalDamageAmpPercent = criticalDamageAmpPercent + criticalIntegerToPercent;
  
  // 총합 (DPS 계산용)
  const totalFinalDamageAmpPercent = finalWeaponDamageAmpPercent + finalPveDamageAmpPercent + finalDamageAmpPercent + finalCriticalDamageAmpPercent;
  
  const result = {
    // 4가지 피해 증폭 각각
    weaponDamageAmp: {
      totalPercent: finalWeaponDamageAmpPercent,
      totalInteger: weaponDamageAmpInteger,
      breakdown: {
        soulPercent: weaponSoulPercent,
        equipmentBasePercent: weaponEquipmentBasePercent,
        stoneInteger: weaponStoneInteger,
        stonePercent: weaponIntegerToPercent,
        daevanionPercent: weaponDaevanionPercent,
        daevanionArielPercent: 0, // 아리엘은 PVE만
        titlePercent: weaponTitlePercent
      }
    },
    pveDamageAmp: {
      totalPercent: finalPveDamageAmpPercent,
      totalInteger: pveDamageAmpInteger,
      breakdown: {
        soulPercent: pveSoulPercent,
        equipmentBasePercent: pveEquipmentBasePercent,
        stoneInteger: pveStoneInteger,
        stonePercent: pveIntegerToPercent,
        daevanionPercent: pveDaevanionPercent,
        daevanionArielPercent: pveDaevanionArielPercent,
        titlePercent: pveTitlePercent
      }
    },
    damageAmp: {
      totalPercent: finalDamageAmpPercent,
      totalInteger: damageAmpInteger,
      breakdown: {
        soulPercent: damageAmpSoulPercent,
        equipmentBasePercent: damageAmpEquipmentBasePercent,
        stoneInteger: damageAmpStoneInteger,
        stonePercent: damageAmpIntegerToPercent,
        daevanionPercent: damageAmpDaevanionPercent,
        daevanionArielPercent: 0, // 아리엘은 PVE만
        titlePercent: damageAmpTitlePercent
      }
    },
    criticalDamageAmp: {
      totalPercent: finalCriticalDamageAmpPercent,
      totalInteger: criticalDamageAmpInteger,
      breakdown: {
        soulPercent: criticalSoulPercent,
        equipmentBasePercent: criticalEquipmentBasePercent,
        stoneInteger: criticalStoneInteger,
        stonePercent: criticalIntegerToPercent,
        daevanionPercent: criticalDaevanionPercent,
        daevanionArielPercent: 0, // 아리엘은 PVE만
        titlePercent: criticalTitlePercent
      }
    },
    // DPS 계산용 총합 (하위 호환성)
    totalDamageAmpPercent: totalFinalDamageAmpPercent,
    finalDamageAmpPercent: totalFinalDamageAmpPercent
  };
  
  // 전역 변수에 저장
  window.damageAmplificationResult = result;
  
  // 피해 증폭 표시 업데이트
  displayDamageAmplificationStats(result);
  
  return result;
}

// 피해 증폭 정보 표시 함수 (4가지 피해 증폭을 각각 표시)
function displayDamageAmplificationStats(result) {
  if (!result) {
    return;
  }
  
  // 1. 무기 피해 증폭
  if (result.weaponDamageAmp) {
    const weaponValue = document.getElementById('weapon-damage-amplification-value');
    const weaponBreakdown = result.weaponDamageAmp.breakdown;
    
    if (weaponValue) {
      const total = result.weaponDamageAmp.totalPercent;
      // 무기 피해 증폭 딜증: 0.66배
      weaponValue.textContent = total > 0 ? `+${total.toFixed(1)}%` : '-';

    }
    
    const tooltipSoul = document.getElementById('tooltip-soul-weapon-damage-amp');
    const tooltipEquipmentBase = document.getElementById('tooltip-equipment-base-weapon-damage-amp');
    const tooltipStone = document.getElementById('tooltip-stone-weapon-damage-amp');
    const tooltipDaevanion = document.getElementById('tooltip-daevanion-weapon-damage-amp');
    const tooltipTitle = document.getElementById('tooltip-title-weapon-damage-amp');
    
    if (tooltipSoul) tooltipSoul.textContent = `+${(weaponBreakdown.soulPercent || 0).toFixed(1)}%`;
    if (tooltipEquipmentBase) tooltipEquipmentBase.textContent = `+${(weaponBreakdown.equipmentBasePercent || 0).toFixed(1)}%`;
    if (tooltipStone) tooltipStone.textContent = `+${weaponBreakdown.stoneInteger || 0} (${(weaponBreakdown.stonePercent || 0).toFixed(1)}%)`;
    if (tooltipDaevanion) tooltipDaevanion.textContent = `+${(weaponBreakdown.daevanionPercent || 0).toFixed(1)}%`;
    if (tooltipTitle) tooltipTitle.textContent = `+${(weaponBreakdown.titlePercent || 0).toFixed(1)}%`;
  }
  
  // 2. 피해 증폭 (PVE 피해 증폭 + 일반 피해 증폭 합산)
  if (result.pveDamageAmp && result.damageAmp) {
    const damageAmpValue = document.getElementById('damage-amplification-value');
    const pveBreakdown = result.pveDamageAmp.breakdown;
    const damageAmpBreakdown = result.damageAmp.breakdown;
    
    if (damageAmpValue) {
      // PVE 피해 증폭 + 일반 피해 증폭 합산
      const total = result.pveDamageAmp.totalPercent + result.damageAmp.totalPercent;
      damageAmpValue.textContent = total > 0 ? `+${total.toFixed(1)}%` : '-';
    }
    
    // breakdown 합산하여 표시
    const tooltipSoul = document.getElementById('tooltip-soul-damage-amp');
    const tooltipEquipmentBase = document.getElementById('tooltip-equipment-base-damage-amp');
    const tooltipStone = document.getElementById('tooltip-stone-damage-amp');
    const tooltipDaevanion = document.getElementById('tooltip-daevanion-damage-amp');
    const tooltipDaevanionAriel = document.getElementById('tooltip-daevanion-ariel-damage-amp');
    const tooltipTitle = document.getElementById('tooltip-title-damage-amp');
    
    if (tooltipSoul) tooltipSoul.textContent = `+${((pveBreakdown.soulPercent || 0) + (damageAmpBreakdown.soulPercent || 0)).toFixed(1)}%`;
    if (tooltipEquipmentBase) tooltipEquipmentBase.textContent = `+${((pveBreakdown.equipmentBasePercent || 0) + (damageAmpBreakdown.equipmentBasePercent || 0)).toFixed(1)}%`;
    if (tooltipStone) {
      const totalStoneInt = (pveBreakdown.stoneInteger || 0) + (damageAmpBreakdown.stoneInteger || 0);
      const totalStonePercent = (pveBreakdown.stonePercent || 0) + (damageAmpBreakdown.stonePercent || 0);
      tooltipStone.textContent = `+${totalStoneInt} (${totalStonePercent.toFixed(1)}%)`;
    }
    if (tooltipDaevanion) tooltipDaevanion.textContent = `+${((pveBreakdown.daevanionPercent || 0) + (damageAmpBreakdown.daevanionPercent || 0)).toFixed(1)}%`;
    if (tooltipDaevanionAriel) tooltipDaevanionAriel.textContent = `+${((pveBreakdown.daevanionArielPercent || 0) + (damageAmpBreakdown.daevanionArielPercent || 0)).toFixed(1)}%`;
    if (tooltipTitle) tooltipTitle.textContent = `+${((pveBreakdown.titlePercent || 0) + (damageAmpBreakdown.titlePercent || 0)).toFixed(1)}%`;
  }
  
  // 3. 치명타 피해 증폭
  if (result.criticalDamageAmp) {
    const criticalValue = document.getElementById('critical-damage-amplification-value');
    const criticalBreakdown = result.criticalDamageAmp.breakdown;
    
    if (criticalValue) {
      const total = result.criticalDamageAmp.totalPercent;
      // 치명타 피해 증폭으로 인한 딜증 계산은 updateAllDamageIncreaseBadges에서 수행
      // 여기서는 일단 퍼센트만 표시 (실제 딜증은 모달에서 확인)
      criticalValue.textContent = total > 0 ? `+${total.toFixed(1)}%` : '-';
    }
    
    const tooltipSoul = document.getElementById('tooltip-soul-critical-damage-amp');
    const tooltipEquipmentBase = document.getElementById('tooltip-equipment-base-critical-damage-amp');
    const tooltipStone = document.getElementById('tooltip-stone-critical-damage-amp');
    const tooltipDaevanion = document.getElementById('tooltip-daevanion-critical-damage-amp');
    const tooltipTitle = document.getElementById('tooltip-title-critical-damage-amp');
    
    if (tooltipSoul) tooltipSoul.textContent = `+${(criticalBreakdown.soulPercent || 0).toFixed(1)}%`;
    if (tooltipEquipmentBase) tooltipEquipmentBase.textContent = `+${(criticalBreakdown.equipmentBasePercent || 0).toFixed(1)}%`;
    if (tooltipStone) tooltipStone.textContent = `+${criticalBreakdown.stoneInteger || 0} (${(criticalBreakdown.stonePercent || 0).toFixed(1)}%)`;
    if (tooltipDaevanion) tooltipDaevanion.textContent = `+${(criticalBreakdown.daevanionPercent || 0).toFixed(1)}%`;
    if (tooltipTitle) tooltipTitle.textContent = `+${(criticalBreakdown.titlePercent || 0).toFixed(1)}%`;
  }
}

// 전투 속도 정보 표시 함수
function displayCombatSpeedStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const combatSpeedValue = document.getElementById('combat-speed-value');
  const tooltipSoul = document.getElementById('tooltip-soul-combat-speed');
  const tooltipAccessory = document.getElementById('tooltip-accessory-combat-speed');
  const tooltipTime = document.getElementById('tooltip-time-combat-speed');
  const tooltipDaevanion = document.getElementById('tooltip-daevanion-combat-speed');
  const tooltipTitle = document.getElementById('tooltip-title-combat-speed');
  
  if (!combatSpeedValue) {
    return;
  }
  
  const { totalCombatSpeed, breakdown } = result;
  const { soulCombatSpeed, accessoryCombatSpeed, timeCombatSpeed, daevanionCombatSpeed, titleCombatSpeed } = breakdown;
  
  // 최종 전투 속도 표시
  combatSpeedValue.textContent = `+${totalCombatSpeed.toFixed(1)}%`;

  // 툴팁 내용 업데이트
  if (tooltipSoul) tooltipSoul.textContent = `+${soulCombatSpeed.toFixed(1)}%`;
  if (tooltipAccessory) tooltipAccessory.textContent = `+${(accessoryCombatSpeed || 0).toFixed(1)}%`;
  if (tooltipTime) tooltipTime.textContent = `+${timeCombatSpeed.toFixed(1)}%`;
  if (tooltipDaevanion) tooltipDaevanion.textContent = `+${daevanionCombatSpeed.toFixed(1)}%`;
  if (tooltipTitle) tooltipTitle.textContent = `+${(titleCombatSpeed || 0).toFixed(1)}%`;
}

// 치명타 계산 함수
function calculateCriticalHit(equipment, accessories, statData, daevanionData) {
  
  let totalCriticalHitInteger = 0; // 총 치명타 정수
  let totalCriticalHitPercent = 0; // 총 치명타 퍼센트
  
  // Breakdown 정보 추적
  let baseCriticalHitInteger = 0; // 기본 옵션 치명타 (정수)
  let soulCriticalHitInteger = 0; // 영혼 각인 치명타 (정수)
  let stoneCriticalHitInteger = 0; // 마석 각인 치명타 (정수)
  let daevanionCriticalHitInteger = 0; // 데바니온 치명타 (정수)
  let deathCriticalHitPercent = 0; // 주신 스탯 죽음으로 인한 치명타 (퍼센트)
  let accuracyCriticalHitPercent = 0; // 일반 스탯 정확으로 인한 치명타 (퍼센트)
  
  // 1. 메인 무기/가더 기본 옵션에서 치명타 추출 (정수)
  // calculateAttackPower와 동일한 방식으로 slotPos 사용 (1=메인 무기, 2=가더)
  const weaponAndGauntlet = [...(equipment || [])].filter(item => {
    // slotPos, slot_pos, slot_index, slot, raw_data.slotPos 등 다양한 경로 확인
    let slotPos = -1;
    
    if (item.slotPos !== undefined && item.slotPos !== null) slotPos = item.slotPos;
    else if (item.slot_pos !== undefined && item.slot_pos !== null) slotPos = item.slot_pos;
    else if (item.slot_index !== undefined && item.slot_index !== null) slotPos = item.slot_index;
    else if (item.slot !== undefined && item.slot !== null) slotPos = item.slot;
    else if (item.raw_data && item.raw_data.slotPos !== undefined && item.raw_data.slotPos !== null) slotPos = item.raw_data.slotPos;
    
    // slotPos가 1이면 메인 무기, 2이면 가더
    // 또한 slot_index가 0이면 무기, 1이면 가더 (하위 호환성)
    return slotPos == 1 || slotPos == 2 || slotPos == 0 || slotPos == '0' || slotPos == '1' || slotPos == '2';
  });
  
  
  weaponAndGauntlet.forEach((item, index) => {
    const itemName = item.name || '알 수 없음';
    
    // mainStats에서 치명타 추출
    if (item.main_stats) {
      if (Array.isArray(item.main_stats)) {
        item.main_stats.forEach((stat, statIndex) => {
          if (typeof stat === 'object' && stat !== null) {
            const statName = String(stat.name || stat.id || '').toLowerCase();
            const statValue = stat.value || stat.minValue || '';
            
            // "치명타"가 포함되어 있는지 확인 (치명타 저항, 치명타 피해 증폭 등 제외)
            const hasCritical = (statName.includes('치명타') || statName.includes('critical')) &&
                                !statName.includes('치명타 방어력') && 
                                !statName.includes('치명타 저항') && 
                                !statName.includes('치명타 피해 증폭') &&
                                !statName.includes('critical resistance') && 
                                !statName.includes('critical damage');
            
            if (hasCritical) {
              let criticalValue = 0;
              
              // value가 문자열인 경우 (예: "100", "100 (+50)" 등)
              if (typeof statValue === 'string') {
                // 숫자만 추출
                const numMatch = statValue.match(/(\d+)/);
                if (numMatch) {
                  criticalValue = parseInt(numMatch[1]) || 0;
                }
              } else if (typeof statValue === 'number') {
                criticalValue = parseInt(statValue) || 0;
              }
              
              if (criticalValue > 0) {
                baseCriticalHitInteger += criticalValue;
                totalCriticalHitInteger += criticalValue;
              }
            }
          }
        });
      } else if (typeof item.main_stats === 'object' && !Array.isArray(item.main_stats)) {
        for (const key in item.main_stats) {
          const keyLower = String(key).toLowerCase();
          const value = item.main_stats[key];
          
          // "치명타"가 포함되어 있는지 확인 (치명타 저항, 치명타 피해 증폭 등 제외)
          const hasCritical = (keyLower.includes('치명타') || keyLower.includes('critical')) &&
                              !keyLower.includes('치명타 방어력') && 
                              !keyLower.includes('치명타 저항') && 
                              !keyLower.includes('치명타 피해 증폭') &&
                              !keyLower.includes('critical resistance') && 
                              !keyLower.includes('critical damage');
          
          if (hasCritical) {
            let criticalValue = 0;
            
            if (typeof value === 'string') {
              const numMatch = value.match(/(\d+)/);
              if (numMatch) {
                criticalValue = parseInt(numMatch[1]) || 0;
              }
            } else if (typeof value === 'number') {
              criticalValue = parseInt(value) || 0;
            }
            
            if (criticalValue > 0) {
              baseCriticalHitInteger += criticalValue;
              totalCriticalHitInteger += criticalValue;
            }
          }
        }
      }
    }
  });
  
  // 2. 영혼 각인 및 마석 각인에서 치명타 추출 (정수)
  const allItems = [...(equipment || []), ...(accessories || [])];
  
  allItems.forEach((item, itemIndex) => {
    const itemName = item.name || '알 수 없음';
    
    // subStats (영혼 각인)에서 치명타 추출
    if (item.sub_stats) {
      
      if (Array.isArray(item.sub_stats)) {
        item.sub_stats.forEach((stat, statIndex) => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseInt(stat.value || stat.amount || 0);
            
            
            // 정확히 "치명타"만 매칭 (치명타 저항, 치명타 피해 증폭 등 제외)
            if (value > 0 && 
                ((name === '치명타' || name === 'critical') || 
                 (name.startsWith('치명타 ') && !name.includes('치명타 방어력') && !name.includes('치명타 저항') && !name.includes('치명타 피해 증폭')) ||
                 (name.startsWith('critical ') && !name.includes('critical resistance') && !name.includes('critical damage')))) {
              soulCriticalHitInteger += value;
              totalCriticalHitInteger += value;
            }
          }
        });
      } else if (typeof item.sub_stats === 'object') {
        for (const key of Object.keys(item.sub_stats)) {
          const keyLower = key.toLowerCase();
          const value = parseInt(item.sub_stats[key] || 0);
          
          
          // 정확히 "치명타"만 매칭 (치명타 저항, 치명타 피해 증폭 등 제외)
          if (value > 0 && 
              ((keyLower === '치명타' || keyLower === 'critical') || 
               (keyLower.startsWith('치명타 ') && !keyLower.includes('치명타 방어력') && !keyLower.includes('치명타 저항') && !keyLower.includes('치명타 피해 증폭')) ||
               (keyLower.startsWith('critical ') && !keyLower.includes('critical resistance') && !keyLower.includes('critical damage')))) {
            soulCriticalHitInteger += value;
            totalCriticalHitInteger += value;
          }
        }
      }
    } else {
    }
    
    // magic_stone_stat (마석 각인)에서 치명타 추출
    if (item.magic_stone_stat) {
      
      if (Array.isArray(item.magic_stone_stat)) {
        item.magic_stone_stat.forEach((stat, statIndex) => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseInt(stat.value || stat.amount || 0);
            
            
            // 정확히 "치명타"만 매칭 (치명타 저항, 치명타 피해 증폭 등 제외)
            if (value > 0 && 
                ((name === '치명타' || name === 'critical') || 
                 (name.startsWith('치명타 ') && !name.includes('치명타 방어력') && !name.includes('치명타 저항') && !name.includes('치명타 피해 증폭')) ||
                 (name.startsWith('critical ') && !name.includes('critical resistance') && !name.includes('critical damage')))) {
              stoneCriticalHitInteger += value;
              totalCriticalHitInteger += value;
            }
          }
        });
      } else if (typeof item.magic_stone_stat === 'object') {
        for (const key of Object.keys(item.magic_stone_stat)) {
          const keyLower = key.toLowerCase();
          const value = parseInt(item.magic_stone_stat[key] || 0);
          
          
          // 정확히 "치명타"만 매칭 (치명타 저항, 치명타 피해 증폭 등 제외)
          if (value > 0 && 
              ((keyLower === '치명타' || keyLower === 'critical') || 
               (keyLower.startsWith('치명타 ') && !keyLower.includes('치명타 방어력') && !keyLower.includes('치명타 저항') && !keyLower.includes('치명타 피해 증폭')) ||
               (keyLower.startsWith('critical ') && !keyLower.includes('critical resistance') && !keyLower.includes('critical damage')))) {
            stoneCriticalHitInteger += value;
            totalCriticalHitInteger += value;
          }
        }
      }
    } else {
    }
  });
  
  // 3. 데바니온 (아리엘, 아스펠 제외) 4개 보드에서 치명타 추출 (정수)
  const daevanionBoardIds = [41, 42, 43, 44]; // 네자칸, 지켈, 바이젤, 트리니엘
  const daevanionBoardNames = { 41: '네자칸', 42: '지켈', 43: '바이젤', 44: '트리니엘' };
  
  if (daevanionData) {
    
    daevanionBoardIds.forEach(boardId => {
      const boardName = daevanionBoardNames[boardId] || `보드${boardId}`;
      const boardData = daevanionData[boardId];
      let boardCriticalHit = 0;
      
      if (boardData && boardData.nodeList) {
        const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
        
        activeNodes.forEach((node, nodeIndex) => {
          let nodeCriticalHit = 0;
          let foundInField = null;
          
          // 처음 몇 개 노드의 구조 확인
          if (nodeIndex < 3) {
          }
          
          // 노드의 모든 필드를 순회하며 검색 - 공격력 계산과 동일한 방식
          for (const key in node) {
            const value = node[key];
            
            // 문자열인 경우 패턴 검색
            if (typeof value === 'string' && value.trim()) {
              const text = value;
              
              // "치명타 +X" 패턴 검색 (치명타 저항, 치명타 피해 증폭 등 제외)
              let matches = text.match(/치명타\s*[+＋]\s*(\d+)/gi);
              if (!matches) {
                matches = text.match(/critical\s*[+＋]\s*(\d+)/gi);
              }
              
              if (matches) {
                matches.forEach(match => {
                  // 치명타 저항, 치명타 피해 증폭 등 제외
                  const matchLower = match.toLowerCase();
                  if (matchLower.includes('치명타 저항') || matchLower.includes('치명타 방어력') || matchLower.includes('치명타 피해 증폭') ||
                      matchLower.includes('critical resistance') || matchLower.includes('critical damage')) {
                    return; // 이 매칭은 건너뜀
                  }
                  
                  const numMatch = match.match(/(\d+)/);
                  if (numMatch) {
                    const criticalValue = parseInt(numMatch[1]) || 0;
                    if (criticalValue > 0) {
                      nodeCriticalHit += criticalValue;
                      if (!foundInField) foundInField = key;
                    }
                  }
                });
              }
            }
            
            // 배열인 경우 (statList, effectList 등)
            if (Array.isArray(value) && value.length > 0) {
              value.forEach((item, itemIndex) => {
                if (typeof item === 'object' && item !== null) {
                  // 객체의 모든 필드 검색
                  for (const itemKey in item) {
                    const itemValue = item[itemKey];
                    if (typeof itemValue === 'string' && itemValue.trim()) {
                      let matches = itemValue.match(/치명타\s*[+＋]\s*(\d+)/gi);
                      if (!matches) {
                        matches = itemValue.match(/critical\s*[+＋]\s*(\d+)/gi);
                      }
                      
                      if (matches) {
                        matches.forEach(match => {
                          // 치명타 저항, 치명타 피해 증폭 등 제외
                          const matchLower = match.toLowerCase();
                          if (matchLower.includes('치명타 저항') || matchLower.includes('치명타 방어력') || matchLower.includes('치명타 피해 증폭') ||
                              matchLower.includes('critical resistance') || matchLower.includes('critical damage')) {
                            return; // 이 매칭은 건너뜀
                          }
                          
                          const numMatch = match.match(/(\d+)/);
                          if (numMatch) {
                            const criticalValue = parseInt(numMatch[1]) || 0;
                            if (criticalValue > 0) {
                              nodeCriticalHit += criticalValue;
                              if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                            }
                          }
                        });
                      }
                    }
                    
                    // value나 amount 필드가 숫자인 경우
                    if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                      const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                      // 정확히 "치명타"만 매칭 (치명타 저항, 치명타 피해 증폭 등 제외)
                      if ((itemName === '치명타' || itemName === 'critical') || 
                          (itemName.startsWith('치명타 ') && !itemName.includes('치명타 방어력') && !itemName.includes('치명타 저항') && !itemName.includes('치명타 피해 증폭')) ||
                          (itemName.startsWith('critical ') && !itemName.includes('critical resistance') && !itemName.includes('critical damage'))) {
                        nodeCriticalHit += itemValue;
                        if (!foundInField) foundInField = `${key}[${itemIndex}].${itemKey}`;
                      }
                    }
                  }
                }
              });
            }
            
            // 객체인 경우 재귀적으로 검색
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
              for (const subKey in value) {
                const subValue = value[subKey];
                if (typeof subValue === 'string' && subValue.trim()) {
                  let matches = subValue.match(/치명타\s*[+＋]\s*(\d+)/gi);
                  if (!matches) {
                    matches = subValue.match(/critical\s*[+＋]\s*(\d+)/gi);
                  }
                  
                  if (matches) {
                    matches.forEach(match => {
                      // 치명타 저항, 치명타 피해 증폭 등 제외
                      const matchLower = match.toLowerCase();
                      if (matchLower.includes('치명타 저항') || matchLower.includes('치명타 방어력') || matchLower.includes('치명타 피해 증폭') ||
                          matchLower.includes('critical resistance') || matchLower.includes('critical damage')) {
                        return; // 이 매칭은 건너뜀
                      }
                      
                      const numMatch = match.match(/(\d+)/);
                      if (numMatch) {
                        const criticalValue = parseInt(numMatch[1]) || 0;
                        if (criticalValue > 0) {
                          nodeCriticalHit += criticalValue;
                          if (!foundInField) foundInField = `${key}.${subKey}`;
                        }
                      }
                    });
                  }
                }
              }
            }
          }
          
          if (nodeCriticalHit > 0) {
            boardCriticalHit += nodeCriticalHit;
            const nodeName = node.name || node.desc || node.effect || `노드${nodeIndex}`;
          }
        });
        
        if (boardCriticalHit > 0) {
          daevanionCriticalHitInteger += boardCriticalHit;
          totalCriticalHitInteger += boardCriticalHit;
        } else {
        }
      } else {
      }
    });
  } else {
  }
  
  // 정수 합계를 퍼센트로 변환 (정수 1당 0.1%, 즉 정수 * 0.1)
  const integerToPercent = totalCriticalHitInteger * 0.1;
  
  // 4. 주신 스탯 중 죽음[트리니엘] 스탯 1당 치명타 +0.1%
  if (statData && statData.statList) {
    
    const deathStat = statData.statList.find(stat => 
      stat.type === 'Death' || (stat.name && (stat.name.includes('죽음') || stat.name.includes('Death') || stat.name.includes('트리니엘')))
    );
    
    if (deathStat) {
      const deathValue = parseInt(deathStat.value || 0);
      deathCriticalHitPercent = deathValue * 0.2; // 스탯 1당 0.2%, 2배 적용
      totalCriticalHitPercent += deathCriticalHitPercent;
    } else {
    }
  } else {
  }
  
  // 5. 일반 스탯 중 정확 스탯 1당 치명타 +0.1%
  if (statData && statData.statList) {
    const accuracyStat = statData.statList.find(stat => 
      stat.type === 'Accuracy' || (stat.name && stat.name.includes('정확'))
    );
    if (accuracyStat) {
      const accuracyValue = parseInt(accuracyStat.value || 0);
      accuracyCriticalHitPercent = accuracyValue * 0.1;
      totalCriticalHitPercent += accuracyCriticalHitPercent;
    } else {
    }
  }
  
  // 최종 치명타 퍼센트 = 정수 합계 * 0.1% + 주신 스탯 퍼센트 + 일반 스탯 퍼센트
  const finalCriticalHitPercent = integerToPercent + totalCriticalHitPercent;
  
  
  // 각 정수 소스를 퍼센트로 변환 (정수 1당 0.1%)
  const soulCriticalHitPercent = soulCriticalHitInteger * 0.1;
  const stoneCriticalHitPercent = stoneCriticalHitInteger * 0.1;
  const daevanionCriticalHitPercent = daevanionCriticalHitInteger * 0.1;
  
  const result = {
    totalCriticalHitPercent: finalCriticalHitPercent,
    totalCriticalHitInteger: totalCriticalHitInteger,
    breakdown: {
      baseCriticalHitInteger: baseCriticalHitInteger,
      soulCriticalHitInteger: soulCriticalHitInteger,
      soulCriticalHitPercent: soulCriticalHitPercent,
      stoneCriticalHitInteger: stoneCriticalHitInteger,
      stoneCriticalHitPercent: stoneCriticalHitPercent,
      daevanionCriticalHitInteger: daevanionCriticalHitInteger,
      daevanionCriticalHitPercent: daevanionCriticalHitPercent,
      deathCriticalHitPercent: deathCriticalHitPercent,
      accuracyCriticalHitPercent: accuracyCriticalHitPercent
    }
  };
  
  // 전역 변수에 저장
  window.criticalHitResult = result;
  
  // 치명타 표시 업데이트
  displayCriticalHitStats(result);
  
  return result;
}

// 치명타 정보 표시 함수
function displayCriticalHitStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const criticalHitValue = document.getElementById('critical-hit-value');
  const tooltipBase = document.getElementById('tooltip-base-critical');
  const tooltipSoul = document.getElementById('tooltip-soul-critical');
  const tooltipStone = document.getElementById('tooltip-stone-critical');
  const tooltipDaevanion = document.getElementById('tooltip-daevanion-critical');
  const tooltipDeath = document.getElementById('tooltip-death-critical');
  const tooltipAccuracy = document.getElementById('tooltip-accuracy-critical');
  
  if (!criticalHitValue) {
    return;
  }
  
  const { totalCriticalHitPercent, breakdown } = result;
  const { baseCriticalHitInteger, soulCriticalHitInteger, soulCriticalHitPercent, stoneCriticalHitInteger, stoneCriticalHitPercent, daevanionCriticalHitInteger, daevanionCriticalHitPercent, deathCriticalHitPercent, accuracyCriticalHitPercent } = breakdown;
  
  // 최종 치명타 표시
  criticalHitValue.textContent = `+${totalCriticalHitPercent.toFixed(1)}%`;
  
  // 최종 치명타 정수 계산: (정수 합계) * (1 + (주신 스탯 퍼센트 + 일반 스탯 퍼센트)/100)
  const totalCriticalHitInteger = baseCriticalHitInteger + soulCriticalHitInteger + stoneCriticalHitInteger + daevanionCriticalHitInteger;
  const totalPercentMultiplier = 1 + ((deathCriticalHitPercent + accuracyCriticalHitPercent) / 100);
  const finalCriticalHitInteger = Math.round(totalCriticalHitInteger * totalPercentMultiplier);
  
  // 최종 치명타를 확률로 변환 (대만 커뮤니티 테이블 기반)
  const criticalChancePercent = convertCritStatToChance(finalCriticalHitInteger);
  criticalHitValue.textContent = `${criticalChancePercent.toFixed(1)}%`;
  // 원본 정수값도 저장 (다른 계산에서 사용)
  criticalHitValue.dataset.rawValue = finalCriticalHitInteger;
  
  // 툴팁 내용 업데이트 (정수만 표시, 퍼센트 제거)
  if (tooltipBase) {
    tooltipBase.textContent = `+${baseCriticalHitInteger || 0}`;
  }
  
  if (tooltipSoul) {
    tooltipSoul.textContent = `+${soulCriticalHitInteger || 0}`;
  }
  
  if (tooltipStone) {
    tooltipStone.textContent = `+${stoneCriticalHitInteger || 0}`;
  }
  
  if (tooltipDaevanion) {
    tooltipDaevanion.textContent = `+${daevanionCriticalHitInteger || 0}`;
  }
  
  // 주신 스탯과 일반 스탯은 퍼센트만 표시
  if (tooltipDeath) tooltipDeath.textContent = `+${deathCriticalHitPercent.toFixed(1)}%`;
  if (tooltipAccuracy) tooltipAccuracy.textContent = `+${accuracyCriticalHitPercent.toFixed(1)}%`;
  
  // 컨테이너 표시
  const criticalHitContainer = document.getElementById('critical-hit-container');
  if (criticalHitContainer) {
    criticalHitContainer.style.display = 'block';
  }
}

// 강타 계산 함수 (타이틀, 지혜[루미엘])
function calculateStunHit(statData, titles) {
  let totalStunHitPercent = 0;
  let titleStunHitPercent = 0;
  let wisdomStunHitPercent = 0;
  
  // 1. 타이틀 장착 효과에서 강타 추출
  if (titles && Array.isArray(titles)) {
    titles.forEach((title) => {
      const titleName = title.name || '알 수 없음';
      
      if (title.equip_effects && Array.isArray(title.equip_effects)) {
        title.equip_effects.forEach((effect) => {
          const effectText = String(effect || '');
          
          // 강타 패턴 매칭
          let matches = effectText.match(/강타\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          if (!matches) {
            matches = effectText.match(/stun\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          
          if (matches) {
            matches.forEach(match => {
              const numMatch = match.match(/(\d+\.?\d*)/);
              if (numMatch) {
                const stunValue = parseFloat(numMatch[1]) || 0;
                if (stunValue > 0) {
                  titleStunHitPercent += stunValue;
                  totalStunHitPercent += stunValue;
                }
              }
            });
          }
        });
      }
    });
  }
  
  // 2. 주신 스탯 중 지혜[루미엘] 스탯에서 강타 추출
  if (statData && statData.statList) {
    const wisdomStat = statData.statList.find(stat => 
      stat.type === 'Wisdom' || (stat.name && stat.name.includes('지혜'))
    );
    
    if (wisdomStat && wisdomStat.statSecondList && Array.isArray(wisdomStat.statSecondList)) {
      const wisdomValue = parseInt(wisdomStat.value || 0);
      
      // statSecondList에서 "강타" 효과 찾기
      wisdomStat.statSecondList.forEach((effect, index) => {
        const effectText = String(effect || '');
        if (effectText.includes('강타') || effectText.includes('stun')) {
          // 지혜[루미엘]: 정신력 소모 감소(-), 강타 (각각 2배, 첫 번째는 음수)
          // 강타는 두 번째 효과이므로 index 1
          if (index === 1) {
            // 스탯 값 × 0.1% × 2배
            wisdomStunHitPercent = wisdomValue * 0.1 * 2;
            totalStunHitPercent += wisdomStunHitPercent;
          }
        }
      });
    }
  }
  
  const result = {
    totalStunHitPercent: totalStunHitPercent,
    breakdown: {
      titleStunHitPercent: titleStunHitPercent,
      wisdomStunHitPercent: wisdomStunHitPercent
    }
  };
  
  // 전역 변수에 저장
  window.stunHitResult = result;
  
  // 강타 표시 업데이트
  displayStunHitStats(result);
  
  return result;
}

// 강타 정보 표시 함수
function displayStunHitStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const stunHitValue = document.getElementById('stun-hit-value');
  const tooltipTitle = document.getElementById('tooltip-title-stun');
  const tooltipWisdom = document.getElementById('tooltip-wisdom-stun');
  
  if (!stunHitValue) {
    return;
  }
  
  const { totalStunHitPercent, breakdown } = result;
  const { titleStunHitPercent, wisdomStunHitPercent } = breakdown;
  
  // 강타가 0이면 컨테이너 숨김
  if (totalStunHitPercent <= 0) {
    const stunHitContainer = document.getElementById('stun-hit-container');
    if (stunHitContainer) {
      stunHitContainer.style.display = 'none';
    }
    return;
  }
  
  // 최종 강타 표시 (딜증 = 그대로)
  // 최종 강타 표시
  stunHitValue.textContent = `+${totalStunHitPercent.toFixed(1)}%`;

  // 툴팁 내용 업데이트
  if (tooltipTitle) tooltipTitle.textContent = `+${titleStunHitPercent.toFixed(1)}%`;
  if (tooltipWisdom) tooltipWisdom.textContent = `+${wisdomStunHitPercent.toFixed(1)}%`;
  
  // 컨테이너 표시
  const stunHitContainer = document.getElementById('stun-hit-container');
  if (stunHitContainer) {
    stunHitContainer.style.display = 'block';
  }
}

// 완벽 계산 함수
function calculatePerfect(accessories, statData, titles) {
  let totalPerfectPercent = 0;
  let titlePerfectPercent = 0;
  let justicePerfectPercent = 0;
  let accessoryPerfectPercent = 0;
  
  // 1. 타이틀 장착 효과에서 완벽 추출
  if (titles && Array.isArray(titles)) {
    titles.forEach((title) => {
      const titleName = title.name || '알 수 없음';
      
      if (title.equip_effects && Array.isArray(title.equip_effects)) {
        title.equip_effects.forEach((effect) => {
          const effectText = String(effect || '');
          
          // 완벽 패턴 매칭 (완벽 저항 제외)
          let matches = effectText.match(/완벽\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          if (!matches) {
            matches = effectText.match(/perfect\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          
          if (matches) {
            matches.forEach(match => {
              // 완벽 저항 제외
              const matchLower = match.toLowerCase();
              if (matchLower.includes('완벽 저항') || matchLower.includes('perfect resistance')) {
                return; // 이 매칭은 건너뜀
              }
              
              const numMatch = match.match(/(\d+\.?\d*)/);
              if (numMatch) {
                const perfectValue = parseFloat(numMatch[1]) || 0;
                if (perfectValue > 0) {
                  titlePerfectPercent += perfectValue;
                  totalPerfectPercent += perfectValue;
                }
              }
            });
          }
        });
      }
    });
  }
  
  // 2. 주신 스탯 - 정의[네자칸]에서 완벽 추출
  if (statData && statData.statList) {
    const justiceStat = statData.statList.find(stat => 
      stat.type === 'Justice' || (stat.name && stat.name.includes('정의'))
    );
    
    if (justiceStat && justiceStat.statSecondList && Array.isArray(justiceStat.statSecondList)) {
      const justiceValue = parseInt(justiceStat.value || 0);
      
      // statSecondList에서 "완벽" 효과 찾기
      justiceStat.statSecondList.forEach((effect, index) => {
        const effectText = String(effect || '');
        if (effectText.includes('완벽') || effectText.includes('perfect')) {
          // 정의[네자칸]: 방어력 증가, 완벽 (각각 2배)
          // 완벽은 두 번째 효과이므로 index 1
          if (index === 1) {
            // 스탯 값 × 0.1% × 2배
            justicePerfectPercent = justiceValue * 0.1 * 2;
            totalPerfectPercent += justicePerfectPercent;
          }
        }
      });
    }
  }
  
  // 3. 장신구 기본 옵션에서 완벽 추출
  if (Array.isArray(accessories) && accessories.length > 0) {
    accessories.forEach((accessory) => {
      const accessoryName = accessory.name || '알 수 없음';
      
      if (accessory.main_stats) {
        if (Array.isArray(accessory.main_stats)) {
          accessory.main_stats.forEach((stat) => {
            if (typeof stat === 'object' && stat !== null) {
              const name = (stat.name || stat.type || '').toLowerCase();
              const value = parseFloat(stat.value || stat.minValue || 0);
              
              // 정확히 "완벽"만 매칭 (완벽 저항 제외)
              if (value > 0 && 
                  ((name === '완벽' || name === 'perfect') || 
                   (name.startsWith('완벽 ') && !name.includes('완벽 저항')) ||
                   (name.startsWith('perfect ') && !name.includes('perfect resistance')))) {
                accessoryPerfectPercent += value;
                totalPerfectPercent += value;
              }
            }
          });
        } else if (typeof accessory.main_stats === 'object') {
          for (const key of Object.keys(accessory.main_stats)) {
            const keyLower = key.toLowerCase();
            const value = parseFloat(accessory.main_stats[key] || 0);
            
            // 정확히 "완벽"만 매칭 (완벽 저항 제외)
            if (value > 0 && 
                ((keyLower === '완벽' || keyLower === 'perfect') || 
                 (keyLower.startsWith('완벽 ') && !keyLower.includes('완벽 저항')) ||
                 (keyLower.startsWith('perfect ') && !keyLower.includes('perfect resistance')))) {
              accessoryPerfectPercent += value;
              totalPerfectPercent += value;
            }
          }
        }
      }
    });
  }
  
  const result = {
    totalPerfectPercent: totalPerfectPercent,
    breakdown: {
      titlePerfectPercent: titlePerfectPercent,
      justicePerfectPercent: justicePerfectPercent,
      accessoryPerfectPercent: accessoryPerfectPercent
    }
  };
  
  // 전역 변수에 저장
  window.perfectResult = result;
  
  // 완벽 표시 업데이트
  displayPerfectStats(result);
  
  return result;
}

// 완벽 정보 표시 함수
function displayPerfectStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const perfectValue = document.getElementById('perfect-value');
  const tooltipTitle = document.getElementById('tooltip-title-perfect');
  const tooltipJustice = document.getElementById('tooltip-justice-perfect');
  const tooltipAccessory = document.getElementById('tooltip-accessory-perfect');
  
  if (!perfectValue) {
    return;
  }
  
  const { totalPerfectPercent, breakdown } = result;
  const { titlePerfectPercent, justicePerfectPercent, accessoryPerfectPercent } = breakdown;
  
  // 완벽이 0이면 컨테이너 숨김
  if (totalPerfectPercent <= 0) {
    const perfectContainer = document.getElementById('perfect-container');
    if (perfectContainer) {
      perfectContainer.style.display = 'none';
    }
    return;
  }
  
  // 최종 완벽 표시 (무기 min/max 기반 딜증 계산)
    // 최종 완벽 표시
  perfectValue.textContent = `+${totalPerfectPercent.toFixed(1)}%`;

  
  // 툴팁 내용 업데이트
  if (tooltipTitle) tooltipTitle.textContent = `+${titlePerfectPercent.toFixed(1)}%`;
  if (tooltipJustice) tooltipJustice.textContent = `+${justicePerfectPercent.toFixed(1)}%`;
  if (tooltipAccessory) tooltipAccessory.textContent = `+${accessoryPerfectPercent.toFixed(1)}%`;
  
  // 컨테이너 표시
  const perfectContainer = document.getElementById('perfect-container');
  if (perfectContainer) {
    perfectContainer.style.display = 'block';
  }
}

// 다단 히트 적중 계산 함수
function calculateMultiHit(equipment, accessories, daevanionData) {
  let totalMultiHitPercent = 0;
  let soulMultiHitPercent = 0;
  let baseMultiHitPercent = 0;
  let daevanionMultiHitPercent = 0;
  
  // 모든 아이템을 하나의 배열로 합치기
  const allItems = [...(equipment || []), ...(accessories || [])];
  
  allItems.forEach((item) => {
    if (!item) return;
    const itemName = item.name || '알 수 없음';
    
    // 1. 영혼 각인에서 다단 히트 적중 추출 (sub_stats)
    if (item.sub_stats) {
      if (Array.isArray(item.sub_stats)) {
        item.sub_stats.forEach((stat) => {
          if (typeof stat === 'object') {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseFloat(stat.value || stat.amount || 0);
            
            // 다단 히트 적중 패턴 매칭
            if (value > 0 && 
                (name.includes('다단히트') || name.includes('다단 히트') || 
                 (name.includes('multi') && name.includes('hit')))) {
              soulMultiHitPercent += value;
              totalMultiHitPercent += value;
            }
          }
        });
      } else if (typeof item.sub_stats === 'object') {
        for (const key of Object.keys(item.sub_stats)) {
          const keyLower = key.toLowerCase();
          const value = parseFloat(item.sub_stats[key] || 0);
          
          // 다단 히트 적중 패턴 매칭
          if (value > 0 && 
              (keyLower.includes('다단히트') || keyLower.includes('다단 히트') || 
               (keyLower.includes('multi') && keyLower.includes('hit')))) {
            soulMultiHitPercent += value;
            totalMultiHitPercent += value;
          }
        }
      }
    }
    
    // 2. 기본 옵션에서 다단 히트 적중 추출 (main_stats)
    if (item.main_stats) {
      if (Array.isArray(item.main_stats)) {
        item.main_stats.forEach((stat) => {
          if (typeof stat === 'object' && stat !== null) {
            const name = (stat.name || stat.type || '').toLowerCase();
            const value = parseFloat(stat.value || stat.minValue || 0);
            
            // 다단 히트 적중 패턴 매칭
            if (value > 0 && 
                (name.includes('다단히트') || name.includes('다단 히트') || 
                 (name.includes('multi') && name.includes('hit')))) {
              baseMultiHitPercent += value;
              totalMultiHitPercent += value;
            }
          }
        });
      } else if (typeof item.main_stats === 'object') {
        for (const key of Object.keys(item.main_stats)) {
          const keyLower = key.toLowerCase();
          const value = parseFloat(item.main_stats[key] || 0);
          
          // 다단 히트 적중 패턴 매칭
          if (value > 0 && 
              (keyLower.includes('다단히트') || keyLower.includes('다단 히트') || 
               (keyLower.includes('multi') && keyLower.includes('hit')))) {
            baseMultiHitPercent += value;
            totalMultiHitPercent += value;
          }
        }
      }
    }
  });
  
  // 3. 데바니온 - 트리니엘 보드에서 다단 히트 적중 추출
  if (daevanionData && daevanionData[44]) {
    const boardData = daevanionData[44];
    let boardMultiHit = 0;
    
    if (boardData && boardData.nodeList) {
      const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
      
      activeNodes.forEach((node) => {
        let nodeMultiHit = 0;
        
        for (const key in node) {
          const value = node[key];
          
          if (typeof value === 'string' && value.trim()) {
            const text = value;
            let matches = text.match(/다단\s*히트\s*적중\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            if (!matches) {
              matches = text.match(/다단히트\s*적중\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            if (!matches) {
              matches = text.match(/multi.*hit.*accuracy\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            
            if (matches) {
              matches.forEach(match => {
                const numMatch = match.match(/(\d+\.?\d*)/);
                if (numMatch) {
                  const multiHitValue = parseFloat(numMatch[1]) || 0;
                  if (multiHitValue > 0) {
                    nodeMultiHit += multiHitValue;
                  }
                }
              });
            }
          }
          
          if (Array.isArray(value) && value.length > 0) {
            value.forEach((item) => {
              if (typeof item === 'object' && item !== null) {
                for (const itemKey in item) {
                  const itemValue = item[itemKey];
                  if (typeof itemValue === 'string' && itemValue.trim()) {
                    let matches = itemValue.match(/다단\s*히트\s*적중\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    if (!matches) {
                      matches = itemValue.match(/다단히트\s*적중\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    if (!matches) {
                      matches = itemValue.match(/multi.*hit.*accuracy\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    
                    if (matches) {
                      matches.forEach(match => {
                        const numMatch = match.match(/(\d+\.?\d*)/);
                        if (numMatch) {
                          const multiHitValue = parseFloat(numMatch[1]) || 0;
                          if (multiHitValue > 0) {
                            nodeMultiHit += multiHitValue;
                          }
                        }
                      });
                    }
                  }
                  
                  if ((itemKey === 'value' || itemKey === 'amount') && typeof itemValue === 'number' && itemValue > 0) {
                    const itemName = String(item.name || item.desc || item.type || '').toLowerCase();
                    if (itemName.includes('다단히트') || itemName.includes('다단 히트') || 
                        (itemName.includes('multi') && itemName.includes('hit'))) {
                      nodeMultiHit += itemValue;
                    }
                  }
                }
              }
            });
          }
        }
        
        if (nodeMultiHit > 0) {
          boardMultiHit += nodeMultiHit;
        }
      });
      
      if (boardMultiHit > 0) {
        daevanionMultiHitPercent = boardMultiHit;
        totalMultiHitPercent += boardMultiHit;
      }
    }
  }
  
  const result = {
    totalMultiHitPercent: totalMultiHitPercent,
    breakdown: {
      soulMultiHitPercent: soulMultiHitPercent,
      baseMultiHitPercent: baseMultiHitPercent,
      daevanionMultiHitPercent: daevanionMultiHitPercent
    }
  };
  
  // 전역 변수에 저장
  window.multiHitResult = result;
  
  // 다단 히트 적중 표시 업데이트
  displayMultiHitStats(result);
  
  return result;
}

// 다단 히트 적중 정보 표시 함수
function displayMultiHitStats(result) {
  const multiHitValue = document.getElementById('multi-hit-value');
  const tooltipSoul = document.getElementById('tooltip-soul-multi-hit');
  const tooltipBase = document.getElementById('tooltip-base-multi-hit');
  const tooltipDaevanion = document.getElementById('tooltip-daevanion-multi-hit');
  
  if (!multiHitValue) {
    return;
  }
  
  // result가 없으면 0으로 초기화
  if (!result || !result.breakdown) {
    multiHitValue.textContent = '+0.0%';
    if (tooltipSoul) tooltipSoul.textContent = '+0.0%';
    if (tooltipBase) tooltipBase.textContent = '+0.0%';
    if (tooltipDaevanion) tooltipDaevanion.textContent = '+0.0%';
    const multiHitContainer = document.getElementById('multi-hit-container');
    if (multiHitContainer) {
      multiHitContainer.style.display = 'block';
    }
    return;
  }
  
  const { totalMultiHitPercent, breakdown } = result;
  const { soulMultiHitPercent, baseMultiHitPercent, daevanionMultiHitPercent } = breakdown;
  // 최종 다단 히트 적중 표시 (base 18% 고려한 딜증 계산)


  // 최종 다단 히트 적중 표시 (항상 표시, 0%도 표시)
  multiHitValue.textContent = `+${totalMultiHitPercent.toFixed(1)}%`;


  // 툴팁 내용 업데이트
  if (tooltipSoul) tooltipSoul.textContent = `+${(soulMultiHitPercent || 0).toFixed(1)}%`;
  if (tooltipBase) tooltipBase.textContent = `+${(baseMultiHitPercent || 0).toFixed(1)}%`;
  if (tooltipDaevanion) tooltipDaevanion.textContent = `+${(daevanionMultiHitPercent || 0).toFixed(1)}%`;
  
  // 컨테이너 항상 표시
  const multiHitContainer = document.getElementById('multi-hit-container');
  if (multiHitContainer) {
    multiHitContainer.style.display = 'block';
  }
}

// 스킬 점수 계산 함수 (우선순위 기반)
// 초월 랭킹 1~100위 캐릭터들의 스킬 우선순위를 기반으로 점수 계산
async function calculateSkillDamage(skills, stigmas) {
  
  let totalSkillDamage = 0; // 총 스킬 점수
  let activeSkillDamage = 0; // 액티브 스킬 점수
  let passiveSkillDamage = 0; // 패시브 스킬 점수
  let stigmaSkillDamage = 0; // 스티그마 스킬 점수
  
  // 채용 가능한 스킬 개수
  const MAX_ACTIVE_SKILLS = 12;
  const MAX_PASSIVE_SKILLS = 10;
  const MAX_STIGMA_SKILLS = 11;
  
  // 현재 캐릭터의 직업 가져오기
  const currentJob = window.currentCharacterJob || null;
  
  if (!currentJob) {
    console.warn('[스킬 점수 계산] 직업 정보가 없습니다.');
    const result = {
      totalSkillDamage: 0,
      breakdown: {
        activeSkillDamage: 0,
        passiveSkillDamage: 0,
        stigmaSkillDamage: 0
      },
      details: {
        active: [],
        passive: [],
        stigma: []
      }
    };
    window.skillDamageResult = result;
    displaySkillDamageStats(result);
    return result;
  }
  
  // 스킬 우선순위 데이터 가져오기 (캐릭터 검색 시 이미 로드됨)
  let skillPriorities = window.currentSkillPriorities;
  
  if (!skillPriorities) {
    console.warn('[스킬 점수 계산] 스킬 우선순위 데이터가 없습니다.');
    skillPriorities = { active: [], passive: [], stigma: [] };
  }
  
  // 스킬 점수 계산 함수 (새로운 계산식)
  function calculateSkillScore(skillList, priorityList, maxSlots, skillType) {
    const details = [];
    let totalScore = 0;
    
    // 캐릭터가 보유한 스킬을 맵으로 변환
    const skillMap = {};
    skillList.forEach(skill => {
      const skillName = skill.name || '';
      const skillLevel = skill.level_int || parseInt(skill.level || '0', 10) || 0;
      if (skillLevel > 0) {
        skillMap[skillName] = skillLevel;
      }
    });
    
    // 채용률 10% 미만인 스킬 제외 (잘못된 데이터 필터링)
    const filteredPriorityList = priorityList.filter(p => (p.adoption_rate || 0) >= 10);
    
    // 스킬 타입별로 계산에 포함할 스킬 결정
    // 액티브: DB 상위 12개 (안 찍은 스킬은 0점)
    // 패시브: DB 상위 10개 (안 찍은 스킬은 0점)
    // 스티그마: 캐릭터가 찍은 스킬 중 레벨 높은 4개
    let effectivePriorityList = filteredPriorityList;
    if (skillType === 'stigma') {
      // 캐릭터가 찍은 스킬 중 레벨이 높은 순으로 정렬하여 상위 4개 선택
      const characterStigmas = filteredPriorityList
        .map(p => ({
          ...p,
          characterLevel: skillMap[p.skill_name] || 0
        }))
        .filter(p => p.characterLevel > 0)
        .sort((a, b) => {
          // 캐릭터 레벨 높은 순으로 정렬
          if (b.characterLevel !== a.characterLevel) {
            return b.characterLevel - a.characterLevel;
          }
          // 레벨이 같으면 DB priority 순
          return (a.priority || 0) - (b.priority || 0);
        })
        .slice(0, 4);  // 레벨 높은 상위 4개
      
      effectivePriorityList = characterStigmas;
    } else {
      // 액티브/패시브: DB 상위 maxSlots개 모두 (안 찍은 스킬은 0점 처리)
      effectivePriorityList = filteredPriorityList.slice(0, maxSlots);
    }
    
    // 우선순위 목록을 순회하며 점수 계산
    effectivePriorityList.forEach((prioritySkill, index) => {
      const skillName = prioritySkill.skill_name;
      // 스티그마는 DB의 원래 priority 사용, 그 외는 index+1 사용
      const priority = (skillType === 'stigma') ? (prioritySkill.priority || (index + 1)) : (index + 1);
      const adoptionRate = prioritySkill.adoption_rate;
      const averageLevel = prioritySkill.average_level;
      const characterSkillLevel = skillMap[skillName] || 0;
      
      if (characterSkillLevel === 0) {
        details.push({
          skillName: skillName,
          priority: priority,
          adoptionRate: adoptionRate,
          averageLevel: averageLevel,
          characterLevel: 0,
          baseScore: 0,
          bonusScore: 0,
          multiplier: 0,
          finalScore: 0,
          icon: prioritySkill.skill_icon
        });
        return;
      }
      
      // 1. 기본 점수 계산 (모든 스킬 타입 레벨당 1.5점)
      let baseScore = characterSkillLevel * 1.5;
      
      // 2. 보너스 점수 계산
      let bonusScore = 0;
      
      if (skillType === 'active') {
        // 액티브: 8/12/16/20 레벨 달성 시 +5/10/15/10
        if (characterSkillLevel >= 8) bonusScore += 5;
        if (characterSkillLevel >= 12) bonusScore += 10;
        if (characterSkillLevel >= 16) bonusScore += 15;
        if (characterSkillLevel >= 20) bonusScore += 10;
      } else if (skillType === 'stigma') {
        // 스티그마: 5/10/15/20 레벨 달성 시 +5/10/20/40
        if (characterSkillLevel >= 5) bonusScore += 5;
        if (characterSkillLevel >= 10) bonusScore += 10;
        if (characterSkillLevel >= 15) bonusScore += 20;
        if (characterSkillLevel >= 20) bonusScore += 40;
      }
      // 패시브는 보너스 없음
      
      // 3. 스킬 중요도 계수 계산
      let multiplier = 0.2; // 기본값 20%
      
      if (skillType === 'stigma') {
        // 스티그마: average_level 비율 기반 중요도
        // 채택률 10% 이상인 스킬 중 최고 average_level 찾기
        const maxAvgLevel = Math.max(...filteredPriorityList.map(p => p.average_level || 0));
        
        if (maxAvgLevel > 0 && averageLevel > 0) {
          // (해당 스킬 average_level / 최고 average_level) * 150%
          multiplier = (averageLevel / maxAvgLevel) * 1.5;
          // 최소 20% 보장
          multiplier = Math.max(0.2, multiplier);
        } else {
          multiplier = 0.2;
        }
      } else {
        // 액티브/패시브: 순차적 감소 (1순위 200% → 마지막 순위 20%)
        const maxMultiplier = 2.0; // 200%
        const minMultiplier = 0.2; // 20%
        const totalSlots = effectivePriorityList.length;
        
        if (totalSlots > 1) {
          const step = (maxMultiplier - minMultiplier) / (totalSlots - 1);
          multiplier = maxMultiplier - (index * step);
        } else {
          multiplier = maxMultiplier;
        }
        
        // 안전장치: 범위 제한
        multiplier = Math.max(minMultiplier, Math.min(maxMultiplier, multiplier));
      }
      
      // 4. 최종 점수: (기본 점수 + 보너스 점수) × 가산점
      const skillScore = (baseScore + bonusScore) * multiplier;
      totalScore += skillScore;
      
      details.push({
        skillName: skillName,
        priority: priority,
        adoptionRate: adoptionRate,
        averageLevel: averageLevel,
        characterLevel: characterSkillLevel,
        baseScore: baseScore,
        bonusScore: bonusScore,
        multiplier: multiplier,
        finalScore: skillScore,
        icon: prioritySkill.skill_icon
      });
    });
    
    // 최종 점수: 총합을 maxSlots로 나눔
    const finalScore = totalScore / maxSlots;
    
    return { score: finalScore, details: details, totalBeforeDivide: totalScore };
  }
  
  // 스킬 상세 정보 저장
  let activeDetails = [];
  let passiveDetails = [];
  let stigmaDetails = [];
  
  // 나누기 전의 총합을 저장할 변수
  let activeTotalBeforeDivide = 0;
  let passiveTotalBeforeDivide = 0;
  let stigmaTotalBeforeDivide = 0;
  
  // 1. 액티브 스킬 점수 계산
  if (Array.isArray(skills) && skills.length > 0) {
    const activeSkills = skills.filter(skill => {
      const group = detectSkillGroup(skill);
      return group === 'active';
    });
    
    const activeResult = calculateSkillScore(
      activeSkills,
      skillPriorities.active || [],
      MAX_ACTIVE_SKILLS,
      'active'
    );
    activeSkillDamage = activeResult.score;  // 개별 표시용 (12로 나눠진 값)
    activeTotalBeforeDivide = activeResult.totalBeforeDivide || 0;  // 나누기 전 총합
    activeDetails = activeResult.details;
  }
  
  // 2. 패시브 스킬 점수 계산
  if (Array.isArray(skills) && skills.length > 0) {
    const passiveSkills = skills.filter(skill => {
      const group = detectSkillGroup(skill);
      return group === 'passive';
    });
    
    const passiveResult = calculateSkillScore(
      passiveSkills,
      skillPriorities.passive || [],
      MAX_PASSIVE_SKILLS,
      'passive'
    );
    passiveSkillDamage = passiveResult.score;  // 개별 표시용 (10으로 나눠진 값)
    passiveTotalBeforeDivide = passiveResult.totalBeforeDivide || 0;  // 나누기 전 총합
    passiveDetails = passiveResult.details;
  }
  
  // 3. 스티그마 스킬 점수 계산
  if (Array.isArray(stigmas) && stigmas.length > 0) {
    const stigmaResult = calculateSkillScore(
      stigmas,
      skillPriorities.stigma || [],
      4,  // 스티그마는 상위 4개만 계산하므로 4로 나눔
      'stigma'
    );
    stigmaSkillDamage = stigmaResult.score;  // 개별 표시용 (4로 나눠진 값)
    stigmaTotalBeforeDivide = stigmaResult.totalBeforeDivide || 0;  // 나누기 전 총합
    stigmaDetails = stigmaResult.details;
  }
  
  // 총 스킬 점수 계산 (가중치는 이미 중요도 계수에 반영되어 있음)
  totalSkillDamage = activeSkillDamage + passiveSkillDamage + stigmaSkillDamage;
  
  const result = {
    totalSkillDamage: totalSkillDamage,
    breakdown: {
      activeSkillDamage: activeSkillDamage,
      passiveSkillDamage: passiveSkillDamage,
      stigmaSkillDamage: stigmaSkillDamage
    },
    details: {
      active: activeDetails,
      passive: passiveDetails,
      stigma: stigmaDetails
    }
  };
  
  // 전역 변수에 저장
  window.skillDamageResult = result;
  
  // 스킬 딜증 표시 업데이트
  displaySkillDamageStats(result);
  
  return result;
}

// 스킬 점수 정보 표시 함수
function displaySkillDamageStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const skillDamageValue = document.getElementById('skill-damage-value');
  const tooltipActive = document.getElementById('tooltip-active-skill-damage');
  const tooltipPassive = document.getElementById('tooltip-passive-skill-damage');
  const tooltipStigma = document.getElementById('tooltip-stigma-skill-damage');
  
  if (!skillDamageValue) {
    return;
  }
  
  const { totalSkillDamage, breakdown, details } = result;
  const { activeSkillDamage, passiveSkillDamage, stigmaSkillDamage } = breakdown;
  
  // 최종 스킬 점수 표시
  skillDamageValue.textContent = `+${totalSkillDamage.toFixed(1)}%`;

  // 툴팁 내용 업데이트 - 상세 정보가 있으면 표시
  if (tooltipActive) {
    if (details && details.active && details.active.length > 0) {
      const topSkills = details.active.slice(0, 6);
      let tooltipHtml = '<div style="font-weight: 600; margin-bottom: 0.5rem;">액티브 스킬 (우선순위 순)</div>';
      topSkills.forEach(skill => {
        const color = skill.characterLevel >= skill.averageLevel ? '#4ade80' : skill.characterLevel > 0 ? '#fbbf24' : '#ef4444';
        const multiplierPercent = (skill.multiplier * 100).toFixed(0);
        tooltipHtml += `<div style="font-size: 0.7rem; margin-bottom: 0.3rem; display: flex; justify-content: space-between; align-items: center;">
          <span style="display: flex; align-items: center; gap: 4px;">
            <span style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-size: 0.6rem; font-weight: 700; min-width: 16px; height: 16px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center;">${skill.priority}</span>
            ${skill.skillName}
          </span>
          <span style="color: ${color};">Lv.${skill.characterLevel} (${multiplierPercent}%)</span>
        </div>`;
      });
      if (details.active.length > 6) {
        tooltipHtml += `<div style="font-size: 0.65rem; color: var(--text-muted); margin-top: 0.3rem;">외 ${details.active.length - 6}개...</div>`;
      }
      tooltipHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1); font-size: 0.65rem; color: var(--text-muted);">※ 우선순위가 높을수록 중요도 증가</div>`;
      tooltipHtml += `<div style="margin-top: 0.3rem; font-weight: 600; color: #4ade80;">+${activeSkillDamage.toFixed(1)}%</div>`;
      tooltipActive.innerHTML = tooltipHtml;
    } else {
      tooltipActive.textContent = `+${activeSkillDamage.toFixed(1)}%`;
    }
  }
  
  if (tooltipPassive) {
    if (details && details.passive && details.passive.length > 0) {
      const topSkills = details.passive.slice(0, 6);
      let tooltipHtml = '<div style="font-weight: 600; margin-bottom: 0.5rem;">패시브 스킬 (우선순위 순)</div>';
      topSkills.forEach(skill => {
        const color = skill.characterLevel >= skill.averageLevel ? '#4ade80' : skill.characterLevel > 0 ? '#fbbf24' : '#ef4444';
        const multiplierPercent = (skill.multiplier * 100).toFixed(0);
        tooltipHtml += `<div style="font-size: 0.7rem; margin-bottom: 0.3rem; display: flex; justify-content: space-between; align-items: center;">
          <span style="display: flex; align-items: center; gap: 4px;">
            <span style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-size: 0.6rem; font-weight: 700; min-width: 16px; height: 16px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center;">${skill.priority}</span>
            ${skill.skillName}
          </span>
          <span style="color: ${color};">Lv.${skill.characterLevel} (${multiplierPercent}%)</span>
        </div>`;
      });
      if (details.passive.length > 6) {
        tooltipHtml += `<div style="font-size: 0.65rem; color: var(--text-muted); margin-top: 0.3rem;">외 ${details.passive.length - 6}개...</div>`;
      }
      tooltipHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1); font-size: 0.65rem; color: var(--text-muted);">※ 우선순위가 높을수록 중요도 증가</div>`;
      tooltipHtml += `<div style="margin-top: 0.3rem; font-weight: 600; color: #f472b6;">+${passiveSkillDamage.toFixed(1)}%</div>`;
      tooltipPassive.innerHTML = tooltipHtml;
    } else {
      tooltipPassive.textContent = `+${passiveSkillDamage.toFixed(1)}%`;
    }
  }
  
  if (tooltipStigma) {
    if (details && details.stigma && details.stigma.length > 0) {
      const topSkills = details.stigma.slice(0, 6);
      let tooltipHtml = '<div style="font-weight: 600; margin-bottom: 0.5rem;">스티그마 스킬 (우선순위 순)</div>';
      topSkills.forEach(skill => {
        const color = skill.characterLevel >= skill.averageLevel ? '#4ade80' : skill.characterLevel > 0 ? '#fbbf24' : '#ef4444';
        const multiplierPercent = (skill.multiplier * 100).toFixed(0);
        tooltipHtml += `<div style="font-size: 0.7rem; margin-bottom: 0.3rem; display: flex; justify-content: space-between; align-items: center;">
          <span style="display: flex; align-items: center; gap: 4px;">
            <span style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; font-size: 0.6rem; font-weight: 700; min-width: 16px; height: 16px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center;">${skill.priority}</span>
            ${skill.skillName}
          </span>
          <span style="color: ${color};">Lv.${skill.characterLevel} (${multiplierPercent}%)</span>
        </div>`;
      });
      if (details.stigma.length > 6) {
        tooltipHtml += `<div style="font-size: 0.65rem; color: var(--text-muted); margin-top: 0.3rem;">외 ${details.stigma.length - 6}개...</div>`;
      }
      tooltipHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255,255,255,0.1); font-size: 0.65rem; color: var(--text-muted);">※ 우선순위가 높을수록 중요도 증가</div>`;
      tooltipHtml += `<div style="margin-top: 0.3rem; font-weight: 600; color: #fb923c;">+${stigmaSkillDamage.toFixed(1)}%</div>`;
      tooltipStigma.innerHTML = tooltipHtml;
    } else {
      tooltipStigma.textContent = `+${stigmaSkillDamage.toFixed(1)}%`;
    }
  }
  
  // 컨테이너 표시
  const skillDamageContainer = document.getElementById('skill-damage-container');
  if (skillDamageContainer) {
    skillDamageContainer.style.display = 'block';
  }
}

// 재사용 대기 시간 감소 계산 함수
function calculateCooldownReduction(statData, daevanionData, titles) {
  let totalCooldownReduction = 0;
  let titleCooldownReduction = 0;
  let illusionCooldownReduction = 0;
  let daevanionCooldownReduction = 0;
  
  // 1. 타이틀 장착 효과에서 재사용 시간 감소 추출
  if (titles && Array.isArray(titles)) {
    titles.forEach((title) => {
      const titleName = title.name || '알 수 없음';
      
      if (title.equip_effects && Array.isArray(title.equip_effects)) {
        title.equip_effects.forEach((effect) => {
          const effectText = String(effect || '');
          
          // 재사용 시간 감소 패턴 매칭
          let matches = effectText.match(/(?:재사용\s*시간\s*감소|재사용시간감소)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          if (!matches) {
            matches = effectText.match(/cooldown\s*reduction\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
          }
          
          if (matches) {
            matches.forEach(match => {
              const numMatch = match.match(/(\d+\.?\d*)/);
              if (numMatch) {
                const reductionValue = parseFloat(numMatch[1]) || 0;
                if (reductionValue > 0) {
                  titleCooldownReduction += reductionValue;
                  totalCooldownReduction += reductionValue;
                }
              }
            });
          }
        });
      }
    });
  }
  
  // 2. 주신 스탯 - 환상[카이시넬]에서 재사용 시간 감소 추출
  // 스탯 값 × 0.1% × 2배 = 스탯 값 × 0.2%
  if (statData && statData.statList) {
    const illusionStat = statData.statList.find(stat => 
      stat.type === 'Illusion' || (stat.name && (stat.name.includes('환상') || stat.name.includes('Illusion') || stat.name.includes('카이시넬') || stat.name.includes('Kaisinel')))
    );
    
    if (illusionStat) {
      const illusionValue = parseInt(illusionStat.value || 0);
      if (illusionValue > 0) {
        // 스탯 1당 0.2% (0.1% × 2배)
        illusionCooldownReduction = illusionValue * 0.2;
        totalCooldownReduction += illusionCooldownReduction;
      }
    }
  }
  
  // 3. 데바니온 네자칸(41) 보드에서 재사용 시간 감소 추출
  if (daevanionData && daevanionData[41]) {
    const boardData = daevanionData[41];
    let boardCooldownReduction = 0;
    
    if (boardData && boardData.nodeList) {
      const activeNodes = boardData.nodeList.filter(n => parseInt(n.open || 0) === 1);
      
      activeNodes.forEach((node) => {
        let nodeCooldownReduction = 0;
        
        for (const key in node) {
          const value = node[key];
          
          if (typeof value === 'string' && value.trim()) {
            const text = value;
            let matches = text.match(/(?:재사용\s*시간\s*감소|재사용시간감소)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            if (!matches) {
              matches = text.match(/cooldown\s*reduction\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
            }
            
            if (matches) {
              matches.forEach(match => {
                const numMatch = match.match(/(\d+\.?\d*)/);
                if (numMatch) {
                  const speedValue = parseFloat(numMatch[1]) || 0;
                  if (speedValue > 0) {
                    nodeCooldownReduction += speedValue;
                  }
                }
              });
            }
          }
          
          if (Array.isArray(value) && value.length > 0) {
            value.forEach((item) => {
              if (typeof item === 'object' && item !== null) {
                for (const itemKey in item) {
                  const itemValue = item[itemKey];
                  if (typeof itemValue === 'string' && itemValue.trim()) {
                    let matches = itemValue.match(/(?:재사용\s*시간\s*감소|재사용시간감소)\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    if (!matches) {
                      matches = itemValue.match(/cooldown\s*reduction\s*[+＋]\s*(\d+\.?\d*)\s*%/gi);
                    }
                    
                    if (matches) {
                      matches.forEach(match => {
                        const numMatch = match.match(/(\d+\.?\d*)/);
                        if (numMatch) {
                          const speedValue = parseFloat(numMatch[1]) || 0;
                          if (speedValue > 0) {
                            nodeCooldownReduction += speedValue;
                          }
                        }
                      });
                    }
                  }
                }
              }
            });
          }
        }
        
        if (nodeCooldownReduction > 0) {
          boardCooldownReduction += nodeCooldownReduction;
        }
      });
      
      if (boardCooldownReduction > 0) {
        daevanionCooldownReduction = boardCooldownReduction;
        totalCooldownReduction += daevanionCooldownReduction;
      }
    }
  }
  
  const result = {
    totalCooldownReduction: totalCooldownReduction,
    breakdown: {
      titleCooldownReduction: titleCooldownReduction,
      illusionCooldownReduction: illusionCooldownReduction,
      daevanionCooldownReduction: daevanionCooldownReduction
    }
  };
  
  window.cooldownReductionResult = result;
  displayCooldownReductionStats(result);
  
  return result;
}

// 재사용 대기 시간 감소 정보 표시 함수
function displayCooldownReductionStats(result) {
  if (!result || !result.breakdown) {
    return;
  }
  
  const cooldownReductionValue = document.getElementById('cooldown-reduction-value');
  const tooltipTitle = document.getElementById('tooltip-title-cooldown');
  const tooltipIllusion = document.getElementById('tooltip-illusion-cooldown');
  const tooltipDaevanion = document.getElementById('tooltip-daevanion-cooldown');
  
  if (!cooldownReductionValue) {
    return;
  }
  
  const { totalCooldownReduction, breakdown } = result;
  const { titleCooldownReduction, illusionCooldownReduction, daevanionCooldownReduction } = breakdown;
  
  // 최종 재사용 대기 시간 감소 표시
  cooldownReductionValue.textContent = `+${totalCooldownReduction.toFixed(1)}%`;


  // 툴팁 내용 업데이트
  if (tooltipTitle) tooltipTitle.textContent = `+${titleCooldownReduction.toFixed(1)}%`;
  if (tooltipIllusion) tooltipIllusion.textContent = `+${illusionCooldownReduction.toFixed(1)}%`;
  if (tooltipDaevanion) tooltipDaevanion.textContent = `+${daevanionCooldownReduction.toFixed(1)}%`;
  
  // 컨테이너 표시
  const cooldownReductionContainer = document.getElementById('cooldown-reduction-container');
  if (cooldownReductionContainer) {
    cooldownReductionContainer.style.display = 'block';
  }
}

// DPS 점수 계산 함수
function calculateDpsScore(searchId) {
  // 검색 ID 검증: 다른 캐릭터 검색이 진행 중이면 무시 (동시 검색 시 데이터 충돌 방지)
  if (searchId && searchId !== window.currentSearchId) {
    console.debug('[calculateDpsScore] 검색 ID 불일치로 건너뜀:', searchId, '!==', window.currentSearchId);
    return;
  }
  
  // ★★★ 버그 수정: 캐릭터 정보를 함수 시작 시점에 즉시 캡처 (동시 검색 시 데이터 충돌 방지)
  // 이전에는 함수 중간에서 캡처했기 때문에, 스탯 계산 중에 다른 검색이 시작되면 전역 변수가 덮어써지는 문제가 있었음
  const capturedNickname = window.currentCharacterNickname;
  const capturedServer = window.currentCharacterServer;
  const capturedRace = window.currentCharacterRace;
  const capturedSearchIdForSave = searchId || window.currentSearchId;
  const capturedIsCacheMiss = window.isCacheMiss;
  const capturedCombatScoreMax = window.currentCombatScoreMax;
  
  // 각 계산 결과 가져오기
  const attackPowerResult = window.attackPowerResult;
  const combatSpeedResult = window.combatSpeedResult;
  const damageAmplificationResult = window.damageAmplificationResult;
  const skillDamageResult = window.skillDamageResult;
  const cooldownReductionResult = window.cooldownReductionResult;
  const perfectResult = window.perfectResult;
  const stunHitResult = window.stunHitResult;
  const multiHitResult = window.multiHitResult;
  
  if (!attackPowerResult || !combatSpeedResult || !damageAmplificationResult || !skillDamageResult || !cooldownReductionResult) {
    return;
  }
  
  // ★ 공격력 % 캡 적용: 캡 초과 시 캡 적용 공격력 사용
  const rawAttackPower = attackPowerResult.finalAttack || 0;
  const attackPower = (window.isAttackPowerOverCap && window.cappedAttackPower) ? window.cappedAttackPower : rawAttackPower;
  // 4가지 피해 증폭을 합쳐서 사용
  const totalDamageAmpPercent = damageAmplificationResult.finalDamageAmpPercent || damageAmplificationResult.totalDamageAmpPercent || 0;
  const damageAmplification = totalDamageAmpPercent / 100; // 퍼센트를 소수로 변환
  const skillDamage = (skillDamageResult.totalSkillDamage || 0) / 100; // 퍼센트를 소수로 변환
  const combatSpeed = (combatSpeedResult.totalCombatSpeed || 0) / 100; // 퍼센트를 소수로 변환
  const cooldownReduction = (cooldownReductionResult.totalCooldownReduction || 0) / 100; // 퍼센트를 소수로 변환
  
  // 완벽 계수: 확률 × 0.25 (1.25배 데미지 → 추가분 0.25)
  const perfectPercent = perfectResult ? (perfectResult.totalPerfectPercent || 0) : 0;
  const perfectCoefficient = (perfectPercent / 100) * 0.25;
  
  // 강타 계수: 확률 × 1.0 (2배 데미지 → 추가분 1.0)
  const stunHitPercent = stunHitResult ? (stunHitResult.totalStunHitPercent || 0) : 0;
  const stunHitCoefficient = (stunHitPercent / 100) * 1.0;
  
  // 다단 히트 적중 계수 계산: y = 11.1x + 13.9x^2 + 17.8x^3 + 23.9x^4
  // x는 다단 히트 적중 퍼센트를 소수로 변환한 값 (예: 11% = 0.11)
  const multiHitPercent = multiHitResult ? (multiHitResult.totalMultiHitPercent || 0) : 0;
  const x = multiHitPercent / 100; // 퍼센트를 소수로 변환
  let multiHitCoefficient = 0;
  if (x > 0) {
    // y = 11.1x + 13.9x^2 + 17.8x^3 + 23.9x^4
    const x2 = x * x;
    const x3 = x2 * x;
    const x4 = x3 * x;
    const y = 11.1 * x + 13.9 * x2 + 17.8 * x3 + 23.9 * x4;
    // y는 추가 피해 증폭 퍼센트이므로 소수로 변환하여 계수로 사용
    multiHitCoefficient = y / 100;
  }
  
  // DPS 점수 계산: 공격력 × (1 + 피해 증폭) × (1 + 스킬 딜증) × (1 / (1 - 전투 속도)) × (1 / (1 - 쿨타임 감소)) × (1 + 완벽 계수) × (1 + 강타 계수) × (1 + 다단 히트 계수)
  // 전투 속도와 쿨타임 감소는 0보다 작거나 1 이상이면 안됨
  const combatSpeedFactor = combatSpeed >= 1 ? 1 : (combatSpeed <= 0 ? 1 : (1 / (1 - combatSpeed)));
  const cooldownReductionFactor = cooldownReduction >= 1 ? 1 : (cooldownReduction <= 0 ? 1 : (1 / (1 - cooldownReduction)));
  
  const baseDps = attackPower * (1 + damageAmplification) * (1 + skillDamage) * combatSpeedFactor * cooldownReductionFactor;
  const dpsScore = baseDps * (1 + perfectCoefficient) * (1 + stunHitCoefficient) * (1 + multiHitCoefficient);
  
  // DPS 점수 표시는 updateAllDamageIncreaseBadges()에서 계산된 점수로 대체되므로 여기서는 표시하지 않음
  // 계산된 점수는 updateAllDamageIncreaseBadges()에서 표시
  const sectionContainer = document.getElementById('dps-stats-info');
  
  if (sectionContainer) {
    sectionContainer.style.display = 'block';
  }
  
  // 광고 표시 및 초기화
  const adContainer = document.getElementById('character-search-ad');
  if (adContainer && adContainer.style.display === 'none') {
    adContainer.style.display = 'block';
    // 광고 초기화 (한 번만 실행)
    try {
      (adsbygoogle = window.adsbygoogle || []).push({});
    } catch (e) {
      console.error('AdSense error:', e);
    }
  }
  
  // updateAllDamageIncreaseBadges()를 호출하여 딜증 배지 업데이트 및 계산된 점수 표시
  // 이 함수가 최종적으로 계산된 전투 점수를 화면에 표시하고 반환함
  const badgesResult = updateAllDamageIncreaseBadges();
  
  // 계산된 전투 점수 가져오기 (DOM 파싱 대신 반환값 직접 사용 - 데이터 혼입 방지)
  let calculatedCombatScore = 0;
  if (badgesResult && Number.isFinite(badgesResult.finalCombatScore) && badgesResult.finalCombatScore > 0) {
    calculatedCombatScore = Math.round(badgesResult.finalCombatScore);
  } else {
    // fallback: DOM 파싱 (badgesResult가 없거나 유효하지 않은 경우)
    calculatedCombatScore = parseFloat(document.getElementById('dps-score-value')?.textContent?.replace(/,/g, '').replace(/[^0-9.-]/g, '')) || Math.round(dpsScore);
    console.warn('[calculateDpsScore] badgesResult 없음, DOM fallback 사용:', calculatedCombatScore);
  }
  
  // 최종 검증: 유효하지 않은 값이면 저장하지 않음
  if (!Number.isFinite(calculatedCombatScore) || calculatedCombatScore <= 0) {
    console.error('[calculateDpsScore] 최종 전투 점수 유효하지 않음:', calculatedCombatScore);
    calculatedCombatScore = 0;
  }
  
  // 전투 점수를 DB에 저장하는 부분은 일시적으로 주석 처리 (나중에 다시 사용)
  // 하지만 랭킹 정보, 구간 정보, 최고 점수 표시는 계속 실행
  
  // 스탯 데이터 수집
  const combatStatsData = {};
  
  // 공격력
  if (attackPowerResult && attackPowerResult.finalAttack) {
    combatStatsData.attack_power = attackPowerResult.finalAttack;
  }
  
  // 치명타 (화면에 표시되는 실제 확률 값 사용)
  // criticalHitResult에서 criticalChancePercent를 계산하여 사용
  if (window.criticalHitResult && window.criticalHitResult.breakdown) {
    const { baseCriticalHitInteger, soulCriticalHitInteger, stoneCriticalHitInteger, daevanionCriticalHitInteger, deathCriticalHitPercent, accuracyCriticalHitPercent } = window.criticalHitResult.breakdown;
    // 최종 치명타 정수 계산: (정수 합계) * (1 + (주신 스탯 퍼센트 + 일반 스탯 퍼센트)/100)
    const totalCriticalHitInteger = baseCriticalHitInteger + soulCriticalHitInteger + stoneCriticalHitInteger + daevanionCriticalHitInteger;
    const totalPercentMultiplier = 1 + ((deathCriticalHitPercent + accuracyCriticalHitPercent) / 100);
    const finalCriticalHitInteger = Math.round(totalCriticalHitInteger * totalPercentMultiplier);
    // 최종 치명타를 확률로 변환 (대만 커뮤니티 테이블 기반)
    const criticalChancePercent = convertCritStatToChance(finalCriticalHitInteger);
    combatStatsData.critical_hit = criticalChancePercent;
  } else if (window.criticalHitResult && window.criticalHitResult.totalCriticalHitPercent !== undefined) {
    // fallback: totalCriticalHitPercent 사용
    combatStatsData.critical_hit = window.criticalHitResult.totalCriticalHitPercent;
  }
  
  // 전투 속도
  if (combatSpeedResult && combatSpeedResult.totalCombatSpeed !== undefined) {
    combatStatsData.combat_speed = combatSpeedResult.totalCombatSpeed;
  }
  
  // 무기 피해 증폭
  if (damageAmplificationResult && damageAmplificationResult.weaponDamageAmp && damageAmplificationResult.weaponDamageAmp.totalPercent !== undefined) {
    combatStatsData.weapon_damage_amplification = damageAmplificationResult.weaponDamageAmp.totalPercent;
  }
  
  // 피해 증폭 (PVE 피해 증폭 + 일반 피해 증폭 합산)
  if (damageAmplificationResult && damageAmplificationResult.pveDamageAmp && damageAmplificationResult.damageAmp) {
    const totalDamageAmp = (damageAmplificationResult.pveDamageAmp.totalPercent || 0) + (damageAmplificationResult.damageAmp.totalPercent || 0);
    combatStatsData.damage_amplification = totalDamageAmp;
  } else if (damageAmplificationResult && damageAmplificationResult.finalDamageAmpPercent !== undefined) {
    // fallback
    combatStatsData.damage_amplification = damageAmplificationResult.finalDamageAmpPercent;
  }
  
  // 치명타 피해 증폭
  if (damageAmplificationResult && damageAmplificationResult.criticalDamageAmp && damageAmplificationResult.criticalDamageAmp.totalPercent !== undefined) {
    combatStatsData.critical_damage_amplification = damageAmplificationResult.criticalDamageAmp.totalPercent;
  }
  
  // 스킬
  if (skillDamageResult && skillDamageResult.totalSkillDamage !== undefined) {
    combatStatsData.skill_damage = skillDamageResult.totalSkillDamage;
  }
  
  // 재사용 대기 시간 감소
  if (cooldownReductionResult && cooldownReductionResult.totalCooldownReduction !== undefined) {
    combatStatsData.cooldown_reduction = cooldownReductionResult.totalCooldownReduction;
  }
  
  // 강타
  if (stunHitResult && stunHitResult.totalStunHitPercent !== undefined) {
    combatStatsData.stun_hit = stunHitResult.totalStunHitPercent;
  }
  
  // 완벽
  if (perfectResult && perfectResult.totalPerfectPercent !== undefined) {
    combatStatsData.perfect = perfectResult.totalPerfectPercent;
  }
  
  // 다단 히트 적중
  if (multiHitResult && multiHitResult.totalMultiHitPercent !== undefined) {
    combatStatsData.multi_hit = multiHitResult.totalMultiHitPercent;
  }
  
  // DB 저장 부분 (캐시 미스이거나 갱신하기 버튼을 눌렀을 때)
  const wasForceRefresh = window.wasForceRefresh === true; // performSearch에서 설정된 값 사용
  
  // ★ 캐릭터 정보는 함수 시작 시점에 이미 캡처되어 있음 (capturedNickname, capturedServer, capturedRace 등)
  // ★ 이전 코드에서는 여기서 캡처했지만, 동시 검색 시 스탯 계산 중에 전역 변수가 덮어써지는 버그가 있었음
  
  if (capturedNickname && capturedServer && capturedRace && (capturedIsCacheMiss || wasForceRefresh)) {
    // 캐릭터 정보를 파라미터로 전달 (동시 검색 시 데이터 충돌 방지)
    const characterInfo = {
      nickname: capturedNickname,
      server: capturedServer,
      race: capturedRace,
      isCacheMiss: capturedIsCacheMiss
    };
    saveCombatScore(Math.round(calculatedCombatScore), combatStatsData, wasForceRefresh, characterInfo)
      .then((result) => {
        // 검색 ID가 변경되었으면 다른 캐릭터 검색이 진행 중이므로 후속 처리 건너뜀
        if (capturedSearchIdForSave !== window.currentSearchId) {
          console.debug('[saveCombatScore] 검색 ID 불일치로 후속 처리 건너뜀');
          return;
        }
        
        // 저장 완료 후 약간의 지연을 두고 랭킹 정보 로드 (DB 반영 시간 고려)
        setTimeout(() => {
          // 검색 ID 재검증
          if (capturedSearchIdForSave !== window.currentSearchId) return;
          
          if (capturedNickname && capturedServer && capturedRace && calculatedCombatScore > 0) {
            loadCombatScoreRankingsInfo(capturedNickname, capturedServer, capturedRace);
            // 전투력 구간 정보도 로드
            loadCombatScorePowerRangeInfo(Math.round(calculatedCombatScore));
            // 스탯별 퍼센타일 정보 로드 (캐시 미스일 때만, 갱신하기 버튼 클릭 시에는 호출 안 함)
            if (capturedIsCacheMiss && !wasForceRefresh) {
              loadCombatStatsPercentiles(capturedNickname, capturedServer, capturedRace);
            }
          }
        }, 500);
        
        // 달성 최고 점수 표시 (API 응답에서 받은 값)
        if (result && result.combat_score_max !== undefined && result.combat_score_max !== null && result.combat_score_max > 0) {
          displayCombatScoreMaxInfo(result.combat_score_max);
        }
      })
      .catch(err => {
      });
  } else {
  
  
  // DB 저장 없이 랭킹 정보, 구간 정보 로드 (캐시 히트인 경우만)
  // 캐시 미스이거나 갱신하기를 눌렀을 때는 이미 위의 saveCombatScore의 then 블록에서 로드됨
  // 캡처된 값 사용 (동시 검색 시 데이터 충돌 방지)
  if (capturedNickname && capturedServer && capturedRace && calculatedCombatScore > 0 && !capturedIsCacheMiss && !wasForceRefresh) {
    // 랭킹 정보 로드
    loadCombatScoreRankingsInfo(capturedNickname, capturedServer, capturedRace);
    // 전투력 구간 정보도 로드
    loadCombatScorePowerRangeInfo(Math.round(calculatedCombatScore));
    // 스탯별 퍼센타일 정보 로드
    loadCombatStatsPercentiles(capturedNickname, capturedServer, capturedRace);
    
    // 최고 점수 표시 (전역 변수에 저장된 값 사용)
    if (window.currentCombatScoreMax !== undefined && window.currentCombatScoreMax !== null && window.currentCombatScoreMax > 0) {
      displayCombatScoreMaxInfo(window.currentCombatScoreMax);
    } else {
      displayCombatScoreMaxInfo(null);
    }
  }
  
  // wasForceRefresh 플래그 초기화 (calculateDpsScore 완료 후)
  window.wasForceRefresh = false;
  
  }
  
}

// 소수점 반올림 헬퍼 함수
function round(value, decimals) {
  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
}

// 치명타 스탯을 실제 확률로 변환하는 함수
// 공식: (스탯 × 0.7) / 10 = 확률%
function convertCritStatToChance(critStat) {
  // 스탯 × 0.7 / 10 = 확률%
  // 예: 924 × 0.7 = 646.8 / 10 = 64.68%
  const chance = (critStat * 0.7) / 10;
  return chance;
}

// 달성 최고 점수 표시 함수
// ★ 버그 수정: score_updated_at 파라미터 제거 (캐릭터 상세 페이지에서 "N시간 전" 표시는 의도된 기능이 아님)
// ★ 홈화면 캐릭터 카드의 시간 표시는 displayAllServersResults 함수에서 별도로 처리됨
function displayCombatScoreMaxInfo(combatScoreMax) {
  const maxInfo = document.getElementById('combat-score-max-info');
  if (!maxInfo) {
    return;
  }
  
  if (combatScoreMax && combatScoreMax > 0) {
    maxInfo.innerHTML = `달성 최고 점수: <strong style="color: #a78bfa;">${Math.round(combatScoreMax).toLocaleString()}</strong>`;
    maxInfo.style.display = 'block';
  } else {
    maxInfo.style.display = 'none';
    maxInfo.innerHTML = ''; // 내용도 초기화
  }
}

// 전투력 구간 대비 전투 점수 상위% 정보 표시 함수 (서버에서 받은 데이터 사용)
function displayCombatScorePowerRangeInfo(powerRangeData) {
  const powerRangeInfo = document.getElementById('combat-score-power-range-info');
  if (!powerRangeInfo) {
    return;
  }
  
  if (powerRangeData && powerRangeData.power_range && powerRangeData.rank && powerRangeData.total && powerRangeData.top_percent !== undefined) {
    const { power_range, rank, total, top_percent } = powerRangeData;
    powerRangeInfo.innerHTML = `내 전투력 구간 (${power_range.min}~${power_range.max}) 전투 점수 상위 <strong style="color: #fbbf24;">${top_percent}%</strong> (${rank}/${total})<br><span style="font-size: 0.85rem; color: #ff6b6b;">※ 점수가 갱신이 되지 않는 경우, 위 갱신하기 버튼을 눌러주세요.</span><br><span style="font-size: 0.8rem; color: #a78bfa;">12월31일 업데이트로 스킬로 인한 점수 계산이 초월 랭커 1~100위의 주요 채용 스킬 기반으로 수정됨에 따라 점수가 변동되었을 수 있습니다.</span>`;
    powerRangeInfo.style.display = 'block';
  } else {
    powerRangeInfo.style.display = 'none';
  }
}

// 전투력 구간 대비 전투 점수 상위% 정보 로드 함수 (API 호출, 캐시 미스 시에만 사용)
function loadCombatScorePowerRangeInfo(combatScore) {
  if (!combatScore || combatScore <= 0) {
    return;
  }
  
  // 전투력 가져오기
  const combatPowerEl = document.getElementById('result-combat-power');
  let combatPower = null;
  if (combatPowerEl && combatPowerEl.textContent) {
    combatPower = parseInt(combatPowerEl.textContent.replace(/,/g, '')) || null;
  }
  if (!combatPower) {
    combatPower = window.currentCombatPower || window.characterData?.combat_power;
  }
  
  if (!combatPower || combatPower <= 0) {
    return;
  }
  
  const combatPowerInt = parseInt(String(combatPower).replace(/,/g, '')) || 0;
  if (combatPowerInt <= 0) {
    return;
  }
  
  // API 호출 (캐시 미스 시에만)
  fetch(`/api/character/combat-score-power-range-percentile?combat_power=${combatPowerInt}&combat_score=${combatScore}`)
    .then(response => response.json())
    .then(data => {
      if (data.success && data.data) {
        displayCombatScorePowerRangeInfo(data.data);
      } else {
        const powerRangeInfo = document.getElementById('combat-score-power-range-info');
        if (powerRangeInfo) {
          powerRangeInfo.style.display = 'none';
        }
      }
    })
    .catch(err => {
      const powerRangeInfo = document.getElementById('combat-score-power-range-info');
      if (powerRangeInfo) {
        powerRangeInfo.style.display = 'none';
      }
    });
}

// 스탯별 퍼센타일 정보 로드 및 표시 함수 (백분위수 캐시 활용)
function loadCombatStatsPercentiles(nickname, server, race) {
  if (!nickname || !server) {
    return;
  }
  
  // race가 없으면 빈 문자열로 전달
  const raceParam = race || '';
  
  fetch(`/api/character/combat-stats-percentiles?nickname=${encodeURIComponent(nickname)}&server=${encodeURIComponent(server)}&race=${encodeURIComponent(raceParam)}`)
    .then(response => {
      if (!response.ok) {
        // 404 등의 에러 발생 시 빈 데이터로 처리
        return { success: true, data: {} };
      }
      return response.json();
    })
    .then(data => {
      if (data.success && data.data && Object.keys(data.data).length > 0) {
        displayCombatStatsPercentiles(data.data);
      }
      // 스탯 정보가 없으면 표시하지 않음 (기본 상태 유지)
    })
    .catch(err => {
      // 에러 발생 시 무시 (스탯 정보가 없는 경우 정상)
      console.debug('[loadCombatStatsPercentiles] 스탯 퍼센타일 정보 없음:', err);
    });
}

// 스탯별 퍼센타일 표시 함수
function displayCombatStatsPercentiles(percentiles) {
  if (!percentiles) return;
  
  // 스탯 ID와 DB 컬럼명 매핑
  const statMapping = {
    'attack_power': 'attack-power',
    // 'critical_hit': 'critical-hit', // 치명타 확률은 percentile 표시 안 함
    'combat_speed': 'combat-speed',
    'weapon_damage_amplification': 'weapon-damage-amplification',
    'damage_amplification': 'damage-amplification',
    'critical_damage_amplification': 'critical-damage-amplification',
    'skill_damage': 'skill-damage',
    'cooldown_reduction': 'cooldown-reduction',
    'stun_hit': 'stun-hit',
    'perfect': 'perfect',
    'multi_hit': 'multi-hit'
  };
  
  // 각 스탯별로 퍼센타일 표시
  Object.keys(statMapping).forEach(dbColumn => {
    const elementId = statMapping[dbColumn];
    const percentileEl = document.getElementById(`${elementId}-percentile`);
    
    if (percentileEl && percentiles[dbColumn] && percentiles[dbColumn].percentile !== undefined && percentiles[dbColumn].percentile !== null) {
      const percentile = percentiles[dbColumn].percentile;
      percentileEl.textContent = `(상위 ${percentile.toFixed(2)}%)`;
      percentileEl.style.display = 'block';
    } else if (percentileEl) {
      percentileEl.textContent = '';
      percentileEl.style.display = 'none';
    }
  });
}

// 전투 점수 랭킹 정보 로드 함수
function loadCombatScoreRankingsInfo(nickname, server, race) {
  if (!nickname || !server || !race) {
    return;
  }
  
  const params = new URLSearchParams({
    nickname: nickname,
    server: server,
    race: race
  });
  
  fetch(`/api/character/combat-score-rankings?${params.toString()}`)
    .then(response => response.json())
    .then(data => {
      if (data.success && data.data) {
        // 디버깅: 받은 데이터 확인
        displayCombatScoreRankingsInfo(data.data);
      } else {
        // 랭킹 정보가 없으면 컨테이너 숨김
        const rankingsInfo = document.getElementById('combat-score-rankings-info');
        if (rankingsInfo) {
          rankingsInfo.style.display = 'none';
        }
        const rankingNotice = document.getElementById('combat-score-ranking-notice');
        if (rankingNotice) {
          rankingNotice.style.display = 'none';
        }
      }
    })
    .catch(err => {
      // 에러 발생 시 컨테이너 숨김
      const rankingsInfo = document.getElementById('combat-score-rankings-info');
      if (rankingsInfo) {
        rankingsInfo.style.display = 'none';
      }
      const rankingNotice = document.getElementById('combat-score-ranking-notice');
      if (rankingNotice) {
        rankingNotice.style.display = 'none';
      }
    });
}

// 전투 점수 랭킹 정보 표시 함수
function displayCombatScoreRankingsInfo(rankingsData) {
  const rankingsInfo = document.getElementById('combat-score-rankings-info');
  const overallPercentileEl = document.getElementById('combat-score-overall-percentile');
  const jobRankEl = document.getElementById('combat-score-job-rank');
  const serverRankEl = document.getElementById('combat-score-server-rank');
  
  if (!rankingsInfo) {
    return;
  }
  
  // 랭킹 정보 컨테이너 표시
  rankingsInfo.style.display = 'block';
  
  // 전체 랭킹 표시: "X위 / Y명 상위 Z%"
  if (overallPercentileEl) {
    if (rankingsData.overall_rank !== null && rankingsData.overall_rank !== undefined && 
        rankingsData.overall_total > 0 && 
        rankingsData.overall_percentile !== null && rankingsData.overall_percentile !== undefined) {
      overallPercentileEl.textContent = `${rankingsData.overall_rank}위 / ${rankingsData.overall_total}명 (상위 ${rankingsData.overall_percentile}%)`;
    } else {
      overallPercentileEl.textContent = '-';
    }
  }
  
  // 직업 랭킹 표시: "X위 / Y명 상위 Z%"
  if (jobRankEl) {
    if (rankingsData.job_rank !== null && rankingsData.job_rank !== undefined && 
        rankingsData.job_total > 0) {
      
      const jobPercentile = rankingsData.job_percentile !== null && rankingsData.job_percentile !== undefined 
        ? rankingsData.job_percentile 
        : (rankingsData.job_total > 0 && rankingsData.job_rank > 0 
          ? round((rankingsData.job_rank - 1) / rankingsData.job_total * 100, 2) 
          : 0);
      jobRankEl.textContent = `${rankingsData.job_rank}위 / ${rankingsData.job_total}명 (상위 ${jobPercentile}%)`;
    } else {
      jobRankEl.textContent = '-';
    }
  }
  
  // 서버 랭킹 표시: "X위 / Y명 상위 Z%"
  if (serverRankEl) {
    if (rankingsData.server_rank !== null && rankingsData.server_rank !== undefined && 
        rankingsData.server_total > 0) {
      
      const serverPercentile = rankingsData.server_percentile !== null && rankingsData.server_percentile !== undefined 
        ? rankingsData.server_percentile 
        : (rankingsData.server_total > 0 && rankingsData.server_rank > 0 
          ? round((rankingsData.server_rank - 1) / rankingsData.server_total * 100, 2) 
          : 0);
      serverRankEl.textContent = `${rankingsData.server_rank}위 / ${rankingsData.server_total}명(상위 ${serverPercentile}%)`;
    } else {
      serverRankEl.textContent = '-';
    }
  }
  
  // 랭킹 정보가 하나라도 있으면 컨테이너 표시
  const rankingNotice = document.getElementById('combat-score-ranking-notice');
  if ((rankingsData.overall_rank !== null && rankingsData.overall_total > 0) || 
      (rankingsData.job_rank !== null && rankingsData.job_total > 0) || 
      (rankingsData.server_rank !== null && rankingsData.server_total > 0)) {
    rankingsInfo.style.display = 'block';
    if (rankingNotice) {
      rankingNotice.style.display = 'block';
    }
  } else {
    rankingsInfo.style.display = 'none';
    if (rankingNotice) {
      rankingNotice.style.display = 'none';
    }
  }
}

// 전투 점수를 DB에 저장하는 함수
// characterInfo 파라미터 필수: { nickname, server, race, isCacheMiss } (동시 검색 시 데이터 충돌 방지)
// ⚠️ 전역 변수 사용 금지 - 반드시 characterInfo를 통해 캐릭터 정보 전달
function saveCombatScore(combatScore, combatStats, forceRefresh, characterInfo) {
  if (!combatScore || combatScore <= 0) {
    return Promise.resolve();
  }
  
  // characterInfo 필수 검증 - 전역 변수 사용하지 않음 (경쟁 조건 방지)
  if (!characterInfo || typeof characterInfo !== 'object') {
    console.warn('[saveCombatScore] characterInfo 객체가 필요합니다. 전역 변수는 사용하지 않습니다.');
    return Promise.resolve();
  }
  
  const nickname = characterInfo.nickname;
  const server = characterInfo.server;
  const race = characterInfo.race;
  const isCacheMiss = characterInfo.isCacheMiss !== undefined ? characterInfo.isCacheMiss : false;
  
  // 필수 파라미터 검증 (누락 시 조기 반환)
  if (!nickname || !server || !race) {
    console.warn('[saveCombatScore] 필수 파라미터 누락으로 저장 건너뜀:', { nickname, server, race });
    return Promise.resolve();
  }
  
  // race 값 검증 - 숫자가 아닌 문자열("천족" 또는 "마족")이어야 함
  if (race === '1' || race === '2' || race === 1 || race === 2) {
    console.warn('[saveCombatScore] race 값이 숫자입니다. 문자열("천족"/"마족")이어야 합니다:', race);
    return Promise.resolve();
  }
  
  const payload = {
    nickname: nickname,
    server: server,
    race: race,
    combat_score: combatScore
  };
  
  // 스탯 데이터가 있으면 추가
  if (combatStats && typeof combatStats === 'object') {
    payload.combat_stats = combatStats;
  }
  
  // 갱신하기 버튼을 눌렀을 때 플래그 전달
  if (forceRefresh === true) {
    payload.force_refresh = true;
  }
  
  // 캐시 미스일 때도 플래그 전달 (전투 점수 변경 여부와 관계없이 스탯 업데이트)
  if (isCacheMiss === true) {
    payload.is_cache_miss = true;
  }
  
  
  return fetch('/api/character/combat-score', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(payload)
  })
  .then(response => {
    if (!response.ok) {
      console.error('[saveCombatScore] HTTP 에러:', response.status, response.statusText);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => {
    if (data.success) {
    } else {
      console.error('[saveCombatScore] 저장 실패:', data.error);
    }
    return data;
  })
  .catch(err => {
    // 에러 발생 시 로깅 및 무시 (DB 저장 실패해도 UI는 정상 작동)
    console.error('[saveCombatScore] 에러 발생:', err);
    return { success: false, error: err.message };
  });
}


// 스킬 통계 로드 및 순위 매핑
function loadSkillRanksAndDisplay(job) {
  fetch(`/api/stats/skills?job=${encodeURIComponent(job)}`)
    .then(res => res.json())
    .then(data => {
      if (!data.success || !data.data) return;
      
      // 스킬 이름 -> 순위 매핑 생성
      const skillRankMap = {};
      
      // 액티브 스킬 순위 (상위 3개)
      const activeStats = data.data.active || [];
      activeStats.slice(0, 3).forEach((stat, index) => {
        skillRankMap[stat.name] = { rank: index + 1, type: 'active' };
      });
      
      // 패시브 스킬 순위 (상위 3개)
      const passiveStats = data.data.passive || [];
      passiveStats.slice(0, 3).forEach((stat, index) => {
        skillRankMap[stat.name] = { rank: index + 1, type: 'passive' };
      });
      
      // 스티그마 순위 (상위 3개)
      const stigmaStats = data.data.stigma || [];
      stigmaStats.slice(0, 3).forEach((stat, index) => {
        skillRankMap[stat.name] = { rank: index + 1, type: 'stigma' };
      });
      
      // 스킬 아이템에 순위 배지 추가
      applySkillRanks(skillRankMap);
    })
    .catch(err => {
      // 스킬 통계 로드 실패
    });
}

// 스킬 아이템에 순위 배지 적용 (비활성화 - renderSkillCategory에서 priority 기반으로 처리)
function applySkillRanks(skillRankMap) {
  // 이제 renderSkillCategory에서 priority 기반으로 별표를 추가하므로
  // 이 함수는 더 이상 사용하지 않음
  return;
  
  /* 기존 채용률 기반 로직 (사용 안 함)
  const skillItems = document.querySelectorAll('.skill-item');
  skillItems.forEach(item => {
    const skillNameEl = item.querySelector('.skill-name');
    if (!skillNameEl) return;
    
    const skillName = skillNameEl.textContent.trim();
    const rankInfo = skillRankMap[skillName];
    
    if (rankInfo && rankInfo.rank <= 3) {
      // 기존 배지 제거
      const existingBadge = item.querySelector('.skill-rank-badge');
      if (existingBadge) existingBadge.remove();
      
      // 별 개수 결정 (1위: 3개, 2위: 2개, 3위: 1개)
      const starCount = 4 - rankInfo.rank; // 1위=3, 2위=2, 3위=1
      const stars = '★'.repeat(starCount);
      
      // 새 배지 추가
      const badge = document.createElement('div');
      badge.className = `skill-rank-badge rank-${rankInfo.rank}`;
      badge.textContent = stars;
      item.appendChild(badge);
    }
  });
  */
}

// 통계 페이지로 이동 및 직업 클래스 버튼 클릭
function navigateToSkillStats(job) {
  // 통계 탭으로 이동
  const statisticsTab = document.getElementById('tab-statistics');
  if (statisticsTab) {
    statisticsTab.checked = true;
    // 탭 변경 이벤트 트리거
    statisticsTab.dispatchEvent(new Event('change', { bubbles: true }));
  }
  
  // 스킬 통계 서브탭 활성화
  setTimeout(() => {
    const skillStatsTab = document.querySelector('[data-target="skill-statistics"]');
    if (skillStatsTab) {
      skillStatsTab.click();
    }
    
    // 직업 클래스 버튼 클릭
    setTimeout(() => {
      const jobButton = document.querySelector(`.skill-stats-class-btn[data-job="${job}"]`);
      if (jobButton) {
        jobButton.click();
      }
    }, 300);
  }, 300);
}

// URL 해시에서 스킬 통계 직업 정보 추출 및 자동 이동
function checkSkillStatsHash() {
  const hash = window.location.hash.substring(1); // # 제거
  const match = hash.match(/^statistics-skill-(.+)$/);
  if (match) {
    const job = decodeURIComponent(match[1]);
    // 페이지 로드 완료 후 실행 (통계 탭과 스킬 통계 서브탭이 로드될 때까지 대기)
    setTimeout(() => {
      navigateToSkillStats(job);
    }, 800);
  }
}

function detectSkillGroup(skill) {
  if (!skill) return 'active';
  const group = (skill.group || skill.skill_group || '').toString().toLowerCase();
  if (group.includes('passive') || group.includes('패시브')) return 'passive';
  if (group.includes('active') || group.includes('액티브')) return 'active';
  const typeText = (skill.type || '').toString().toLowerCase();
  if (typeText.includes('passive') || typeText.includes('패시브')) return 'passive';
  return 'active';
}

// ==================== 스킬 설명 데이터 - 모든 직업 ====================
// 마도성 액티브 스킬 설명 데이터
const mageActiveSkillDescriptions = {
  '불꽃 화살': {
    description: '대상에게 피해를 주고, 정신력을 회복합니다.',
    notes: '이동 가능'
  },
  '얼음 사슬': {
    description: '대상을 중심으로 적들에게 물속성 피해를 주고 일정 확률로 둔화 상태로 만듭니다. 그로기 게이지 피해량 2',
    notes: '이동 가능'
  },
  '불꽃 작살': {
    description: '대상에게 불속성 피해를 줍니다. 그로기 게이지 피해량 5',
    notes: ''
  },
  '혹한의 바람': {
    description: '대상의 위치에 혹한의 바람을 소환합니다. 혹한의 바람 주변 적들에게 물속성 피해를 주고 일정 확률로 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 속박이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '불꽃 폭발': {
    description: '불의 표식인 대상에게 불속성 피해를 주고 정신력을 회복합니다. 그로기 게이지 피해량 7',
    notes: ''
  },
  '화염 난사': {
    description: '그로기 상태인 대상에게 불속성 피해를 줍니다.',
    notes: ''
  },
  '빙결': {
    description: '대상을 중심으로 적들에게 물속성 피해를 주고, 일정 확률로 빙결 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 빙결이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '겨울의 속박': {
    description: '자신을 중심으로 적들에게 물속성 피해를 주고 둔화 상태로 만듭니다.',
    notes: '논타겟'
  },
  '빙결 폭발': {
    description: '빙결 상태의 대상을 중심으로 적들에게 물속성 피해를 줍니다. 그로기 게이지 피해량 7',
    notes: ''
  },
  '집중의 기원': {
    description: '자신의 공격력 및 명중이 증가합니다.',
    notes: '논타겟, 이동 가능'
  },
  '지옥의 화염': {
    description: '대상에게 불속성 피해를 줍니다. 그로기 게이지 피해량 20',
    notes: '차지 스킬'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. [강인함]: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 저주: 고목: 대상을 나무로 변이시키고, 불속성 내성을 감소시킵니다. 공격을 받으면 효과가 사라집니다.',
    notes: ''
  }
};

// 마도성 패시브 스킬 설명 데이터
const magePassiveSkillDescriptions = {
  '불의 표식': {
    description: '불속성 공격이 적중할 때 일정 확률로 대상에게 불의 표식을 새깁니다. 불의 표식 상태인 대상이 불속성 피해를 받으면 추가 피해를 받습니다. [불의 표식]: 공격력이 감소하고, 불속성 피해를 받을 때 일정 확률로 추가 피해를 받는 상태입니다.',
    notes: ''
  },
  '대지의 로브': {
    description: '최대 정신력과 정신력 회복량이 증가합니다.',
    notes: ''
  },
  '냉기 소환': {
    description: '둔화 상태인 대상을 공격할 때 일정 확률로 피해를 줍니다.',
    notes: ''
  },
  '불꽃의 로브': {
    description: '명중과 공격력이 증가합니다.',
    notes: ''
  },
  '정기 흡수': {
    description: '공격이 적중할 때마다 정신력을 회복합니다.',
    notes: ''
  },
  '저항의 은혜': {
    description: '정신 저항과 충격 저항이 증가합니다.',
    notes: ''
  },
  '냉기의 로브': {
    description: '자신을 공격하는 적에게 일정 확률로 둔화 상태를 부여하여 이동 속도를 감소시킵니다.',
    notes: ''
  },
  '강화의 은혜': {
    description: '최대 정신력이 일정 수치 이상일 때 공격력이 증가합니다.',
    notes: ''
  },
  '회생의 계약': {
    description: '상태 이상 저항이 증가하고, 체력이 일정 수치 이하로 떨어지면 즉시 체력을 회복합니다.',
    notes: ''
  },
  '생기 증발': {
    description: '공격이 적중할 때, 대상의 체력이 일정 수치 이상이면 피해를 줍니다.',
    notes: ''
  }
};

// 마도성 스티그마 스킬 설명 데이터
const mageStigmaSkillDescriptions = {
  '신성 폭발': {
    description: '대상에게 불속성 피해를 줍니다. 그로기 게이지 피해량 50',
    notes: ''
  },
  '강철 보호막': {
    description: '피해를 막아주는 보호막을 생성합니다.',
    notes: '논타겟, 이동 가능'
  },
  '원소 강화': {
    description: '자신의 불속성 및 물속성 공격력이 증가합니다.',
    notes: '논타겟, 이동 가능'
  },
  '저주: 나무': {
    description: '대상을 나무로 변이시키고, 불속성 내성을 감소시킵니다. 공격을 받으면 변이 효과가 사라집니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '빙설의 갑주': {
    description: '일정 시간 동안 자신의 피해 내성이 증가하고, 일정 확률로 자신을 공격하는 적들을 빙결 상태로 만듭니다.',
    notes: '논타겟, 이동 가능'
  },
  '영혼 동결': {
    description: '대상에게 물속성 피해를 주고, 일정 확률로 봉인 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 봉인이 적중됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '냉기 폭풍': {
    description: '대상을 중심으로 적들에게 물속성 피해를 주고 둔화 상태로 만듭니다. 대상의 위치에서 지속적으로 동상 상태로 만드는 냉기 폭풍을 소환합니다. [동상]: 일정 간격으로 물속성 지속 피해를 줍니다. 대상이 이동 상태일 경우 지속 피해량이 증가합니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '불의 장벽': {
    description: '일정 시간 동안 대상의 위치에 불의 장벽을 소환합니다. 범위 내 적들에게 피해를 주고 잔불 상태로 만듭니다. [잔불]: 일정 간격으로 불속성 지속 피해, 대상이 이동 상태일 경우 지속 피해량 증가',
    notes: ''
  },
  '루미엘의 공간': {
    description: '자신을 중심으로 적들에게 피해를 주고, 일정 확률로 공중 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공중 속박이 적중됩니다.',
    notes: '논타겟'
  },
  '지연 폭발': {
    description: '대상에게 일정 시간 뒤에 불속성 피해를 줍니다. 지연 시간 동안 대상의 피해 내성이 감소합니다.',
    notes: '이동 가능'
  },
  '빙하 강타': {
    description: '대상을 중심으로 적들에게 물속성 피해를 줍니다. 그로기 게이지 피해량 20',
    notes: '이동 가능'
  },
  '강습 폭격': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 빙결 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 빙결이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// 검성 액티브 스킬 설명 데이터
const warriorActiveSkillDescriptions = {
  '예리한 일격': {
    description: '적들에게 피해를 주고 적대치를 증가시킵니다. 정신력을 회복합니다.',
    notes: '논타겟, 이동 가능'
  },
  '절단의 맹타': {
    description: '적들에게 피해를 주고 적대치를 증가시킵니다. 그로기 게이지 피해량 2',
    notes: '논타겟'
  },
  '도약 찍기': {
    description: '대상에게 도약하여 피해를 줍니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '유린의 검': {
    description: '대상에게 피해를 주고 넘어짐 상태로 만듭니다. 행동불가 면역 대상일 경우 모션이 변경됩니다. 그로기 게이지 피해량 15',
    notes: ''
  },
  '내려찍기': {
    description: '넘어짐 상태의 대상에게 피해를 줍니다.',
    notes: ''
  },
  '검기 난무': {
    description: '그로기 상태인 대상에게 피해를 줍니다.',
    notes: ''
  },
  '발목 베기': {
    description: '막기 성공 시 대상을 중심으로 적들에게 피해를 주고, 일정 확률로 속박 상태로 만듭니다. 대상이 NPC일 경우 100% 확률로 속박이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '분쇄 파동': {
    description: '자신을 중심으로 적들에게 피해를 줍니다. 그로기 게이지 피해량 5',
    notes: '논타겟'
  },
  '돌진 일격': {
    description: '긴급 회피 사용 후 대상에게 이동하여 피해를 주고, 일정 확률로 넘어짐 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 넘어짐이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '공중 결박': {
    description: '넘어짐 상태의 대상에게 피해를 주고, 일정 확률로 공중속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공중속박이 적중됩니다.',
    notes: ''
  },
  '파멸의 맹타': {
    description: '대상에게 돌진하여 피해를 주고 자신은 전투 준비 상태가 됩니다. 최대 차지 시 범위 피해를 줍니다. [전투 준비]: 피해 증폭 및 치명타 증가 그로기 게이지 피해량 15',
    notes: '차지'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. 강인함: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 분노 폭발: 대상에게 피해를 주고 넘어짐 상태로 만듭니다.',
    notes: '논타겟'
  }
};

// 검성 패시브 스킬 설명 데이터
const warriorPassiveSkillDescriptions = {
  '생존 자세': {
    description: '자신의 최대 생명력 및 자연 생명력 회복이 증가합니다.',
    notes: ''
  },
  '보호의 갑옷': {
    description: '자신의 막기가 증가하고, 막기 성공 시 생명력을 회복합니다.',
    notes: ''
  },
  '피의 흡수': {
    description: '공격 적중 시 피의 흡수 효과를 받습니다. [피의 흡수]: 공격이 적중할 때 마다 일정 확률로 생명력을 회복합니다.',
    notes: ''
  },
  '약점 파악': {
    description: '자신의 치명타 및 완벽이 증가합니다.',
    notes: ''
  },
  '공격 준비': {
    description: '자신의 공격력 및 방어력이 증가합니다.',
    notes: ''
  },
  '충격 적중': {
    description: '충격계 적중 및 강타가 증가합니다.',
    notes: ''
  },
  '파괴 충동': {
    description: '대상이 충격계 또는 그로기 상태일 때 추가 피해를 줍니다.',
    notes: ''
  },
  '노련한 반격': {
    description: '막기 성공 시 자신의 공격력이 증가합니다.',
    notes: ''
  },
  '생존 의지': {
    description: '자신의 상태이상 저항이 증가하고, 자신의 충격계 상태일 때 충격계 저항 및 피해 내성이 증가합니다.',
    notes: ''
  },
  '살기 파열': {
    description: '공격이 적중할 때 마다 살기를 획득합니다. 10회 중첩 시 살기를 삭제하고 자신을 중심으로 적들에게 피해를 줍니다.',
    notes: ''
  }
};

// 검성 스티그마 스킬 설명 데이터
const warriorStigmaSkillDescriptions = {
  '분노의 파동': {
    description: '자신을 중심으로 적들에게 피해를 주고 공격력을 감소시킵니다. 적들은 일정 확률로 넘어짐 상태가 됩니다. 대상이 NPC일 경우 100%의 확률로 넘어짐이 적중됩니다. 그로기 게이지 피해량 50',
    notes: '논타겟'
  },
  '돌격 자세': {
    description: '자신의 전투 속도가 증가합니다.',
    notes: ''
  },
  '지켈의 축복': {
    description: '자신과 주변에 있는 파티원들의 공격력이 증가합니다.',
    notes: '논타겟, 이동 가능'
  },
  '집중 막기': {
    description: '잠시 동안 전방 공격에 대한 막기 피해 감소가 증가하고 확정 무기막기를 합니다. 막기 성공 시 정신력과 행동력을 회복합니다.',
    notes: '유지형 스킬'
  },
  '균형의 갑옷': {
    description: '일정 시간 동안 충격계 저항이 증가합니다.',
    notes: '논타겟, 이동 가능'
  },
  '칼날 날리기': {
    description: '대상에게 피해를 주고 방어력을 감소시킵니다. 그로기 게이지 피해량 5',
    notes: ''
  },
  '근성': {
    description: '5초 동안 피해를 받지 않으며, 상태이상에 걸리지 않습니다. 일부 강력한 공격은 방어할 수 없습니다.',
    notes: ''
  },
  '흡혈의 검': {
    description: '대상을 올려치며 피해를 주고 내려치며 그 주변 적들에게 피해를 줍니다. 피해의 일부를 생명력으로 흡수합니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '격노 폭발': {
    description: '대상에게 피해를 줍니다. 대상이 충격계 상태일 경우 피해가 증가합니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '파동의 갑주': {
    description: '자신을 중심으로 적들에게 지속적으로 피해를 줍니다.',
    notes: '논타겟, 이동 가능'
  },
  '강제 결박': {
    description: '대상에게 피해를 주고 일정 확률로 봉인 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 봉인이 적중됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '강습 일격': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 넘어짐 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 넘어짐이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// ==================== 수호성 ====================
const guardianActiveSkillDescriptions = {
  '맹렬한 일격': {
    description: '적들에게 피해를 주고 적대치를 증가시킵니다. 정신력을 회복합니다.',
    notes: '논타겟, 이동 가능'
  },
  '연속 난타': {
    description: '적들에게 피해를 주고 적대치를 증가시킵니다. 그로기 게이지 피해량 2',
    notes: '논타겟, 이동 가능'
  },
  '포획': {
    description: '대상에게 피해를 주고 자신에게 끌어당기며, 일정 확률로 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 속박이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '방패 강타': {
    description: '적들에게 피해를 줍니다. 대상은 일정 확률로 기절 상태가 됩니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '심판': {
    description: '기절 또는 넘어짐 상태의 대상에게 피해를 줍니다.',
    notes: ''
  },
  '섬광 난무': {
    description: '그로기 상태인 대상에게 피해를 주고 적대치를 증가시킵니다.',
    notes: ''
  },
  '쇠약의 맹타': {
    description: '막기 성공 시 대상을 중심으로 적들에게 피해를 주고 쇠약 상태로 만듭니다. [쇠약]: 방어력 감소 그로기 게이지 피해량 10',
    notes: ''
  },
  '비호의 일격': {
    description: '자신을 중심으로 적들에게 피해를 줍니다. 자신은 즉시 생명력을 회복하고 비호 효과를 받습니다. [비호]: 피해 내성 증가',
    notes: '논타겟'
  },
  '방패 돌격': {
    description: '긴급 회피 사용 후 대상에게 돌진하여 피해를 주고, 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '섬멸': {
    description: '기절 또는 넘어짐 상태의 대상에게 피해를 주고, 일정 확률로 넘어짐 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 넘어짐이 적중됩니다.',
    notes: ''
  },
  '징벌': {
    description: '자신을 중심으로 적들에게 피해를 줍니다. 그로기 게이지 피해량 15',
    notes: '논타겟, 차지 스킬'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. 강인함: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 생포: 대상에게 피해를 주고 자신에게 끌어당기며 속박 상태로 만듭니다. 그 후 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다.',
    notes: ''
  }
};

const guardianPassiveSkillDescriptions = {
  '체력 강화': {
    description: '자신의 최대 생명력 및 받는 회복량이 증가합니다.',
    notes: ''
  },
  '비호의 방패': {
    description: '자신의 막기가 증가하고, 막기 성공 시 생명력을 회복합니다.',
    notes: ''
  },
  '단죄의 가호': {
    description: '공격 적중 시 단죄의 가호 효과를 받습니다. [단죄의 가호]: 공격이 적중할 때 마다 일정 확률로 추가 피해를 줍니다.',
    notes: ''
  },
  '철벽 방어': {
    description: '자신의 방어력이 증가합니다.',
    notes: ''
  },
  '수호의 인장': {
    description: '생명력이 50% 이하일 때 보호막을 생성합니다.',
    notes: ''
  },
  '충격 적중': {
    description: '충격계 적중 및 강타가 증가합니다.',
    notes: ''
  },
  '모욕의 포효': {
    description: '자신의 적대치 증폭이 증가하고 막기 시 대상에게 피해를 주며 적대치를 큰 폭으로 증가시킵니다.',
    notes: ''
  },
  '격앙': {
    description: '막기 성공 시 자신 및 파티원의 공격력이 증가합니다.',
    notes: ''
  },
  '생존 의지': {
    description: '자신의 상태이상 저항이 증가하고, 충격계 상태일 때 충격계 저항 및 피해 내성이 증가합니다.',
    notes: ''
  },
  '고통 차단': {
    description: '공격을 받을 때마다 유지되는 고통 차단 효과를 획득합니다. 10회 중첩이 되면 고통 차단 효과를 삭제하고 인내 효과를 받습니다. [인내]: 피해 내성 증가',
    notes: ''
  }
};

const guardianStigmaSkillDescriptions = {
  '주신의 징벌': {
    description: '대상을 중심으로 적들에게 피해를 주고, 일정 확률로 기절 상태가 됩니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 50',
    notes: ''
  },
  '네자칸의 방패': {
    description: '자신과 주변 파티원들에게 보호막을 생성합니다.',
    notes: ''
  },
  '보호의 방패': {
    description: '잠시 동안 전방 공격에 대한 막기 피해 감소가 증가하고 확정 방패막기를 합니다. 막기 성공 시 정신력과 행동력을 회복합니다.',
    notes: '유지형 스킬'
  },
  '도발': {
    description: '대상에게 피해를 주고 적대치를 증가시킵니다. 대상이 PC인 경우 일정 확률로 도발 상태로 만듭니다.',
    notes: '이동 가능'
  },
  '균형의 갑옷': {
    description: '일정 시간 동안 충격계 저항이 증가합니다.',
    notes: '이동 가능'
  },
  '이중 갑옷': {
    description: '일정 시간 동안 피해 내성이 증가합니다.',
    notes: '이동 가능'
  },
  '파멸의 방패': {
    description: '대상에게 돌진하며 피해를 줍니다. 적들은 지속적으로 밀려나고 마지막 피해를 받은 경우 일정 확률로 넘어짐 상태가 됩니다. 자신은 보호막 효과를 받습니다. 대상이 NPC일 경우 100%의 확률로 넘어짐이 적중됩니다. 그로기 게이지 피해량 20',
    notes: '이동 가능'
  },
  '고결의 갑주': {
    description: '최대 생명력이 증가하고, 생명력을 즉시 회복합니다.',
    notes: '이동 가능'
  },
  '처형의 검': {
    description: '적들에게 피해를 줍니다. 대상이 충격계 상태일 경우 피해가 증가합니다.',
    notes: ''
  },
  '전우 보호': {
    description: '파티원이 공격을 받을 때마다 피해의 일부를 자신과 피격받은 파티원이 나누어 받습니다.',
    notes: ''
  },
  '나포': {
    description: '대상을 중심으로 적들에게 피해를 주고 자신의 앞으로 끌어당깁니다. 적들은 일정 시간 동안 속박 상태가 됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '강습 맹격': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// ==================== 살성 ====================
const assassinActiveSkillDescriptions = {
  '빠른 베기': {
    description: '적들에게 피해를 주고, 정신력을 회복합니다.',
    notes: '논타겟, 이동 가능'
  },
  '맹수의 포효': {
    description: '적들에게 피해를 주고, 문양 1개를 각인합니다. 그로기 게이지 피해량 2',
    notes: '논타겟'
  },
  '암습': {
    description: '대상의 뒤편으로 이동하여 피해를 주고 일정 확률로 회전시키며, 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '기습': {
    description: '대상에게 피해를 줍니다. 대상의 후방에서 공격할 경우 피해가 증가합니다. 그로기 게이지 피해량 7',
    notes: ''
  },
  '심장 찌르기': {
    description: '치명타 적중 시 활성화되며, 적들에게 피해를 주고, 정신력을 회복합니다. 그로기 게이지 피해량 5',
    notes: ''
  },
  '폭풍 난무': {
    description: '그로기 상태인 대상에게 피해를 줍니다.',
    notes: ''
  },
  '회오리 베기': {
    description: '회피 성공 시 대상에게 피해를 주고, 일정 확률로 회전시키며 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 7',
    notes: ''
  },
  '섬광베기': {
    description: '대상의 반대쪽으로 이동하여 적들에게 피해를 주고 일정 확률로 실명 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 실명이 적중됩니다. 그로기 게이지 피해량 7',
    notes: '논타겟'
  },
  '침투': {
    description: '긴급 회피 사용 후 대상의 뒤편으로 이동하여 피해를 주고, 일정 확률로 실명 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 실명이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '그림자 낙하': {
    description: '기절 상태의 대상에게 피해를 주고, 일정 확률로 넘어짐 상태로 만듭니다.',
    notes: ''
  },
  '문양 폭발': {
    description: '대상을 중심으로 적들에게 피해를 주고 기절 상태로 만듭니다. 문양 중첩 시 피해량과 기절 확률이 증가합니다. 그로기 게이지 피해량 7',
    notes: '이동 가능'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. [강인함]: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 폭풍 베기: 대상에게 피해를 주고, 회전시키며 기절 상태로 만듭니다.',
    notes: '논타겟'
  }
};

const assassinPassiveSkillDescriptions = {
  '육감 극대화': {
    description: '자신의 회피, 최대 생명력이 증가하고, 회피 성공 시 생명력을 회복합니다.',
    notes: ''
  },
  '빈틈 노리기': {
    description: '자신의 치명타가 증가하고, 치명타 적중 시 일정 확률로 분신을 소환해 피해를 주고 문양을 부여합니다.',
    notes: ''
  },
  '독바르기': {
    description: '공격이 적중할 때마다 일정 확률로 대상의 받는 회복량을 감소시키고, 지속 피해를 받는 중독 상태로 만듭니다.',
    notes: ''
  },
  '배후 강타': {
    description: '자신의 후방 피해 증폭이 증가합니다.',
    notes: ''
  },
  '강습 자세': {
    description: '자신의 치명타 피해 증폭이 증가합니다.',
    notes: ''
  },
  '충격 적중': {
    description: '충격계 적중 및 강타가 증가합니다.',
    notes: ''
  },
  '기습 자세': {
    description: '기절, 실명 상태의 대상에게 공격을 적중시킬 때마다 일정 확률로 피해를 줍니다.',
    notes: ''
  },
  '방어 균열': {
    description: '그로기 또는 충격계 상태의 대상에게 공격을 적중시킬 때마다 대상의 방어력을 감소시킵니다.',
    notes: ''
  },
  '회생의 계약': {
    description: '자신의 상태이상 저항이 증가하고, 생명력이 일정량 이하일 때 생명력을 즉시 회복합니다.',
    notes: ''
  },
  '각오': {
    description: '생명력이 일정량 이하인 대상에게 공격 적중시킬 때마다 피해를 줍니다.',
    notes: ''
  }
};

const assassinStigmaSkillDescriptions = {
  '맹수의 송곳니': {
    description: '적들에게 피해를 주고 문양을 각인합니다. 그로기 게이지 피해량 50',
    notes: '논타겟'
  },
  '신속의 계약': {
    description: '일정 시간 동안 자신의 전투 속도가 증가합니다.',
    notes: '이동 가능'
  },
  '연막탄': {
    description: '연막탄을 터뜨립니다. 연막탄 안에서 자신과 파티원들은 발사체에 피격되지 않습니다.',
    notes: '이동 가능'
  },
  '회피 자세': {
    description: '잠시 동안 모든 피해를 확정 회피합니다. 회피 성공 시 정신력과 행동력을 회복합니다.',
    notes: '유지형 스킬'
  },
  '나선 베기': {
    description: '대상에게 돌진하며 적들에게 피해를 주고, 일정 확률로 회전시키며 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '그림자 보행': {
    description: '일정 시간 동안 은신 상태가 됩니다. 전투 상태에서 사용할 수 없고, 사용 중 전투 상태가 되면 효과가 해제됩니다.',
    notes: '이동 가능'
  },
  '암검 투척': {
    description: '대상에게 피해를 주고 이동 속도가 감소되는 둔화 상태로 만듭니다. 그로기 게이지 피해량 15',
    notes: '이동 가능'
  },
  '트리니엘의 비수': {
    description: '대상에게 피해를 주고, 모든 스킬의 재시전 시간을 5%만큼 발생시킵니다. 대상의 후방에서 공격할 경우 피해가 증가합니다. 그로기 게이지 피해량 20',
    notes: '논타겟'
  },
  '공중 포박': {
    description: '대상에게 피해를 주고 일정 확률로 공중 속박 상태로 만듭니다. 문양 5중첩 대상에게는 100%의 확률로 공중 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공중 속박이 적중됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '환영 분신': {
    description: '모든 공격의 일정량만큼 추가 피해를 줍니다.',
    notes: '이동 가능'
  },
  '회피의 계약': {
    description: '자신에게 걸린 둔화, 속박 효과를 해제합니다. 자신의 회피가 증가합니다.',
    notes: '이동 가능'
  },
  '강습 습격': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 실명 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 실명이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// ==================== 궁성 ====================
const rangerActiveSkillDescriptions = {
  '저격': {
    description: '적들에게 피해를 주고, 정신력을 회복합니다.',
    notes: '이동 가능'
  },
  '속사': {
    description: '대상을 중심으로 적들에게 피해를 줍니다. 그로기 게이지 피해량 1',
    notes: '이동 가능'
  },
  '올가미 화살': {
    description: '대상을 중심으로 적들에게 피해를 주고 둔화 상태로 만듭니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '표적 화살': {
    description: '대상에게 피해를 주고 입력 방향으로 이동합니다. 대상은 표적 상태가 됩니다. [표적]: 치명타 저항 감소 그로기 게이지 피해량 7',
    notes: ''
  },
  '송곳 화살': {
    description: '치명타 적중 시 활성화되며, 대상을 중심으로 적들에게 피해를 주고 정신력을 회복합니다. 대상은 출혈 상태가 되어 1초마다 피해를 받습니다. 그로기 게이지 피해량 5',
    notes: ''
  },
  '화살 난사': {
    description: '그로기 상태인 대상에게 피해를 줍니다.',
    notes: ''
  },
  '광풍 화살': {
    description: '대상에게 피해를 줍니다. 그로기 게이지 피해량 10',
    notes: '차지 스킬'
  },
  '폭발의 덫': {
    description: '자신 근처에 범위형 함정을 설치합니다. 적이 다가오면 적들에게 피해를 주고 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다.',
    notes: ''
  },
  '파열 화살': {
    description: '둔화 또는 속박 상태의 대상을 중심으로 적들에게 피해를 줍니다. 그로기 게이지 피해량 15',
    notes: ''
  },
  '제압 화살': {
    description: '표적 상태인 대상에게 피해를 주고 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '조준 화살': {
    description: '대상에게 피해를 줍니다. 표적 상태인 대상에게는 피해가 증가합니다. 그로기 게이지 피해량 10',
    notes: '차지 스킬'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. [강인함]: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 번개 화살: 대상에게 피해를 주고 기절 상태로 만듭니다.',
    notes: ''
  }
};

const rangerPassiveSkillDescriptions = {
  '경계의 눈': {
    description: '자신의 회피, 최대 생명력이 증가하고, 회피 성공 시 생명력을 즉시 회복합니다.',
    notes: ''
  },
  '집중 포화': {
    description: '지속 피해를 입는 대상에게 일정 확률로 피해를 줍니다.',
    notes: ''
  },
  '바람의 활력': {
    description: '공격을 받을 때마다 이동 속도가 증가합니다.',
    notes: ''
  },
  '집중의 눈': {
    description: '자신의 명중 및 공격력이 증가합니다.',
    notes: ''
  },
  '사냥꾼의 결의': {
    description: '자신의 치명타 피해 증폭이 증가합니다.',
    notes: ''
  },
  '저항의 결의': {
    description: '자신의 육체계 저항이 증가합니다.',
    notes: ''
  },
  '속박의 눈': {
    description: '둔화, 속박 상태의 대상에게 공격을 적중시킬 때마다 일정 확률로 피해를 줍니다.',
    notes: ''
  },
  '근접 사격': {
    description: '근접한 대상에게 공격을 적중시킬 때마다 일정 확률로 추가 피해를 줍니다.',
    notes: ''
  },
  '회생의 계약': {
    description: '자신의 상태이상 저항이 증가하고, 생명력이 일정량 이하일 때 생명력을 즉시 회복합니다.',
    notes: ''
  },
  '사냥꾼의 혼': {
    description: '치명타 시 일정 확률로 피해를 줍니다.',
    notes: ''
  }
};

const rangerStigmaSkillDescriptions = {
  '화살 폭풍': {
    description: '대상을 중심으로 적들에게 피해를 주고, 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 50',
    notes: ''
  },
  '바이젤의 권능': {
    description: '일정 시간 동안 자신의 공격력이 증가합니다.',
    notes: ''
  },
  '축복의 활': {
    description: '일정 시간 동안 자신과 주변 파티원들의 치명타를 증가시킵니다.',
    notes: ''
  },
  '기습 차기': {
    description: '대상의 뒤로 이동하여 피해를 주고 밀려난 상태로 만듭니다. 자신은 후방으로 이동합니다.',
    notes: ''
  },
  '결박의 덫': {
    description: '자신 근처에 범위형 함정을 설치합니다. 함정은 일정 시간 동안 작동하며 적이 다가오면 적들에게 피해를 주고 공중 속박 상태로 만듭니다.',
    notes: ''
  },
  '수면 화살': {
    description: '대상을 수면 상태로 만들고 방어력을 감소시킵니다. 공격을 받으면 수면이 해제됩니다.',
    notes: ''
  },
  '은신': {
    description: '일정 시간 동안 은신 상태가 됩니다. 전투 상태에서 사용할 수 없으며, 은신 후 전투 상태가 되면 효과가 해제됩니다.',
    notes: '이동 가능'
  },
  '봉인 화살': {
    description: '대상에게 피해를 주고, 일정 확률로 봉인 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 봉인이 적중됩니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '대자연의 숨결': {
    description: '일정 시간 동안 적에게 받는 모든 마법 피해의 10%만큼 반사합니다.',
    notes: '이동 가능'
  },
  '그리폰의 화살': {
    description: '그리폰이 날아가는 경로 내 적들에게 피해를 줍니다. 적들은 일정 시간 동안 불 속성 지속 피해를 받습니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '폭발 화살': {
    description: '대상을 중심으로 적들에게 피해를 줍니다. 대상이 충격계 상태일 경우 피해가 증가합니다. 그로기 게이지 피해량 20',
    notes: '이동 가능'
  },
  '강습 강타': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// ==================== 호법성 ====================
const priestActiveSkillDescriptions = {
  '격파쇄': {
    description: '적들에게 피해를 주고, 정신력을 회복합니다.',
    notes: '논타겟, 이동 가능'
  },
  '백열격': {
    description: '적들에게 피해를 줍니다. 그로기 게이지 피해량 2',
    notes: '논타겟, 이동 가능'
  },
  '돌진 격파': {
    description: '대상에게 돌진하여 적들에게 피해를 줍니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '타격쇄': {
    description: '대상에게 피해를 주고, 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '암격쇄': {
    description: '기절, 넘어짐, 공중 속박 상태의 대상에게 피해를 줍니다.',
    notes: ''
  },
  '질풍 난타': {
    description: '그로기 상태인 대상에게 피해를 줍니다.',
    notes: ''
  },
  '열파격': {
    description: '막기 성공 시, 대상을 중심으로 적들에게 피해를 주고, 일정 확률로 봉인 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 봉인이 적중됩니다. 그로기 게이지 피해량 10',
    notes: '논타겟'
  },
  '쾌유의 주문': {
    description: '자신과 주변 파티원들의 생명력을 즉시 회복하고, 일정 간격으로 지속 회복합니다.',
    notes: '논타겟'
  },
  '진동쇄': {
    description: '긴급 회피 사용 후 대상에게 이동하여 피해를 주고, 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 10',
    notes: ''
  },
  '파동격': {
    description: '기절 상태의 대상에게 피해를 주고 넘어짐 상태로 만듭니다.',
    notes: ''
  },
  '회전격': {
    description: '자신의 앞을 중심으로 적들에게 피해를 줍니다. 그로기 게이지 피해량 15',
    notes: ''
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. [강인함]: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 강격쇄: 자신을 중심으로 적들에게 피해를 주고 기절 상태로 만듭니다.',
    notes: ''
  }
};

const priestPassiveSkillDescriptions = {
  '생명의 축복': {
    description: '자신의 최대 생명력 및 받는 회복량이 증가합니다.',
    notes: ''
  },
  '십자 방어': {
    description: '자신의 막기가 증가하고, 막기 성공 시 생명력을 회복합니다.',
    notes: ''
  },
  '보호진': {
    description: '공격이 적중할 때마다 보호진 효과를 획득합니다. 20회 중첩이 되면 보호진 효과를 삭제하고 자신과 파티원들에게 신성한 보호막을 부여합니다.',
    notes: ''
  },
  '고취의 주문': {
    description: '자신의 치명타 및 완벽이 증가합니다.',
    notes: ''
  },
  '공격 준비': {
    description: '자신의 공격력 및 방어력이 증가합니다.',
    notes: ''
  },
  '충격 적중': {
    description: '충격계 적중 및 강타가 증가합니다.',
    notes: ''
  },
  '격노의 주문': {
    description: '대상이 충격계 또는 그로기 상태일 때 추가 피해를 줍니다.',
    notes: ''
  },
  '대지의 약속': {
    description: '막기 성공 시 대상의 전투 속도를 감소시킵니다.',
    notes: ''
  },
  '생존 의지': {
    description: '자신의 상태이상 저항이 증가하고, 충격계 상태일 때 충격계 저항 및 피해 내성이 증가합니다.',
    notes: ''
  },
  '바람의 약속': {
    description: '치명타 시 일정 확률로 대상에게 피해를 줍니다.',
    notes: ''
  }
};

const priestStigmaSkillDescriptions = {
  '멸화': {
    description: '적들에게 피해를 주고, 일정 확률로 넘어짐 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 그로기 게이지 피해량 50',
    notes: '논타겟'
  },
  '불패의 진언': {
    description: '자신과 주변 파티원들의 공격력, 방어력을 증가시킵니다.',
    notes: '토글형'
  },
  '집중 방어': {
    description: '잠시 동안 전방 공격에 대한 막기 피해 감소가 증가하고, 확정 무기막기를 합니다. 막기 성공 시 정신력과 행동력을 회복합니다.',
    notes: '유지형'
  },
  '질주의 진언': {
    description: '자신과 주변 파티원들의 이동속도를 증가시킵니다.',
    notes: '토글형'
  },
  '쾌유의 진언': {
    description: '자신과 주변 파티원들의 공격이 적중할 때마다 일정 확률로 생명력을 회복합니다.',
    notes: '토글형'
  },
  '마르쿠탄의 분노': {
    description: '대상을 중심으로 적들에게 피해를 줍니다.',
    notes: ''
  },
  '차단의 권능': {
    description: '자신과 주변 파티원들이 공격을 받을 때마다 피해를 막을 수 있는 보호막을 만듭니다.',
    notes: '논타겟'
  },
  '결박의 낙인': {
    description: '대상을 중심으로 적들에게 피해를 주고, 일정 확률로 봉인 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 봉인이 적중됩니다.',
    notes: ''
  },
  '쾌유의 손길': {
    description: '자신과 주변 파티원들의 생명력을 회복시킵니다.',
    notes: '논타겟'
  },
  '질풍의 권능': {
    description: '자신과 주변 파티원들의 전투속도를 증가시킵니다.',
    notes: '논타겟'
  },
  '수호의 축복': {
    description: '자신의 최대 생명력 및 자연 생명력이 증가하고, 생명력을 즉시 회복합니다.',
    notes: '논타겟, 이동 가능'
  },
  '강습 충격': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 기절 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 기절이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// ==================== 치유성 ====================
const clericActiveSkillDescriptions = {
  '대지의 응보': {
    description: '대상에게 대지속성 피해를 주고 정신력을 회복합니다. (연계기) 뇌전: 대상에게 바람속성 피해를 주고 정신력을 회복합니다. (연계기) 방전: 일정 확률로 활성화되며, 대상에게 바람속성 피해를 주고 정신력을 회복합니다.',
    notes: '이동 가능'
  },
  '심판의 번개': {
    description: '대상을 중심으로 적들에게 바람속성 피해를 줍니다. 그로기 게이지 피해량 2',
    notes: '이동 가능'
  },
  '약화의 낙인': {
    description: '대상을 중심으로 적들에게 바람속성 피해를 줍니다. 적들의 바람속성 내성이 감소하고, 일정 간격으로 지속 피해를 받습니다. 그로기 게이지 피해량 10',
    notes: '이동 가능'
  },
  '신성한 기운': {
    description: '자신 근처에 신성한 기운을 소환합니다. 기운은 이동할 수 없으며, 시전자가 지정한 대상을 일정 간격으로 대지속성 피해를 줍니다. 기운은 공격을 적중시킬 때마다 자신의 생명력을 소모합니다.',
    notes: ''
  },
  '고통의 연쇄': {
    description: '대상을 중심으로 적들에게 대지속성 피해를 줍니다. 적들의 대지속성 내성이 감소하고, 일정 간격으로 지속 피해를 받습니다. 그로기 게이지 피해량 10',
    notes: '이동 가능'
  },
  '벼락 난사': {
    description: '그로기 상태인 대상에게 피해를 줍니다.',
    notes: ''
  },
  '재생의 빛': {
    description: '자신과 주변 파티원들의 생명력을 일정 간격으로 회복합니다.',
    notes: '논타겟, 이동 가능'
  },
  '단죄': {
    description: '고통의 연쇄 효과가 걸린 대상을 중심으로 적들에게 대지속성 피해를 줍니다. 그로기 게이지 피해량 7',
    notes: ''
  },
  '치유의 빛': {
    description: '생명력이 가장 낮은 파티원과 자신의 생명력을 회복합니다. 재생의 빛 효과가 활성화된 상태에서도 사용할 수 있습니다.',
    notes: '논타겟, 이동 가능'
  },
  '쾌유의 광휘': {
    description: '자신과 주변 파티원들의 생명력을 회복합니다. 최대 차지 시 추가 회복합니다.',
    notes: '논타겟, 차지 스킬'
  },
  '벽력': {
    description: '대상을 중심으로 적들에게 바람속성 피해를 줍니다. 그로기 게이지 피해량 20',
    notes: '차지 스킬'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 강인함 상태가 됩니다. [강인함]: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 재생의 축복: 자신의 생명력과 정신력을 회복합니다.',
    notes: '논타겟, 이동 가능'
  }
};

const clericPassiveSkillDescriptions = {
  '따뜻한 가호': {
    description: '자신의 최대 생명력 및 정신력이 증가합니다.',
    notes: ''
  },
  '주신의 가호': {
    description: '자신의 막기가 증가하고, 막기 성공 후 생명력을 회복합니다.',
    notes: ''
  },
  '주신의 은총': {
    description: '지속 피해를 입는 대상에게 공격을 적중시킬 때마다 일정 확률로 추가 피해를 줍니다.',
    notes: ''
  },
  '치유력 강화': {
    description: '자신의 치유 증폭이 증가합니다.',
    notes: ''
  },
  '불사의 장막': {
    description: '자신의 방어력 및 치명타 저항이 증가합니다.',
    notes: ''
  },
  '회복 차단': {
    description: '공격이 적중할 때마다 일정 확률로 대상의 받는 치유량을 감소시킵니다.',
    notes: ''
  },
  '집중의 기도': {
    description: '자신의 생명력이 일정량 이하일 때 보호막을 생성하고 치유 증폭이 증가합니다.',
    notes: ''
  },
  '대지의 은총': {
    description: '자신의 생명력이 일정량 이상일 때, 공격 적중 시 자신과 주변 파티원들의 공격력이 증가합니다.',
    notes: ''
  },
  '생존 의지': {
    description: '자신의 상태이상 저항이 증가하고, 충격계 상태일 때 충격계 저항 및 피해 내성이 증가합니다.',
    notes: ''
  },
  '찬란한 가호': {
    description: '공격이 적중할 때마다 일정 확률로 자신과 주변 파티원들의 생명력을 회복시킵니다.',
    notes: ''
  }
};

const clericStigmaSkillDescriptions = {
  '권능 폭발': {
    description: '대상에게 대지속성 피해를 줍니다. 그로기 게이지 피해량 50',
    notes: ''
  },
  '면죄': {
    description: '자신과 주변 파티원들에게 걸린 약화 효과를 최대 2개까지 제거하고 생명력을 회복합니다.',
    notes: '논타겟'
  },
  '치유의 기운': {
    description: '자신 근처에 치유의 기운을 소환합니다. 기운은 이동할 수 없으며, 시전자와 파티원들의 생명력을 일정 간격으로 회복합니다.',
    notes: '논타겟'
  },
  '증폭의 기도': {
    description: '일정 시간 동안 자신의 공격력이 증가합니다.',
    notes: '논타겟, 이동 가능'
  },
  '소환 부활': {
    description: '자신 주변 일정 범위 내에 있는 사망한 파티원을 자신 근처에서 부활시킵니다.',
    notes: '논타겟'
  },
  '대지의 징벌': {
    description: '대상에게 대지속성 피해를 주고 막기와 회피를 감소시킵니다. 일정 간격으로 피해를 줍니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '구원': {
    description: '모든 피해를 무효화하고 상태이상에 걸리지 않습니다. 일부 강력한 공격은 방어할 수 없습니다.',
    notes: '논타겟, 이동 가능'
  },
  '속박': {
    description: '대상을 중심으로 적들에게 대지속성 피해를 주고 일정 확률로 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 속박이 적중됩니다. 그로기 게이지 피해량 15',
    notes: '이동 가능'
  },
  '보호의 빛': {
    description: '일정 시간 동안 자신과 주변 파티원들의 최대 생명력이 증가하고, 생명력을 즉시 회복합니다.',
    notes: '논타겟'
  },
  '유스티엘의 권능': {
    description: '일정 시간 동안 자신과 주변 파티원들의 피해 내성이 증가합니다.',
    notes: '논타겟'
  },
  '파멸의 목소리': {
    description: '대상을 중심으로 적들에게 대지속성 피해를 줍니다. 적들은 일정 간격으로 지속 피해를 받고 받는 치유량이 감소합니다.',
    notes: ''
  },
  '강습 낙인': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 속박이 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// ==================== 정령성 ====================
const spiritmasterActiveSkillDescriptions = {
  '냉기 충격': {
    description: '대상에게 물속성 피해를 주고, 정신력을 회복합니다. (연계기) 진공 폭발: 대상에게 바람속성 피해를 주고, 정신력을 회복합니다. (연계기) 대지 진동: 대상에게 땅속성 피해를 주고, 정신력을 회복합니다.',
    notes: '이동 가능'
  },
  '화염 전소': {
    description: '대상을 중심으로 적들에게 불속성 피해를 줍니다. 그로기 게이지 피해량 3',
    notes: ''
  },
  '소환: 불의 정령': {
    description: '불의 정령을 소환합니다. 불의 정령은 대상에게 돌진하여 적들에게 불속성 피해를 주는 스킬을 사용합니다. 스킬 사용 후 일반 공격으로 전투를 지속하며, 소환 아이콘을 선택하면 소환이 해제됩니다. 스킬 레벨이 증가할 때마다 불의 정령의 공격력과 방어력이 증가합니다. 그로기 게이지 피해량 7',
    notes: '이동 가능'
  },
  '소환: 물의 정령': {
    description: '물의 정령을 소환합니다. 물의 정령은 대상에게 물속성 피해를 주는 스킬을 사용합니다. 스킬 사용 후 일반 공격으로 전투를 지속하며, 공격이 적중할 때마다 정령성의 정신력을 회복시킵니다. 소환 아이콘을 선택하면 소환이 해제됩니다. 스킬 레벨이 증가할 때마다 불의 정령의 공격력과 치명타 증가합니다. 그로기 게이지 피해량 7',
    notes: '이동 가능'
  },
  '협공: 저주': {
    description: '대상을 중심으로 적들에게 피해를 주고 일정 간격으로 지속 피해를 받는 저주 상태로 만듭니다. 정령과 함께 협공을 합니다. 불: 광역 피해 물: 단일 피해 땅: 단일 피해 및 상태이상 저항 감소 바람: 광역 피해 및 지속 피해, 치명타 피해 내성 감소 고대: 광역 피해 그로기 게이지 피해량 10',
    notes: ''
  },
  '연속 난사': {
    description: '그로기 상태인 대상에게 피해를 줍니다.',
    notes: ''
  },
  '소환: 땅의 정령': {
    description: '땅의 정령을 소환합니다. 땅의 정령은 대상에게 땅속성 피해를 주고 적대치를 증가시키는 스킬을 사용합니다. 대상이 PC인 경우 일정 확률로 도발 상태로 만듭니다. 스킬 사용 후 일반 공격으로 전투를 지속하며, 공격이 적중할 때마다 적대치를 증가시킵니다. 소환 아이콘을 선택하면 소환이 해제됩니다. 스킬 레벨이 증가할 때마다 땅의 정령의 방어력과 생명력이 증가합니다. 그로기 게이지 피해량 7',
    notes: '이동 가능'
  },
  '공간 지배': {
    description: '정령 소환 스킬 사용 후 짧은 시간 활성화되는 스킬입니다. 대상을 중심으로 적들에게 피해를 주고 이동 속도를 감소시키는 둔화 상태로 만듭니다. 정신력을 회복합니다. 그로기 게이지 피해량 5',
    notes: '이동 가능'
  },
  '소환: 바람의 정령': {
    description: '바람의 정령을 소환합니다. 바람의 정령은 대상을 중심으로 적들에게 바람속성 피해를 주고 정령성의 생명력을 회복시키는 스킬을 사용합니다. 스킬 사용 후 일반 공격으로 전투를 지속하며, 공격이 적중할 때마다 정령성의 생명력을 회복시킵니다. 소환 아이콘을 선택하면 소환이 해제됩니다. 스킬 레벨이 증가할 때마다 바람의 정령의 명중과 치명타 증가합니다. 그로기 게이지 피해량 7',
    notes: '이동 가능'
  },
  '영혼의 절규': {
    description: '대상에게 피해를 주고, 일정 확률로 공포 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공포가 적중됩니다. 그로기 게이지 피해량 15',
    notes: ''
  },
  '원소 융합': {
    description: '정령을 소환할 때마다 정령성은 원소를 획득합니다. 모든 원소를 획득하면 4원소 상태가 되며, 원소 융합 스킬을 사용할 수 있습니다. 4원소 효과를 획득한 상태에서만 원소 융합을 사용할 수 있으며, 사용 시 대상에게 피해를 줍니다. 원소 융합을 사용하면 4원소는 즉시 삭제됩니다. 그로기 게이지 피해량 10',
    notes: '이동 가능'
  },
  '충격 해제': {
    description: '자신의 기절, 넘어짐, 공중 속박 상태를 해제하고 [강인함] 상태가 됩니다. [강인함]: 기절, 넘어짐, 공중 속박 저항 증가 (연계기) 절망의 저주: 대상에게 피해를 주고, 일정 확률로 공포 및 속박 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공포 및 속박이 적중됩니다.',
    notes: ''
  },
  '마법 강탈': {
    description: '대상을 중심으로 적들에게 피해를 주고 강화 마법을 최대 2개 제거합니다. 강화 마법의 삭제 개수에 따라 추가 피해를 줍니다. 그로기 게이지 피해량 20',
    notes: '이동 가능'
  },
  '마법 차단': {
    description: '대상에게 피해를 주고, 일정 확률로 봉인 상태로 만듭니다. 그로기 게이지 피해량 20',
    notes: ''
  }
};

const spiritmasterPassiveSkillDescriptions = {
  '정령 타격': {
    description: '자신의 공격력과 정령의 공격력이 증가합니다.',
    notes: ''
  },
  '정령 보호': {
    description: '자신의 방어력과 정령의 방어력이 증가합니다.',
    notes: ''
  },
  '정령 강림': {
    description: '정령 소환 후 정령성의 공격이 적중할 때마다 일정 확률로 추가 피해를 줍니다.',
    notes: ''
  },
  '침식': {
    description: '자신의 치명타가 증가하고, 치명타 적중 시 일정 확률로 지속 피해를 줍니다.',
    notes: ''
  },
  '정령 회생': {
    description: '소환된 정령의 생명력이 일정량 이하일 때 최대 생명력을 회복합니다.',
    notes: ''
  },
  '정신 집중': {
    description: '자신의 정신계 적중 및 강타가 증가합니다.',
    notes: ''
  },
  '연속 역류': {
    description: '지속 피해를 입는 대상에게 공격을 적중시킬 때마다 일정 확률로 추가 피해를 줍니다.',
    notes: ''
  },
  '정령 교감': {
    description: '공격이 적중할 때마다 일정 확률로 자신과 정령의 생명력을 회복합니다.',
    notes: ''
  },
  '회생의 계약': {
    description: '자신의 상태이상 저항이 증가하고, 생명력이 일정량 이하일 때 생명력을 즉시 회복합니다.',
    notes: ''
  },
  '원소 결집': {
    description: '소환 스킬 공격이 적중할 때마다 일정 간격으로 지속 피해를 줍니다.',
    notes: ''
  }
};

const spiritmasterStigmaSkillDescriptions = {
  '협공: 파멸의 공세': {
    description: '대상에게 피해를 줍니다. 정령과 함께 협공을 합니다. 불: 광역 피해 물: 단일 피해 땅: 단일 피해 바람: 광역 피해 고대: 광역 피해 그로기 게이지 피해량 50',
    notes: ''
  },
  '강화: 정령의 가호': {
    description: '자신과 소환된 정령의 피해 증폭 및 피해 내성이 증가하고, 일정 간격으로 생명력을 회복합니다.',
    notes: '이동 가능'
  },
  '불길의 축복': {
    description: '자신과 주변 파티원들이 공격할 때마다 일정 확률로 적들에게 추가 피해를 줍니다.',
    notes: '이동 가능'
  },
  '소환: 고대의 정령': {
    description: '고대의 정령을 소환합니다. 고대의 정령은 대상을 중심으로 적들에게 피해를 주는 스킬을 사용합니다. 스킬 사용 후 일반 공격으로 전투를 지속하며, 소환 아이콘을 선택하면 소환이 해제됩니다. 스킬 레벨이 증가할 때마다 고대의 정령의 공격력, 방어력, 명중, 치명타 증가합니다. 그로기 게이지 피해량 20',
    notes: '이동 가능'
  },
  '협공: 부식': {
    description: '대상을 중심으로 적들에게 피해를 주고 부식 상태로 만듭니다. [부식]: 모든 속성 내성 감소, 일정 간격으로 지속 피해 정령과 함께 협공을 합니다. 불: 광역 피해 및 넘어짐 물: 단일 피해 및 둔화 땅: 단일 피해 및 속박 바람: 광역 피해 및 기절 고대: 광역 피해 및 넘어짐 그로기 게이지 피해량 10',
    notes: ''
  },
  '카이시넬의 권능': {
    description: '자신과 주변 파티원들에게 걸린 약화 효과를 제거하고 일정 시간 동안 상태이상 저항이 증가합니다.',
    notes: '이동 가능'
  },
  '흡인': {
    description: '대상에게 피해 및 정신력 피해를 줍니다. 피해량의 일정 비율만큼 생명력을 회복하고, 정신력을 일정량 회복합니다.',
    notes: ''
  },
  '공포의 절규': {
    description: '자신을 중심으로 적들에게 피해를 주고 일정 확률로 공포 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공포가 적중됩니다.',
    notes: ''
  },
  '저주의 구름': {
    description: '대상을 중심으로 적들에게 피해를 줍니다. 적들은 일정 간격으로 지속 피해를 받습니다. 그로기 게이지 피해량 20',
    notes: ''
  },
  '강습 공포': {
    description: '대상을 중심으로 적들에게 피해 및 정신력 피해를 주고 일정 확률로 공포 상태로 만듭니다. 대상이 NPC일 경우 100%의 확률로 공포가 적중됩니다. 적중 인원 수에 비례하여 방어력이 증가합니다.',
    notes: '활강 전용'
  }
};

// 스킬 설명 데이터 접근 함수
function getSkillDescription(job, skillType, baseSkillName) {
  if (!job || !skillType || !baseSkillName) return null;
  
  let skillData = null;
  
  if (job === '마도성') {
    if (skillType === 'active') {
      skillData = mageActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = magePassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = mageStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '검성') {
    if (skillType === 'active') {
      skillData = warriorActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = warriorPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = warriorStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '수호성') {
    if (skillType === 'active') {
      skillData = guardianActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = guardianPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = guardianStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '살성') {
    if (skillType === 'active') {
      skillData = assassinActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = assassinPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = assassinStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '궁성') {
    if (skillType === 'active') {
      skillData = rangerActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = rangerPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = rangerStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '호법성') {
    if (skillType === 'active') {
      skillData = priestActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = priestPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = priestStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '치유성') {
    if (skillType === 'active') {
      skillData = clericActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = clericPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = clericStigmaSkillDescriptions[baseSkillName];
    }
  } else if (job === '정령성') {
    if (skillType === 'active') {
      skillData = spiritmasterActiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'passive') {
      skillData = spiritmasterPassiveSkillDescriptions[baseSkillName];
    } else if (skillType === 'stigma') {
      skillData = spiritmasterStigmaSkillDescriptions[baseSkillName];
    }
  }
  
  return skillData;
}

// 스킬명에서 화살표 앞부분만 추출
function extractBaseSkillName(skillName) {
  if (!skillName) return '';
  // 화살표(→) 또는 화살표 유사 문자 제거
  const arrowPattern = /[→→→?]/;
  if (arrowPattern.test(skillName)) {
    return skillName.split(arrowPattern)[0].trim();
  }
  return skillName.trim();
}

// 스킬 breakdown 계산 함수
function calculateSkillBreakdown(skillName) {
  // 안전성 체크: skillName이 없으면 빈 breakdown 반환
  if (!skillName || typeof skillName !== 'string') {
    return { arcana: 0, equipment: 0, base: 0 };
  }
  
  const breakdown = {
    arcana: 0,
    equipment: 0,
    base: 0
  };
  
  try {
    // 1. 아르카나에서 스킬 포인트 수집
    const allItems = [...(window.currentEquipment || []), ...(window.currentAccessories || [])];
    
    allItems.forEach(item => {
      if (!item || typeof item !== 'object') return;
      
      if (isArcanaItem(item) && item.sub_skills && Array.isArray(item.sub_skills)) {
        item.sub_skills.forEach(subSkill => {
          if (!subSkill || typeof subSkill !== 'object') return;
          
          const subSkillName = subSkill.name || '';
          if (!subSkillName) return;
          
          try {
            if (subSkillName === skillName || extractBaseSkillName(subSkillName) === extractBaseSkillName(skillName)) {
              const level = parseInt(subSkill.level || subSkill.level_int || 0, 10);
              if (!isNaN(level) && level > 0) {
                breakdown.arcana += level;
              }
            }
          } catch (e) {
            // extractBaseSkillName 에러 무시하고 계속 진행
          }
        });
      }
    });
    
    // 2. 장비/장신구 부스킬에서 스킬 포인트 수집
    allItems.forEach(item => {
      if (!item || typeof item !== 'object') return;
      
      if (!isArcanaItem(item) && item.sub_skills && Array.isArray(item.sub_skills)) {
        item.sub_skills.forEach(subSkill => {
          if (!subSkill || typeof subSkill !== 'object') return;
          
          const subSkillName = subSkill.name || '';
          if (!subSkillName) return;
          
          try {
            if (subSkillName === skillName || extractBaseSkillName(subSkillName) === extractBaseSkillName(skillName)) {
              const level = parseInt(subSkill.level || subSkill.level_int || 0, 10);
              if (!isNaN(level) && level > 0) {
                breakdown.equipment += level;
              }
            }
          } catch (e) {
            // extractBaseSkillName 에러 무시하고 계속 진행
          }
        });
      }
    });
  } catch (e) {
    // 전체 에러 발생 시 빈 breakdown 반환
    return { arcana: 0, equipment: 0, base: 0 };
  }
  
  return breakdown;
}

function createSkillTooltip(skillName, job, skillType, skillLevel) {
  if (!job) return null;
  
  const baseName = extractBaseSkillName(skillName);
  
  // skill-descriptions.js의 getSkillDescription 함수 사용
  if (typeof getSkillDescription !== 'function') {
    return null;
  }
  
  const skillData = getSkillDescription(job, skillType, baseName);
  
  if (!skillData) {
    // 디버깅: 스킬 데이터를 찾을 수 없는 경우
    return null;
  }
  
  const tooltip = document.createElement('div');
  tooltip.className = 'skill-tooltip';
  
  let html = `<div class="skill-tooltip-title">${baseName}</div>`;
  
  // 스킬 레벨 표시 (breakdown 포함)
  if (skillLevel) {
    const levelInt = parseInt(skillLevel, 10) || 0;
    const breakdown = calculateSkillBreakdown(skillName);
    
    // 기본 스킬 포인트 계산 (전체 레벨 - 보너스 포인트)
    breakdown.base = Math.max(0, levelInt - breakdown.arcana - breakdown.equipment);
    
    // breakdown이 있는 경우에만 표시
    if (breakdown.arcana > 0 || breakdown.equipment > 0 || breakdown.base > 0) {
      const breakdownParts = [];
      if (breakdown.arcana > 0) {
        breakdownParts.push(`<span style="color: #4ade80;">아르카나 ${breakdown.arcana}</span>`);
      }
      if (breakdown.equipment > 0) {
        breakdownParts.push(`<span style="color: #60a5fa;">장비/장신구 ${breakdown.equipment}</span>`);
      }
      if (breakdown.base > 0) {
        breakdownParts.push(`<span style="color: #ffffff;">기타 포인트 ${breakdown.base}</span>`);
      }
      
      html += `<div class="skill-tooltip-level">Lv ${skillLevel} (${breakdownParts.join(' + ')})</div>`;
    } else {
      html += `<div class="skill-tooltip-level">Lv ${skillLevel}</div>`;
    }
  }
  
  // 설명에서 특수 정보(그로기 게이지 피해량 등) 추출
  const description = skillData.description || '';
  // 그로기 게이지 피해량, 그로기 게이지 등 다양한 패턴 매칭
  const specialInfoPattern = /(그로기 게이지\s*(?:피해량\s*)?\d+)/g;
  const specialInfoMatches = description.match(specialInfoPattern);
  
  // 설명에서 특수 정보 제거 (마지막에 있는 경우만)
  let cleanDescription = description;
  if (specialInfoMatches) {
    specialInfoMatches.forEach(match => {
      // 설명 끝부분의 특수 정보만 제거 (앞부분에 있는 경우는 유지)
      const matchIndex = cleanDescription.lastIndexOf(match);
      if (matchIndex !== -1 && matchIndex + match.length >= cleanDescription.length - 5) {
        cleanDescription = cleanDescription.substring(0, matchIndex).trim();
      }
    });
  }
  
  html += `<div class="skill-tooltip-description">${cleanDescription}</div>`;
  
  // 특수 정보를 빨간색으로 별도 표시 (줄바꿈)
  if (specialInfoMatches && specialInfoMatches.length > 0) {
    html += `<div class="skill-tooltip-special-info">${specialInfoMatches.join('<br>')}</div>`;
  }
  
  if (skillData.notes) {
    html += `<div class="skill-tooltip-notes">${skillData.notes}</div>`;
  }
  
  tooltip.innerHTML = html;
  return tooltip;
}

function renderSkillCategory(list, container, section, emptyMessage) {
  if (!container) return false;
  container.innerHTML = '';
  const hasData = Array.isArray(list) && list.length > 0;
  if (!hasData) {
    container.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; color: var(--text-muted); padding: 1rem;">${emptyMessage}</div>`;
    if (section) section.style.display = 'block';
    return false;
  }

  // 현재 직업 정보 가져오기 (마도성 체크용)
  const currentJob = window.currentJobName || '';
  
  // 스킬 타입 판별
  let skillType = 'active';
  if (container.id === 'skills-passive-container') {
    skillType = 'passive';
  } else if (container.id === 'stigmas-container') {
    skillType = 'stigma';
  }

  // 우선순위 정보 가져오기
  const skillPriorities = window.currentSkillPriorities || { active: [], passive: [], stigma: [] };
  let priorityData = [];
  if (skillType === 'active') {
    priorityData = skillPriorities.active || [];
  } else if (skillType === 'passive') {
    priorityData = skillPriorities.passive || [];
  } else if (skillType === 'stigma') {
    priorityData = skillPriorities.stigma || [];
  }
  
  list.forEach(skill => {
    const levelInt = skill.level_int || parseInt(skill.level || '0', 10) || 0;
    if (levelInt <= 0) {
      return;
    }
    const skillItem = document.createElement('div');
    skillItem.className = 'skill-item';
    skillItem.setAttribute('data-skill-name', skill.name || '');

    // 아이콘 래퍼 생성
    const iconWrapper = document.createElement('div');
    iconWrapper.className = 'skill-icon-wrapper';

    const img = document.createElement('img');
    img.src = skill.icon_url || '';
    img.alt = skill.name || '스킬';
    img.onerror = function() {
      this.style.display = 'none';
    };

    iconWrapper.appendChild(img);
    
    // 우선순위 배지 추가 (채용률 10% 미만 스킬은 표시하지 않음)
    const priorityInfo = priorityData.find(p => p.skill_name === skill.name);
    
    // skillItem에 position relative 추가 (배지 위치 지정을 위해)
    skillItem.style.position = 'relative';
    
    if (priorityInfo && priorityInfo.priority && (priorityInfo.adoption_rate || 0) >= 10) {
      // priority 1-3위에만 별표 표시
      if (priorityInfo.priority <= 3) {
        const starCount = 4 - priorityInfo.priority; // 1위=3개, 2위=2개, 3위=1개
        const stars = '★'.repeat(starCount);
        
        const priorityBadge = document.createElement('div');
        priorityBadge.className = `skill-rank-badge rank-${priorityInfo.priority}`;
        priorityBadge.textContent = stars;
        priorityBadge.title = `${priorityInfo.priority}위 (채용률: ${priorityInfo.adoption_rate.toFixed(1)}%)`;
        // skillItem에 직접 추가 (iconWrapper는 overflow: hidden이라 잘림)
        skillItem.appendChild(priorityBadge);
      }
      
      // 기존 우선순위 번호 배지는 제거하거나 주석 처리
      /* const priorityBadge = document.createElement('div');
      priorityBadge.className = 'skill-priority-badge';
      priorityBadge.textContent = priorityInfo.priority;
      priorityBadge.title = `우선순위 ${priorityInfo.priority}위 (채용률: ${priorityInfo.adoption_rate.toFixed(1)}%)`;
      iconWrapper.appendChild(priorityBadge); */
    }
    
    skillItem.appendChild(iconWrapper);

    if (skill.name) {
      const nameDiv = document.createElement('div');
      nameDiv.className = 'skill-name';
      nameDiv.textContent = skill.name;
      skillItem.appendChild(nameDiv);
    }

    if (skill.level) {
      const levelDiv = document.createElement('div');
      levelDiv.className = 'skill-level';
      levelDiv.textContent = `LV ${skill.level}`;
      skillItem.appendChild(levelDiv);
    }

    // 스킬 툴팁 추가 (지원되는 직업인 경우)
    if (currentJob) {
      const tooltip = createSkillTooltip(skill.name, currentJob, skillType, skill.level);
      if (tooltip) {
        // skillItem에 position: relative 명시 (툴팁 위치 지정을 위해)
        if (!skillItem.style.position) {
          skillItem.style.position = 'relative';
        }
        skillItem.appendChild(tooltip);
      }
    }

    container.appendChild(skillItem);
  });

  if (section) section.style.display = 'block';
  return true;
}

// 장비 정보 표시 함수
// 아르카나 아이템인지 확인하는 함수
function isArcanaItem(item) {
  if (!item || !item.name) return false;
  const name = item.name.toLowerCase();
  const arcanaKeywords = ['성배', '양피지', '나침반', '종', '거울'];
  return arcanaKeywords.some(keyword => name.includes(keyword));
}

// 아르카나 아이템 생성 함수
function createArcanaItem(item) {
  if (!item || !item.name) {
    return null;
  }
  
  const itemDiv = document.createElement('div');
  itemDiv.className = 'arcana-item';
  
  // 아이콘
  const iconDiv = document.createElement('div');
  iconDiv.className = 'arcana-item-icon';
  
  if (item.icon_url) {
    const img = document.createElement('img');
    img.src = item.icon_url;
    img.alt = item.name;
    iconDiv.appendChild(img);
  }
  
  // 이름
  const nameDiv = document.createElement('div');
  nameDiv.className = 'arcana-item-name';
  
  // 강화 수치
  const enhanceLevel = item.enhance_level || 0;
  if (enhanceLevel > 0) {
    nameDiv.textContent = `+${enhanceLevel} ${item.name}`;
  } else {
    nameDiv.textContent = item.name;
  }
  
  // 등급에 따른 색상 적용 (마석 각인과 동일한 방식)
  const grade = item.grade || '';
  if (grade) {
    const gradeColor = getGradeColor(grade);
    if (gradeColor) {
      nameDiv.style.color = gradeColor;
    }
  }
  
  itemDiv.appendChild(iconDiv);
  itemDiv.appendChild(nameDiv);
  
  // 오버레이 툴팁 생성
  const tooltip = createArcanaTooltip(item);
  if (tooltip) {
    itemDiv.appendChild(tooltip);
  }
  
  return itemDiv;
}

// 아르카나 아이템 툴팁 생성 함수
function createArcanaTooltip(item) {
  const hasMainStats = item.main_stats && Array.isArray(item.main_stats) && item.main_stats.length > 0;
  const hasSubSkills = item.sub_skills && Array.isArray(item.sub_skills) && item.sub_skills.length > 0;
  
  // mainStats나 subSkills가 없으면 툴팁 생성하지 않음
  if (!hasMainStats && !hasSubSkills) {
    return null;
  }
  
  const tooltip = document.createElement('div');
  tooltip.className = 'arcana-tooltip';
  
  // mainStats 섹션
  if (hasMainStats) {
    const mainStatsSection = document.createElement('div');
    mainStatsSection.className = 'arcana-tooltip-section';
    
    const mainStatsTitle = document.createElement('div');
    mainStatsTitle.className = 'arcana-tooltip-section-title';
    mainStatsTitle.textContent = '기본 옵션';
    mainStatsSection.appendChild(mainStatsTitle);
    
    item.main_stats.forEach(stat => {
      const statDiv = document.createElement('div');
      statDiv.className = 'arcana-tooltip-stat';
      
      const statName = document.createElement('span');
      statName.className = 'arcana-tooltip-stat-name';
      statName.textContent = (stat.name || stat.id || '') + ': ';
      
      const statValue = document.createElement('span');
      statValue.className = 'arcana-tooltip-stat-value';
      let valueText = stat.value || '';
      if (stat.extra && parseInt(stat.extra) > 0) {
        valueText += ` (+${stat.extra})`;
      }
      statValue.textContent = valueText;
      
      statDiv.appendChild(statName);
      statDiv.appendChild(statValue);
      mainStatsSection.appendChild(statDiv);
    });
    
    tooltip.appendChild(mainStatsSection);
  }
  
  // subSkills 섹션
  if (hasSubSkills) {
    const subSkillsSection = document.createElement('div');
    subSkillsSection.className = 'arcana-tooltip-section';
    
    const subSkillsTitle = document.createElement('div');
    subSkillsTitle.className = 'arcana-tooltip-section-title';
    subSkillsTitle.textContent = '부스킬';
    subSkillsSection.appendChild(subSkillsTitle);
    
    item.sub_skills.forEach(skill => {
      const skillDiv = document.createElement('div');
      skillDiv.className = 'arcana-tooltip-skill';
      
      // 스킬 아이콘
      if (skill.icon) {
        const skillIcon = document.createElement('img');
        skillIcon.className = 'arcana-tooltip-skill-icon';
        skillIcon.src = skill.icon;
        skillIcon.alt = skill.name || '';
        skillDiv.appendChild(skillIcon);
      }
      
      // 스킬 이름
      const skillName = document.createElement('span');
      skillName.className = 'arcana-tooltip-skill-name';
      skillName.textContent = skill.name || '';
      skillDiv.appendChild(skillName);
      
      // 스킬 레벨
      if (skill.level) {
        const skillLevel = document.createElement('span');
        skillLevel.className = 'arcana-tooltip-skill-level';
        skillLevel.textContent = `+${skill.level}`;
        skillDiv.appendChild(skillLevel);
      }
      
      subSkillsSection.appendChild(skillDiv);
    });
    
    tooltip.appendChild(subSkillsSection);
  }
  
  return tooltip;
}

function displayEquipment(equipment, accessories) {
  const equipmentInfo = document.getElementById('equipment-info');
  const equipmentContainer = document.getElementById('equipment-container');
  const accessoriesContainer = document.getElementById('accessories-container');
  const arcanaInfo = document.getElementById('arcana-info');
  const arcanaContainer = document.getElementById('arcana-container');
  const equipmentTwoColumn = document.getElementById('equipment-two-column');
  const equipmentColumn = document.getElementById('equipment-column');
  const accessoriesColumn = document.getElementById('accessories-column');
  
  // 화면 너비 체크 - 640~770px 사이에서만 세로 배치
  const width = window.innerWidth;
  const shouldUseColumn = width >= 640 && width <= 770;
  const isMobile = width < 640;
  
  // 모든 모바일/태블릿 크기에서 스크롤 스타일 적용 (640~770px와 동일하게)
  if (equipmentContainer && (shouldUseColumn || isMobile)) {
    equipmentContainer.style.cssText += 'max-height: 600px !important; min-height: 200px !important; height: auto !important; overflow-y: auto !important; overflow-x: hidden !important; padding-right: 0.25rem !important; display: flex !important; flex-direction: column !important;';
  }
  
  if (accessoriesContainer && (shouldUseColumn || isMobile)) {
    accessoriesContainer.style.cssText += 'max-height: 600px !important; min-height: 200px !important; height: auto !important; overflow-y: auto !important; overflow-x: hidden !important; padding-right: 0.25rem !important; display: flex !important; flex-direction: column !important;';
  }
  
  // 중간 너비에서는 강제로 세로 배치 적용
  if (equipmentTwoColumn && shouldUseColumn) {
    // CSS 클래스 추가로 더 강력하게 적용
    equipmentTwoColumn.classList.add('force-column-layout');
    equipmentTwoColumn.setAttribute('data-layout', 'column');
    
    // 인라인 스타일로 강제 적용
    equipmentTwoColumn.style.setProperty('display', 'flex', 'important');
    equipmentTwoColumn.style.setProperty('flex-direction', 'column', 'important');
    equipmentTwoColumn.style.setProperty('gap', '2rem', 'important');
    equipmentTwoColumn.style.setProperty('align-items', 'stretch', 'important');
    equipmentTwoColumn.style.setProperty('width', '100%', 'important');
    equipmentTwoColumn.style.setProperty('max-width', '100%', 'important');
    equipmentTwoColumn.style.setProperty('box-sizing', 'border-box', 'important');
    
    if (equipmentColumn) {
      equipmentColumn.style.setProperty('width', '100%', 'important');
      equipmentColumn.style.setProperty('max-width', '100%', 'important');
      equipmentColumn.style.setProperty('box-sizing', 'border-box', 'important');
      equipmentColumn.style.setProperty('order', '1', 'important');
      equipmentColumn.style.setProperty('margin-bottom', '1rem', 'important');
      equipmentColumn.style.setProperty('flex', 'none', 'important');
      equipmentColumn.style.setProperty('min-width', '0', 'important');
    }
    
    if (accessoriesColumn) {
      accessoriesColumn.style.setProperty('width', '100%', 'important');
      accessoriesColumn.style.setProperty('max-width', '100%', 'important');
      accessoriesColumn.style.setProperty('box-sizing', 'border-box', 'important');
      accessoriesColumn.style.setProperty('order', '2', 'important');
      accessoriesColumn.style.setProperty('margin-top', '1rem', 'important');
      accessoriesColumn.style.setProperty('flex', 'none', 'important');
      accessoriesColumn.style.setProperty('min-width', '0', 'important');
    }
    
    // 640~770px 범위에서 장비/장신구 컨테이너에 스크롤 스타일 명시적으로 추가 - 항상 스크롤바 표시
    if (equipmentContainer) {
      equipmentContainer.style.setProperty('max-height', '600px', 'important');
      equipmentContainer.style.setProperty('overflow-y', 'scroll', 'important');
      equipmentContainer.style.setProperty('overflow-x', 'hidden', 'important');
      equipmentContainer.style.setProperty('padding-right', '0.25rem', 'important');
    }
    
    if (accessoriesContainer) {
      accessoriesContainer.style.setProperty('max-height', '600px', 'important');
      accessoriesContainer.style.setProperty('overflow-y', 'scroll', 'important');
      accessoriesContainer.style.setProperty('overflow-x', 'hidden', 'important');
      accessoriesContainer.style.setProperty('padding-right', '0.25rem', 'important');
    }
  } else if (equipmentTwoColumn) {
    equipmentTwoColumn.classList.remove('force-column-layout');
    equipmentTwoColumn.setAttribute('data-layout', 'grid');
    equipmentTwoColumn.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;';
    if (equipmentColumn) {
      equipmentColumn.style.cssText = '';
    }
    if (accessoriesColumn) {
      accessoriesColumn.style.cssText = '';
    }
  }
  
  // 리사이즈 이벤트 리스너 추가 (디바운싱) - 전역으로 한 번만 등록
  if (!window.equipmentResizeHandlerAdded) {
    let resizeTimeout;
    const handleResize = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const equipmentTwoColumn = document.getElementById('equipment-two-column');
        if (equipmentTwoColumn) {
          const width = window.innerWidth;
          // 640~770px 사이에서만 세로 배치
          const shouldUseColumn = width >= 640 && width <= 770;
          const isMobile = width < 640;
          const equipmentColumn = document.getElementById('equipment-column');
          const accessoriesColumn = document.getElementById('accessories-column');
          const equipmentContainer = document.getElementById('equipment-container');
          const accessoriesContainer = document.getElementById('accessories-container');
          
          // 모든 모바일/태블릿 크기에서 스크롤 스타일 적용 (640~770px와 동일하게) - 항상 스크롤바 표시
          if (equipmentContainer && (shouldUseColumn || isMobile)) {
            equipmentContainer.style.cssText += 'max-height: 600px !important; min-height: 200px !important; height: auto !important; overflow-y: scroll !important; overflow-x: hidden !important; padding-right: 0.25rem !important; display: flex !important; flex-direction: column !important;';
          }
          
          if (accessoriesContainer && (shouldUseColumn || isMobile)) {
            accessoriesContainer.style.cssText += 'max-height: 600px !important; min-height: 200px !important; height: auto !important; overflow-y: scroll !important; overflow-x: hidden !important; padding-right: 0.25rem !important; display: flex !important; flex-direction: column !important;';
          }
          
          if (shouldUseColumn) {
            equipmentTwoColumn.classList.add('force-column-layout');
            equipmentTwoColumn.setAttribute('data-layout', 'column');
            equipmentTwoColumn.style.setProperty('display', 'flex', 'important');
            equipmentTwoColumn.style.setProperty('flex-direction', 'column', 'important');
            equipmentTwoColumn.style.setProperty('gap', '2rem', 'important');
            equipmentTwoColumn.style.setProperty('align-items', 'stretch', 'important');
            equipmentTwoColumn.style.setProperty('width', '100%', 'important');
            equipmentTwoColumn.style.setProperty('max-width', '100%', 'important');
            equipmentTwoColumn.style.setProperty('box-sizing', 'border-box', 'important');
            
            if (equipmentColumn) {
              equipmentColumn.style.setProperty('width', '100%', 'important');
              equipmentColumn.style.setProperty('max-width', '100%', 'important');
              equipmentColumn.style.setProperty('box-sizing', 'border-box', 'important');
              equipmentColumn.style.setProperty('order', '1', 'important');
              equipmentColumn.style.setProperty('margin-bottom', '1rem', 'important');
              equipmentColumn.style.setProperty('flex', 'none', 'important');
              equipmentColumn.style.setProperty('min-width', '0', 'important');
            }
            
            if (accessoriesColumn) {
              accessoriesColumn.style.setProperty('width', '100%', 'important');
              accessoriesColumn.style.setProperty('max-width', '100%', 'important');
              accessoriesColumn.style.setProperty('box-sizing', 'border-box', 'important');
              accessoriesColumn.style.setProperty('order', '2', 'important');
              accessoriesColumn.style.setProperty('margin-top', '1rem', 'important');
              accessoriesColumn.style.setProperty('flex', 'none', 'important');
              accessoriesColumn.style.setProperty('min-width', '0', 'important');
            }
            
          } else {
            equipmentTwoColumn.classList.remove('force-column-layout');
            equipmentTwoColumn.setAttribute('data-layout', 'grid');
            equipmentTwoColumn.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;';
            if (equipmentColumn) {
              equipmentColumn.style.cssText = '';
            }
            if (accessoriesColumn) {
              accessoriesColumn.style.cssText = '';
            }
            
            // 모바일이 아닐 때만 스타일 제거 (모바일에서는 CSS가 처리하므로 제거하지 않음)
            if (!isMobile) {
              const equipmentContainer = document.getElementById('equipment-container');
              const accessoriesContainer = document.getElementById('accessories-container');
              if (equipmentContainer) {
                equipmentContainer.style.removeProperty('max-height');
                equipmentContainer.style.removeProperty('overflow-y');
                equipmentContainer.style.removeProperty('overflow-x');
                equipmentContainer.style.removeProperty('padding-right');
              }
              if (accessoriesContainer) {
                accessoriesContainer.style.removeProperty('max-height');
                accessoriesContainer.style.removeProperty('overflow-y');
                accessoriesContainer.style.removeProperty('overflow-x');
                accessoriesContainer.style.removeProperty('padding-right');
              }
            }
          }
        }
      }, 100);
    };
    window.addEventListener('resize', handleResize);
    window.equipmentResizeHandlerAdded = true;
  }
  
  // 기존 내용 초기화
  equipmentContainer.innerHTML = '';
  accessoriesContainer.innerHTML = '';
  arcanaContainer.innerHTML = '';
  
  // 아르카나 세트 효과 컨테이너 제거 (기존 세트 효과 지우기)
  if (arcanaInfo) {
    const existingSetEffects = arcanaInfo.querySelector('.arcana-set-effects-container');
    if (existingSetEffects) {
      existingSetEffects.remove();
    }
  }
  
  // 아르카나 아이템 필터링
  const arcanaItems = [];
  const regularEquipment = [];
  const regularAccessories = [];
  
  // 장비에서 아르카나 아이템 분리
  if (equipment && equipment.length > 0) {
    equipment.forEach(item => {
      if (isArcanaItem(item)) {
        arcanaItems.push(item);
      } else {
        regularEquipment.push(item);
      }
    });
  }
  
  // 악세사리에서 아르카나 아이템 분리
  if (accessories && accessories.length > 0) {
    accessories.forEach(item => {
      if (isArcanaItem(item)) {
        arcanaItems.push(item);
      } else {
        regularAccessories.push(item);
      }
    });
  }
  
  // 장비가 하나도 없으면 섹션 숨김
  if (regularEquipment.length === 0 && regularAccessories.length === 0 && arcanaItems.length === 0) {
    equipmentInfo.style.display = 'none';
    arcanaInfo.style.display = 'none';
    return;
  }
  
  // 장비 정보 표시
  if (regularEquipment.length > 0 || regularAccessories.length > 0) {
    equipmentInfo.style.display = 'block';
  } else {
    equipmentInfo.style.display = 'none';
  }
  
  // 장비 표시
  if (regularEquipment.length > 0) {
    // 첫 번째 장비가 메인 무기 (크로메데 확인용)
    const firstEquipment = regularEquipment[0];
    if (firstEquipment && firstEquipment.name && firstEquipment.name.includes('크로메데')) {
      firstEquipment.isKromedeMainWeapon = true;
    }
    
    regularEquipment.forEach(item => {
      const equipmentItem = createEquipmentItem(item);
      if (equipmentItem) {
        equipmentContainer.appendChild(equipmentItem);
      }
    });
  } else {
    equipmentContainer.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 1rem;">장비 정보가 없습니다.</div>';
  }
  
  // 악세사리 표시
  if (regularAccessories.length > 0) {
    regularAccessories.forEach(item => {
      const accessoryItem = createEquipmentItem(item);
      if (accessoryItem) {
        accessoriesContainer.appendChild(accessoryItem);
      }
    });
  } else {
    accessoriesContainer.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 1rem;">악세사리 정보가 없습니다.</div>';
  }
  
  // 아르카나 표시
  if (arcanaItems.length > 0) {
    arcanaInfo.style.display = 'block';
    arcanaItems.forEach(item => {
      const arcanaItem = createArcanaItem(item);
      if (arcanaItem) {
        arcanaContainer.appendChild(arcanaItem);
      }
    });
    
    // 세트 효과 계산 및 표시
    let magicCount = 0; // 마력 세트 개수
    let vitalityCount = 0; // 활력 세트 개수
    
    arcanaItems.forEach(item => {
      const name = item.name || '';
      if (name.includes('마력')) {
        magicCount++;
      } else if (name.includes('활력')) {
        vitalityCount++;
      }
    });
    
    // 활성화된 세트 효과 확인
    const activeSetEffects = [];
    
    // 마력 세트 효과
    if (magicCount >= 2) {
      activeSetEffects.push({
        setCount: 2,
        setName: '마력',
        effect: '정신력이 20% 이하로 감소할 경우, 1500의 정신력을 즉시 회복 [재사용 시간 30초]'
      });
    }
    if (magicCount >= 4) {
      activeSetEffects.push({
        setCount: 4,
        setName: '마력',
        effect: '정신력이 50%이상일 때, PVE 방어력 1000 증가'
      });
    }
    
    // 활력 세트 효과
    if (vitalityCount >= 2) {
      activeSetEffects.push({
        setCount: 2,
        setName: '활력',
        effect: '생명력이 70%이상일 때, PVE 공격력 60만큼 증가'
      });
    }
    if (vitalityCount >= 4) {
      activeSetEffects.push({
        setCount: 4,
        setName: '활력',
        effect: '생명력이 70%이상일 때, PVE 공격력 150만큼 증가'
      });
    }
    
    // 세트 효과 표시 (아이템 아이콘 아래)
    if (activeSetEffects.length > 0) {
      const setEffectsContainer = document.createElement('div');
      setEffectsContainer.className = 'arcana-set-effects-container';
      setEffectsContainer.style.cssText = 'margin-top: 1rem; width: fit-content; max-width: 100%;';
      
      activeSetEffects.forEach(setEffect => {
        const effectDiv = document.createElement('div');
        effectDiv.style.cssText = 'margin-bottom: 0.5rem;';
        
        const effectTitle = document.createElement('div');
        effectTitle.style.cssText = 'font-size: 0.85rem; font-weight: 600; color: #4caf50; margin-bottom: 0.15rem;'; // 전체 제목 초록색
        
        effectTitle.textContent = `${setEffect.setCount} 세트 효과 [${setEffect.setName}]`;
        
        const effectDesc = document.createElement('div');
        effectDesc.style.cssText = 'font-size: 0.75rem; color: var(--text-primary); line-height: 1.5;';
        effectDesc.textContent = setEffect.effect;
        
        effectDiv.appendChild(effectTitle);
        effectDiv.appendChild(effectDesc);
        setEffectsContainer.appendChild(effectDiv);
      });
      
      // arcanaInfo에 추가 (아이템 아이콘 아래)
      arcanaInfo.appendChild(setEffectsContainer);
    }
  } else {
    arcanaInfo.style.display = 'none';
  }
  
  // 무기, 방어구, 장신구 이름 리스트 추출
  const weaponNames = [];
  const armorNames = [];
  const accessoryNames = [];
  
  // 무기: 가더 포함, 첫 번째 장비 (가장 위에 있는 장비)
  if (regularEquipment.length > 0) {
    // 첫 번째 장비는 무기
    const firstEquipment = regularEquipment[0];
    if (firstEquipment && firstEquipment.name) {
      // 강화 수치 제거 (예: "+15 빛나는 백룡왕의 대검" -> "빛나는 백룡왕의 대검")
      const weaponName = firstEquipment.name.replace(/^\+\d+\s*/, '').trim();
      weaponNames.push(weaponName);
    }
    
    // 가더 찾기
    regularEquipment.forEach(item => {
      if (item && item.name && item.name.includes('가더')) {
        const guarderName = item.name.replace(/^\+\d+\s*/, '').trim();
        if (!weaponNames.includes(guarderName)) {
          weaponNames.push(guarderName);
        }
      }
    });
  }
  
  // 방어구: 흉갑, 각반, 투구, 견갑, 장갑, 장화, 망토로 끝나는 것들 (허리띠 제외)
  const armorEndings = ['흉갑', '각반', '투구', '견갑', '장갑', '장화', '망토'];
  regularEquipment.forEach(item => {
    if (item && item.name) {
      const itemName = item.name.replace(/^\+\d+\s*/, '').trim();
      const isArmor = armorEndings.some(ending => itemName.endsWith(ending));
      if (isArmor) {
        armorNames.push(itemName);
      }
    }
  });
  
  // 장신구: 목걸이, 귀걸이, 반지로 끝나는 것들
  const accessoryEndings = ['목걸이', '귀걸이', '반지'];
  regularAccessories.forEach(item => {
    if (item && item.name) {
      const itemName = item.name.replace(/^\+\d+\s*/, '').trim();
      const isAccessory = accessoryEndings.some(ending => itemName.endsWith(ending));
      if (isAccessory) {
        accessoryNames.push(itemName);
      }
    }
  });
  
  // 아르카나 세트 옵션 문자열 생성
  let arcanaSetOption = '';
  if (arcanaItems.length > 0) {
    let magicCount = 0;
    let vitalityCount = 0;
    
    arcanaItems.forEach(item => {
      const name = item.name || '';
      if (name.includes('마력')) {
        magicCount++;
      } else if (name.includes('활력')) {
        vitalityCount++;
      }
    });
    
    const setParts = [];
    if (magicCount >= 4) {
      setParts.push('4마력');
    } else if (magicCount >= 2) {
      setParts.push('2마력');
    }
    if (vitalityCount >= 4) {
      setParts.push('4활력');
    } else if (vitalityCount >= 2) {
      setParts.push('2활력');
    }
    
    arcanaSetOption = setParts.join('');
  }
  
  // 영혼 각인 세팅 점수 계산 및 표시 (UI 표시 제거, 계산만 수행)
  // calculateAndDisplaySoulInscriptionScore(regularEquipment, regularAccessories);
  
  // 점수 계산만 수행 (DB 저장용, UI 표시 없음)
  const allItems = [...(regularEquipment || []), ...(regularAccessories || [])];
  let totalScore = 0;
  allItems.forEach((item) => {
    const scoreData = calculateEquipmentSoulScore(item);
    totalScore += scoreData.totalScore;
  });
  window.currentSoulScore = totalScore;
  
  return {
    weaponNames,
    armorNames,
    accessoryNames,
    arcanaSetOption
  };
}

// 타이틀 정보 표시 함수
function displayTitles(titles, titleSummary) {
  const titleInfo = document.getElementById('title-info');
  const titleContainer = document.getElementById('title-container');
  const titleSummaryEl = document.getElementById('title-summary');
  
  if (!titleInfo || !titleContainer) {
    return 0;
  }
  
  // 기존 내용 초기화
  titleContainer.innerHTML = '';
  
  // 타이틀 개수 저장
  let titleCount = 0;
  
  // 타이틀이 없으면 섹션 숨김
  if (!titles || titles.length === 0) {
    titleInfo.style.display = 'none';
    return 0;
  }
  
  // 타이틀 정보 표시
  titleInfo.style.display = 'block';
  
  // 타이틀 요약 정보 표시
  if (titleSummary && titleSummaryEl) {
    const ownedCount = titleSummary.owned_count || 0;
    const totalCount = titleSummary.total_count || 0;
    titleCount = ownedCount; // 소유한 타이틀 개수
    if (totalCount > 0) {
      titleSummaryEl.textContent = `${ownedCount}/${totalCount}`;
      // 랭킹 정보는 loadCharacterRankingInfo에서 추가됨
    } else {
      titleSummaryEl.textContent = '';
    }
  } else {
    // titleSummary가 없으면 titles 배열 길이 사용
    titleCount = titles.length;
  }
  
  // 카테고리 순서 정의: Attack -> Defense -> Etc
  const categoryOrder = ['Attack', 'Defense', 'Etc'];
  const getCategoryOrder = (category) => {
    const index = categoryOrder.indexOf(category);
    return index >= 0 ? index : 999; // 없는 카테고리는 뒤로
  };
  
  // 타이틀을 카테고리 순서로 정렬
  const sortedTitles = [...titles].sort((a, b) => {
    const categoryA = a.category || '';
    const categoryB = b.category || '';
    const orderA = getCategoryOrder(categoryA);
    const orderB = getCategoryOrder(categoryB);
    return orderA - orderB;
  });
  
  // 각 타이틀을 개별 카드로 표시 (아르카나처럼)
  sortedTitles.forEach((title, index) => {
    if (!title || !title.name) {
      return;
    }
    
    // 타이틀 카드 생성 (아르카나 아이템처럼)
    const titleCard = document.createElement('div');
    titleCard.style.cssText = 'padding: 1rem; background: rgba(4, 7, 25, 0.35); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.4); min-width: 280px; flex: 1 1 300px; display: flex; flex-direction: column;';
    
    // 타이틀 헤더 (이름, 카테고리, 진행도)
    const titleHeader = document.createElement('div');
    titleHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.75rem;';
    
    // 타이틀 이름과 카테고리
    const titleNameSection = document.createElement('div');
    titleNameSection.style.cssText = 'flex: 1;';
    
    // 타이틀 이름 (등급별 색상 적용)
    const titleNameDiv = document.createElement('div');
    titleNameDiv.style.cssText = 'font-size: 1rem; font-weight: 600; margin-bottom: 0.25rem;';
    const gradeColor = getGradeColor(title.grade);
    if (gradeColor) {
      titleNameDiv.style.color = gradeColor;
    } else {
      titleNameDiv.style.color = 'var(--text-primary)';
    }
    titleNameDiv.textContent = title.name;
    titleNameSection.appendChild(titleNameDiv);
    
    // 카테고리
    if (title.category) {
      const categoryDiv = document.createElement('div');
      categoryDiv.style.cssText = 'font-size: 0.75rem; color: var(--text-muted);';
      categoryDiv.textContent = title.category;
      titleNameSection.appendChild(categoryDiv);
    }
    
    // 진행도 (우측 상단)
    const progressDiv = document.createElement('div');
    progressDiv.style.cssText = 'font-size: 0.85rem; color: var(--text-muted); margin-left: 0.5rem; white-space: nowrap;';
    if (title.total_count !== undefined && title.owned_count !== undefined) {
      progressDiv.textContent = `${title.owned_count}/${title.total_count}`;
    }
    
    titleHeader.appendChild(titleNameSection);
    titleHeader.appendChild(progressDiv);
    titleCard.appendChild(titleHeader);
    
    // 장착 효과
    if (title.equip_effects && title.equip_effects.length > 0) {
      const equipLabel = document.createElement('div');
      equipLabel.style.cssText = 'font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;';
      equipLabel.textContent = '장착 효과:';
      titleCard.appendChild(equipLabel);
      
      title.equip_effects.forEach(effect => {
        const equipEffectDiv = document.createElement('div');
        equipEffectDiv.style.cssText = 'font-size: 0.8rem; color: var(--text-primary); margin-bottom: 0.25rem; padding-left: 0.5rem;';
        equipEffectDiv.textContent = effect;
        titleCard.appendChild(equipEffectDiv);
      });
    }
    
    titleContainer.appendChild(titleCard);
  });
  
  return titleCount;
}

// 타이틀 아이템 생성 헬퍼 함수
function createTitleItem(title) {
  const titleItem = document.createElement('div');
  titleItem.className = 'title-item-extra';
  titleItem.style.cssText = 'padding: 1rem; background: rgba(0, 0, 0, 0.2); border-radius: 8px; margin-bottom: 0.75rem; position: relative; width: 100%; max-width: 100%; box-sizing: border-box; overflow: hidden;';
  
  // 타이틀 헤더 (이름과 진행도)
  const titleHeader = document.createElement('div');
  titleHeader.style.cssText = 'display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem; width: 100%; max-width: 100%; box-sizing: border-box;';
  
  // 타이틀 이름과 카테고리
  const titleNameSection = document.createElement('div');
  titleNameSection.style.cssText = 'flex: 1; min-width: 0; overflow: hidden;';
  
  // 타이틀 이름 (등급별 색상 적용)
  const titleNameDiv = document.createElement('div');
  titleNameDiv.style.cssText = 'font-size: 0.95rem; font-weight: 600; margin-bottom: 0.25rem; word-wrap: break-word; overflow-wrap: break-word; max-width: 100%;';
  const gradeColor = getGradeColor(title.grade);
  if (gradeColor) {
    titleNameDiv.style.color = gradeColor;
  } else {
    titleNameDiv.style.color = 'var(--text-primary)';
  }
  titleNameDiv.textContent = title.name;
  titleNameSection.appendChild(titleNameDiv);
  
  // 카테고리
  if (title.category) {
    const categoryDiv = document.createElement('div');
    categoryDiv.style.cssText = 'font-size: 0.75rem; color: var(--text-muted);';
    categoryDiv.textContent = title.category;
    titleNameSection.appendChild(categoryDiv);
  }
  
  // 진행도 (우측 상단)
  const progressDiv = document.createElement('div');
  progressDiv.style.cssText = 'font-size: 0.85rem; color: var(--text-muted); margin-left: 0.5rem; flex-shrink: 0; white-space: nowrap;';
  if (title.total_count !== undefined && title.owned_count !== undefined) {
    progressDiv.textContent = `${title.owned_count}/${title.total_count}`;
  }
  
  titleHeader.appendChild(titleNameSection);
  titleHeader.appendChild(progressDiv);
  titleItem.appendChild(titleHeader);
  
  // 장착 효과
  if (title.equip_effects && title.equip_effects.length > 0) {
    const equipLabel = document.createElement('div');
    equipLabel.style.cssText = 'font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem; font-weight: 500;';
    equipLabel.textContent = '장착 효과:';
    titleItem.appendChild(equipLabel);
    
    title.equip_effects.forEach(effect => {
      const equipEffectDiv = document.createElement('div');
      equipEffectDiv.style.cssText = 'font-size: 0.8rem; color: var(--text-primary); margin-bottom: 0.25rem; padding-left: 0.5rem;';
      equipEffectDiv.textContent = effect;
      titleItem.appendChild(equipEffectDiv);
    });
  }
  
  return titleItem;
}

// 장비 아이템 생성 함수
function createEquipmentItem(item) {
  if (!item || !item.name) {
    return null;
  }
  
  const itemDiv = document.createElement('div');
  itemDiv.className = 'equipment-item';
  const isMobile = window.innerWidth <= 768;
  const itemMarginBottom = isMobile ? '1rem' : '0.5rem';
  itemDiv.style.cssText = `display: flex !important; flex-direction: column !important; align-items: flex-start !important; gap: 0.5rem !important; padding: 0.75rem !important; margin-bottom: ${itemMarginBottom} !important; border-radius: 6px !important; background: rgba(4, 7, 25, 0.3) !important; border: 1px solid rgba(255, 255, 255, 0.08) !important; transition: background 0.2s ease, border-color 0.2s ease !important; width: 100% !important; max-width: 100% !important; box-sizing: border-box !important; position: relative !important; clear: both !important; overflow: visible !important;`;
  
  // 아이콘과 이름을 감싸는 컨테이너
  const contentDiv = document.createElement('div');
  contentDiv.className = 'equipment-item-content';
  
  // 아이콘과 이름을 감싸는 컨테이너를 가로 배치 (이름과 아이콘을 나란히)
  contentDiv.style.cssText = 'display: flex; flex-direction: row; align-items: flex-start; gap: 0.75rem; width: 100%;';
  
  // 초월 레벨과 이름을 감싸는 컨테이너 (위에 표시)
  const nameContainer = document.createElement('div');
  nameContainer.style.cssText = 'display: flex; flex-direction: column; gap: 0.3rem; width: 100%;';
  
  // 이름과 초월 레벨을 감싸는 컨테이너
  const nameRow = document.createElement('div');
  nameRow.style.cssText = 'display: flex; align-items: center; gap: 0.4rem; flex-wrap: wrap;';
  
  // 초월 레벨 (exceedLevel) - 이름 앞에 표시 (1.5배 크기)
  const exceedLevel = item.exceed_level || 0;
  
  // 초월 레벨이 0보다 크면 마름모 배지로 표시
  if (exceedLevel > 0) {
    const exceedBadge = document.createElement('span');
    exceedBadge.className = 'exceed-level-badge';
    exceedBadge.style.cssText = `
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      aspect-ratio: 1;
      background: #87ceeb !important;
      background-image: linear-gradient(135deg, #87ceeb 0%, #5ba3f5 100%) !important;
      border: 1px solid rgba(255, 255, 255, 0.4);
      transform: rotate(45deg);
      font-size: 0.975rem;
      font-weight: 700;
      color: #ffffff;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      line-height: 1;
      cursor: help;
      position: relative;
    `;
    // 내부 텍스트는 반대로 회전시켜서 읽을 수 있게 함
    const badgeText = document.createElement('span');
    badgeText.style.cssText = `
      display: inline-block;
      transform: rotate(-45deg);
      line-height: 1;
    `;
    badgeText.textContent = exceedLevel;
    exceedBadge.appendChild(badgeText);
    exceedBadge.title = `초월 +${exceedLevel}`;
    nameRow.appendChild(exceedBadge);
  }
  
  // 아이템 이름 (1.5배 크기)
  const nameDiv = document.createElement('div');
  nameDiv.className = 'equipment-item-name';
  nameDiv.style.cssText = 'font-size: 1.125rem; font-weight: 600;';
  
  // 강화 수치와 이름
  const enhanceLevel = item.enhance_level || 0;
  
  // 강화 수치가 0보다 크면 표시
  if (enhanceLevel > 0) {
    nameDiv.textContent = `+${enhanceLevel} ${item.name}`;
  } else {
    nameDiv.textContent = item.name;
  }
  
  // 등급에 따른 색상 적용 (마석 각인과 동일한 방식)
  const grade = item.grade || '';
  
  if (grade) {
    const gradeColor = getGradeColor(grade);
    if (gradeColor) {
      nameDiv.style.color = gradeColor;
    }
  }
  
  nameRow.appendChild(nameDiv);
  nameContainer.appendChild(nameRow);
  
  // 아이템 레벨을 아이템 이름 바로 아래, 영혼 각인율 위에 표시
  if (item.level !== undefined && item.level !== null) {
    const levelInt = parseInt(item.level, 10);
    if (!isNaN(levelInt) && levelInt > 0) {
      const levelDiv = document.createElement('div');
      levelDiv.style.cssText = 'font-size: 0.85rem; font-weight: 500;';

      // 기본 텍스트 (아이템 레벨 +X)
      const baseSpan = document.createElement('span');
      baseSpan.textContent = `아이템 레벨 +${levelInt}`;
      levelDiv.appendChild(baseSpan);

      // level_value가 있으면 파란색으로 (+Y) 추가
      if (item.level_value !== undefined && item.level_value !== null) {
        const levelBonusInt = parseInt(item.level_value, 10);
        if (!isNaN(levelBonusInt) && levelBonusInt > 0) {
          const bonusSpan = document.createElement('span');
          bonusSpan.style.cssText = 'color: #60a5fa; margin-left: 4px;'; // 파란색
          bonusSpan.textContent = `(+${levelBonusInt})`;
          levelDiv.appendChild(bonusSpan);
        }
      }

      nameContainer.appendChild(levelDiv);
    }
  }
  
  // 영혼 각인율을 아이템 레벨 아래에 표시
  if (item.soul_bind_rate) {
    const soulBindRateDiv = document.createElement('div');
    soulBindRateDiv.style.cssText = 'font-size: 0.85rem; color: #87CEEB; font-weight: 500;'; // 하늘색
    const rateValue = parseFloat(item.soul_bind_rate) || 0;
    soulBindRateDiv.textContent = `영혼 각인율 ${rateValue}%`;
    nameContainer.appendChild(soulBindRateDiv);
  }
  
  // 아이콘 (2배 크기: 32px -> 64px) - 이름 아래에 표시
  const iconDiv = document.createElement('div');
  iconDiv.className = 'equipment-item-icon';
  // isMobile은 위에서 이미 선언됨
  const iconSize = isMobile ? '48px' : '64px';
  iconDiv.style.cssText = `width: ${iconSize}; height: ${iconSize}; flex-shrink: 0;`;
  
  if (item.icon_url) {
    const img = document.createElement('img');
    img.src = item.icon_url;
    img.alt = item.name;
    img.style.cssText = 'width: 100%; height: 100%; object-fit: contain;';
    img.onerror = function() {
      this.style.display = 'none';
    };
    iconDiv.appendChild(img);
  }
  
  // 아이콘을 먼저 추가 (왼쪽)
  contentDiv.appendChild(iconDiv);
  // 이름을 나중에 추가 (오른쪽)
  contentDiv.appendChild(nameContainer);
  itemDiv.appendChild(contentDiv);
  
  // 스탯 정보 표시 영역 (3개 카드 형태로 구분 - 모바일은 세로, 데스크톱은 가로 배치)
  const statsDiv = document.createElement('div');
  statsDiv.className = 'equipment-item-stats';
  const statsGap = isMobile ? '0.5rem' : '0.5rem';
  const statsMarginTop = isMobile ? '0.5rem' : '0.75rem';
  // 모바일에서는 CSS가 강제하지만, 인라인 스타일도 설정
  const statsDirection = isMobile ? 'column' : 'row';
  statsDiv.style.cssText = `display: flex !important; flex-direction: ${statsDirection} !important; gap: ${statsGap} !important; margin-top: ${statsMarginTop} !important; width: 100% !important; max-width: 100% !important; box-sizing: border-box !important; position: relative; z-index: 1; overflow: visible !important;`;
  
  // 1번 카드: 기본 옵션
  const card1 = document.createElement('div');
  const cardPadding = isMobile ? '0.5rem' : '0.75rem';
  const cardFlex = isMobile ? 'none' : '0 0 auto';
  const cardWidth = isMobile ? '100%' : '31%';
  const cardMinWidth = isMobile ? '0' : '0';
  card1.style.cssText = `flex: ${cardFlex} !important; flex-shrink: 0 !important; width: ${cardWidth} !important; max-width: ${cardWidth} !important; min-width: ${cardMinWidth} !important; padding: ${cardPadding} !important; background: rgba(4, 7, 25, 0.4) !important; border-radius: 8px !important; border: 1px solid rgba(255, 255, 255, 0.1) !important; box-sizing: border-box !important; overflow: visible !important;`;
  
  const column1 = document.createElement('div');
  const columnGap = isMobile ? '0.25rem' : '0.4rem';
  column1.style.cssText = `display: flex; flex-direction: column; gap: ${columnGap};`;
  
  // 기본 옵션 (mainStats)
  const mainStatsHeader = document.createElement('div');
  const headerFontSize = isMobile ? '0.7rem' : '0.8rem';
  const headerMarginBottom = isMobile ? '0.35rem' : '0.5rem';
  mainStatsHeader.style.cssText = `font-size: ${headerFontSize}; color: var(--accent); font-weight: 600; margin-bottom: ${headerMarginBottom};`;
  mainStatsHeader.textContent = '기본 옵션';
  column1.appendChild(mainStatsHeader);
  
  if (item.main_stats && Array.isArray(item.main_stats) && item.main_stats.length > 0) {
    item.main_stats.forEach(stat => {
      if (!stat || typeof stat !== 'object') return;
      
      const statLine = document.createElement('div');
      statLine.className = 'equipment-stat-line';
      const statFontSize = isMobile ? '0.65rem' : '0.75rem';
      
      if (isMobile) {
        // 모바일: 세로 배치 (1column)
        statLine.style.cssText = `font-size: ${statFontSize}; display: flex; flex-direction: column; align-items: flex-start; gap: 0.15rem; margin-bottom: 0.4rem;`;
        
        const name = stat.name || stat.id || '';
        const value = stat.value || '';
        const minValue = stat.minValue || '';
        const extra = stat.extra || '0';
        
        const label = document.createElement('div');
        label.className = 'equipment-stat-label';
        label.textContent = name;
        label.style.cssText = 'font-weight: 500; color: var(--text-muted);';
        
        const valueSpan = document.createElement('div');
        valueSpan.className = 'equipment-stat-value';
        let valueText = value;
        
        // 공격력인 경우 최소~최대 표시
        if ((name.includes('공격력') || name.toLowerCase().includes('attack')) && minValue) {
          valueText = `${minValue} ~ ${value}`;
        }
        
        // extra가 있고 0이 아니면 (+extra) 형식으로 추가
        if (extra && extra !== '0' && extra !== 0 && extra !== '0%') {
          valueText += ` (+${extra})`;
        }
        valueSpan.textContent = valueText;
        valueSpan.style.cssText = 'font-weight: 600; color: var(--text-primary);';
        
        statLine.appendChild(label);
        statLine.appendChild(valueSpan);
      } else {
        // 데스크톱: 가로 배치 (기존 방식)
        const statGap = '0.5rem';
        statLine.style.cssText = `font-size: ${statFontSize}; display: flex; align-items: center; gap: ${statGap};`;
        
        const name = stat.name || stat.id || '';
        const value = stat.value || '';
        const minValue = stat.minValue || '';
        const extra = stat.extra || '0';
        
        const label = document.createElement('span');
        label.className = 'equipment-stat-label';
        label.textContent = name;
        
        const valueSpan = document.createElement('span');
        valueSpan.className = 'equipment-stat-value';
        let valueText = value;
        
        // 공격력인 경우 최소~최대 표시
        if ((name.includes('공격력') || name.toLowerCase().includes('attack')) && minValue) {
          valueText = `${minValue} ~ ${value}`;
        }
        
        // extra가 있고 0이 아니면 +extra 형식으로 추가
        if (extra && extra !== '0' && extra !== 0 && extra !== '0%') {
          valueText += ` (+${extra})`;
        }
        valueSpan.textContent = valueText;
        
        statLine.appendChild(label);
        statLine.appendChild(valueSpan);
      }
      
      column1.appendChild(statLine);
    });
  }
  
  // 초월 옵션 추가 (기본 옵션 아래에)
  const itemExceedLevel = item.exceed_level || 0;
  
  if (itemExceedLevel > 0) {
    // slot_pos 또는 raw_data.slotPos 사용
    const slotPos = item.slot_pos !== null && item.slot_pos !== undefined ? item.slot_pos : 
                    (item.raw_data && item.raw_data.slotPos !== null && item.raw_data.slotPos !== undefined ? item.raw_data.slotPos : -1);
    
    // 카테고리 이름으로 악세사리 확인
    const categoryName = item.category_name || '';
    const isAccessory = item.is_accessory || false || 
                       categoryName.includes('목걸이') || 
                       categoryName.includes('귀걸이') || 
                       categoryName.includes('반지') || 
                       categoryName.includes('허리띠');
    
    let transcendStats = [];
    
    // 장비 타입에 따라 초월 옵션 결정
    // 무기/가드: slotPos 0, 1, 2
    if (slotPos >= 0 && slotPos <= 2) {
      // 무기/가드: 초월 1당 공격력 +30, 공격력 +1% (2줄)
      const attackPower = itemExceedLevel * 30;
      const attackPercent = itemExceedLevel * 1;
      transcendStats = [
        { label: '공격력', value: `+${attackPower}` },
        { label: '공격력', value: `+${attackPercent}%` }
      ];
    }
    // 악세사리: 카테고리 이름으로 판정
    else if (isAccessory) {
      // 악세: 초월 1당 공격력 +20, 방어력 +20, 공격력 +1% (3줄)
      const attackPower = itemExceedLevel * 20;
      const defense = itemExceedLevel * 20;
      const attackPercent = itemExceedLevel * 1;
      transcendStats = [
        { label: '공격력', value: `+${attackPower}` },
        { label: '방어력', value: `+${defense}` },
        { label: '공격력', value: `+${attackPercent}%` }
      ];
    }
    // 방어구: 무기/가드 제외한 나머지 모두 (장화, 망토, 흉갑 등)
    else {
      // 방어구: 초월 1당 방어력 +40, 생명력 +40, 방어력 +1% (3줄)
      const defense = itemExceedLevel * 40;
      const hp = itemExceedLevel * 40;
      const defensePercent = itemExceedLevel * 1;
      transcendStats = [
        { label: '방어력', value: `+${defense}` },
        { label: '생명력', value: `+${hp}` },
        { label: '방어력', value: `+${defensePercent}%` }
      ];
    }
    
    // 초월 옵션 표시
    if (transcendStats.length > 0) {
      transcendStats.forEach((stat) => {
        const statLine = document.createElement('div');
        statLine.className = 'equipment-stat-line';
        const statFontSize = isMobile ? '0.65rem' : '0.75rem';
        
        if (isMobile) {
          // 모바일: 가로 배치 (한 줄에)
          const statGap = '0.5rem';
          statLine.style.cssText = `font-size: ${statFontSize}; display: flex; align-items: center; gap: ${statGap};`;
        } else {
          // 데스크톱: 가로 배치
          const statGap = '0.5rem';
          statLine.style.cssText = `font-size: ${statFontSize}; display: flex; align-items: center; gap: ${statGap};`;
        }
        
        const label = document.createElement('span');
        label.className = 'equipment-stat-label';
        label.textContent = stat.label || '';
        label.style.cssText = 'font-weight: 500; color: #87ceeb;'; // 하늘색
        
        const value = document.createElement('span');
        value.className = 'equipment-stat-value';
        value.textContent = stat.value || '';
        value.style.cssText = 'font-weight: 600; color: #87ceeb;'; // 하늘색
        
        statLine.appendChild(label);
        statLine.appendChild(value);
        
        column1.appendChild(statLine);
      });
    }
  }
  
  card1.appendChild(column1);
  
  // 2번 카드: 추가 옵션 (subStats) - 내용이 있을 때만 생성
  let hasSubStats = false;
  let hasSubSkills = false;
  
  // subStats 확인
  if (item.sub_stats) {
    const subStats = extractStats(item.sub_stats);
    hasSubStats = subStats && subStats.length > 0;
  }
  
  // sub_skills 확인
  if (item.sub_skills && Array.isArray(item.sub_skills) && item.sub_skills.length > 0) {
    hasSubSkills = true;
  }
  
  let card2 = null;
  let column2 = null;
  
  // 영혼 각인 또는 부스킬이 있을 때만 카드 생성
  if (hasSubStats || hasSubSkills) {
    card2 = document.createElement('div');
    card2.style.cssText = `flex: ${cardFlex} !important; flex-shrink: 0 !important; width: ${cardWidth} !important; max-width: ${cardWidth} !important; min-width: ${cardMinWidth} !important; padding: ${cardPadding} !important; background: rgba(4, 7, 25, 0.4) !important; border-radius: 8px !important; border: 1px solid rgba(255, 255, 255, 0.1) !important; box-sizing: border-box !important; overflow: visible !important;`;
    
    column2 = document.createElement('div');
    column2.style.cssText = `display: flex; flex-direction: column; gap: ${columnGap}; min-height: 0;`;
    
    const subStatsHeader = document.createElement('div');
    subStatsHeader.style.cssText = `font-size: ${headerFontSize}; color: var(--accent); font-weight: 600; margin-bottom: ${headerMarginBottom};`;
    subStatsHeader.textContent = hasSubSkills ? '영혼 각인/부스킬' : '영혼 각인';
    column2.appendChild(subStatsHeader);
    
    // 크로메데 메인 무기인 경우 "늘어남" 옵션을 맨 위에 추가
    if (item.isKromedeMainWeapon) {
      const neureomLine = document.createElement('div');
      neureomLine.className = 'equipment-stat-line';
      const statFontSize = isMobile ? '0.65rem' : '0.75rem';
      const tierBadge = createTierBadge('S');
      
      if (isMobile) {
        neureomLine.style.cssText = `font-size: ${statFontSize}; display: flex; flex-direction: column; align-items: flex-start; gap: 0.15rem; margin-bottom: 0.4rem;`;
        
        const labelContainer = document.createElement('div');
        labelContainer.style.cssText = 'display: flex; align-items: center; gap: 0.3rem;';
        
        const label = document.createElement('div');
        label.className = 'equipment-stat-label';
        label.textContent = '늘어남';
        label.style.cssText = 'font-weight: 500; color: var(--text-muted);';
        
        labelContainer.appendChild(tierBadge);
        labelContainer.appendChild(label);
        
        const value = document.createElement('div');
        value.className = 'equipment-stat-value';
        value.textContent = '';
        value.style.cssText = 'font-weight: 600; color: var(--text-primary);';
        
        neureomLine.appendChild(labelContainer);
        neureomLine.appendChild(value);
      } else {
        const statGap = '0.5rem';
        neureomLine.style.cssText = `font-size: ${statFontSize}; display: flex; align-items: center; gap: ${statGap}; width: 100%;`;
        
        neureomLine.appendChild(tierBadge);
        
        const label = document.createElement('span');
        label.className = 'equipment-stat-label';
        label.textContent = '늘어남';
        label.style.cssText = 'flex: 1; min-width: 0;';
        
        const value = document.createElement('span');
        value.className = 'equipment-stat-value';
        value.textContent = '';
        value.style.cssText = 'flex-shrink: 0; text-align: right; white-space: nowrap;';
        
        neureomLine.appendChild(label);
        neureomLine.appendChild(value);
      }
      
      column2.appendChild(neureomLine);
    }
    
    // subStats 정보 추출 및 표시
    if (hasSubStats) {
      const subStats = extractStats(item.sub_stats);
      
      if (subStats && subStats.length > 0) {
      // 티어별 정렬: S -> A -> B 순으로
      const tierOrder = { 'S': 0, 'A': 1, 'B': 2, 'C': 3 };
      const sortedSubStats = [...subStats].sort((a, b) => {
        const tierA = getSoulInscriptionTier(a.label || '');
        const tierB = getSoulInscriptionTier(b.label || '');
        const orderA = tierOrder[tierA] !== undefined ? tierOrder[tierA] : 3;
        const orderB = tierOrder[tierB] !== undefined ? tierOrder[tierB] : 3;
        return orderA - orderB;
      });
      
      sortedSubStats.forEach((stat, idx) => {
        const statLine = document.createElement('div');
        statLine.className = 'equipment-stat-line';
        const statFontSize = isMobile ? '0.65rem' : '0.75rem';
        
        // 티어 판단 및 뱃지 생성
        const optionName = stat.label || '';
        const tier = getSoulInscriptionTier(optionName);
        const tierBadge = createTierBadge(tier);
        
        if (isMobile) {
          // 모바일: 세로 배치 (1column)
          statLine.style.cssText = `font-size: ${statFontSize}; display: flex; flex-direction: column; align-items: flex-start; gap: 0.15rem; margin-bottom: 0.4rem;`;
          
          // 티어 뱃지와 라벨을 함께 표시하는 컨테이너
          const labelContainer = document.createElement('div');
          labelContainer.style.cssText = 'display: flex; align-items: center; gap: 0.3rem;';
          
          const label = document.createElement('div');
          label.className = 'equipment-stat-label';
          label.textContent = stat.label || '';
          label.style.cssText = 'font-weight: 500; color: var(--text-muted);';
          
          labelContainer.appendChild(tierBadge);
          labelContainer.appendChild(label);
          
          const value = document.createElement('div');
          value.className = 'equipment-stat-value';
          value.textContent = stat.value || '';
          value.style.cssText = 'font-weight: 600; color: var(--text-primary);';
          
          statLine.appendChild(labelContainer);
          statLine.appendChild(value);
        } else {
          // 데스크톱: 가로 배치 (기존 방식)
          const statGap = '0.5rem';
          statLine.style.cssText = `font-size: ${statFontSize}; display: flex; align-items: center; gap: ${statGap}; width: 100%;`;
          
          // 티어 뱃지 추가
          statLine.appendChild(tierBadge);
          
          const label = document.createElement('span');
          label.className = 'equipment-stat-label';
          label.textContent = stat.label || '';
          label.style.cssText = 'flex: 1; min-width: 0;';
          
          const value = document.createElement('span');
          value.className = 'equipment-stat-value';
          value.textContent = stat.value || '';
          value.style.cssText = 'flex-shrink: 0; text-align: right; white-space: nowrap;';
          
          statLine.appendChild(label);
          statLine.appendChild(value);
        }
        
        column2.appendChild(statLine);
      });
      }
    }
    
    // 부스킬(sub_skills) 정보가 있으면 표시 (아이콘 + 텍스트)
    if (hasSubSkills) {
      // 부스킬과 영혼 각인 사이 구분선
      if (item.sub_stats) {
        const divider = document.createElement('div');
        divider.style.cssText = 'margin: 0.35rem 0; border-top: 1px dashed rgba(255, 255, 255, 0.12);';
        column2.appendChild(divider);
      }

      item.sub_skills.forEach(subSkill => {
        if (!subSkill || typeof subSkill !== 'object') return;

        const line = document.createElement('div');
        const lineFontSize = isMobile ? '0.65rem' : '0.75rem';
        
        if (isMobile) {
          // 모바일: 세로 배치 (1column) - 아이콘과 텍스트를 세로로
          line.style.cssText = `display: flex; flex-direction: column; align-items: flex-start; gap: 0.15rem; margin-bottom: 0.4rem; font-size: ${lineFontSize};`;

          // 아이콘
          const iconUrl = subSkill.icon || subSkill.iconUrl || subSkill.image || subSkill.imageUrl;
          if (iconUrl) {
            const iconImg = document.createElement('img');
            iconImg.src = iconUrl;
            iconImg.alt = subSkill.name || '부스킬';
            const iconSize = '16px';
            iconImg.style.cssText = `width: ${iconSize}; height: ${iconSize}; object-fit: contain; flex-shrink: 0;`;
            iconImg.onerror = function() { this.style.display = 'none'; };
            line.appendChild(iconImg);
          }

          // 텍스트 (예: 육감 극대화 +1)
          const textDiv = document.createElement('div');
          const name = subSkill.name || subSkill.title || '';
          const level = subSkill.level || subSkill.level_int || subSkill.lv || '';
          let text = name || '';
          if (level !== '' && level !== null && level !== undefined) {
            const levelInt = parseInt(level, 10);
            if (!isNaN(levelInt) && levelInt > 0) {
              text = text ? `${text} +${levelInt}` : `+${levelInt}`;
            }
          }
          textDiv.textContent = text;
          textDiv.style.cssText = 'font-weight: 600; color: var(--text-primary);';
          line.appendChild(textDiv);
        } else {
          // 데스크톱: 가로 배치 (기존 방식)
          const lineGap = '0.4rem';
          line.style.cssText = `display: flex; align-items: center; gap: ${lineGap}; font-size: ${lineFontSize};`;

          // 아이콘
          const iconUrl = subSkill.icon || subSkill.iconUrl || subSkill.image || subSkill.imageUrl;
          if (iconUrl) {
            const iconImg = document.createElement('img');
            iconImg.src = iconUrl;
            iconImg.alt = subSkill.name || '부스킬';
            const iconSize = '16px';
            iconImg.style.cssText = `width: ${iconSize}; height: ${iconSize}; object-fit: contain; flex-shrink: 0;`;
            iconImg.onerror = function() { this.style.display = 'none'; };
            line.appendChild(iconImg);
          }

          // 텍스트 (예: 육감 극대화 +1)
          const textSpan = document.createElement('span');
          const name = subSkill.name || subSkill.title || '';
          const level = subSkill.level || subSkill.level_int || subSkill.lv || '';
          let text = name || '';
          if (level !== '' && level !== null && level !== undefined) {
            const levelInt = parseInt(level, 10);
            if (!isNaN(levelInt) && levelInt > 0) {
              text = text ? `${text} +${levelInt}` : `+${levelInt}`;
            }
          }
          textSpan.textContent = text;
          line.appendChild(textSpan);
        }

        column2.appendChild(line);
      });
    }
    
    // card2에 column2 추가 (내용이 있을 때만)
    if (card2 && column2) {
      card2.appendChild(column2);
    }
  }
  
  // 3번 카드: 마석 각인 (magicStoneStat) - 내용이 있을 때만 생성
  let card3 = null;
  let column3 = null;
  let hasMagicStoneStats = false;
  
  // magicStoneStat 확인
  if (item.magic_stone_stat) {
    const magicStoneStats = extractStats(item.magic_stone_stat);
    hasMagicStoneStats = magicStoneStats && magicStoneStats.length > 0;
    
    if (hasMagicStoneStats) {
      card3 = document.createElement('div');
      card3.style.cssText = `flex: ${cardFlex} !important; flex-shrink: 0 !important; width: ${cardWidth} !important; max-width: ${cardWidth} !important; min-width: ${cardMinWidth} !important; padding: ${cardPadding} !important; background: rgba(4, 7, 25, 0.4) !important; border-radius: 8px !important; border: 1px solid rgba(255, 255, 255, 0.1) !important; box-sizing: border-box !important; overflow: visible !important;`;
      
      column3 = document.createElement('div');
      column3.style.cssText = `display: flex; flex-direction: column; gap: ${columnGap}; min-height: 0;`;
      
      const stoneHeader = document.createElement('div');
      stoneHeader.style.cssText = `font-size: ${headerFontSize}; color: var(--accent); font-weight: 600; margin-bottom: ${headerMarginBottom};`;
      stoneHeader.textContent = '마석 각인';
      column3.appendChild(stoneHeader);
    }
  }
  
  // magicStoneStat 정보 추출 및 표시
  if (hasMagicStoneStats && column3) {
    const magicStoneStats = extractStats(item.magic_stone_stat);
    
    if (magicStoneStats && magicStoneStats.length > 0) {
      magicStoneStats.forEach((stat, idx) => {
        // 등급 색상 가져오기
        const gradeColor = stat.grade ? getGradeColor(stat.grade) : null;
        
        // 등급 색상이 있으면 해당 색상으로, 없으면 기본 색상
        let bgColor = 'rgba(255, 255, 255, 0.05)';
        let borderColor = 'rgba(255, 255, 255, 0.1)';
        
        if (gradeColor) {
          // hex 색상을 rgba로 변환 (투명도 추가)
          const hex = gradeColor.replace('#', '');
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);
          bgColor = `rgba(${r}, ${g}, ${b}, 0.15)`;
          borderColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
        }
        
        // 버튼 형태의 컨테이너 생성
        const statContainer = document.createElement('div');
        statContainer.className = 'equipment-stat-line';
        const statFontSize = isMobile ? '0.65rem' : '0.75rem';
        
        // 컨테이너 스타일: 버튼 형태, 최소 크기
        statContainer.style.cssText = `
          font-size: ${statFontSize};
          display: flex;
          align-items: center;
          gap: 0.35rem;
          padding: 0.35rem;
          background: ${bgColor};
          border: 1px solid ${borderColor};
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s ease;
        `;
        
        statContainer.onmouseenter = function() {
          if (gradeColor) {
            const hex = gradeColor.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            this.style.background = `rgba(${r}, ${g}, ${b}, 0.25)`;
          } else {
            this.style.background = 'rgba(255, 255, 255, 0.1)';
          }
          this.style.transform = 'translateY(-1px)';
        };
        statContainer.onmouseleave = function() {
          this.style.background = bgColor;
          this.style.transform = 'translateY(0)';
        };
        
        // 텍스트 영역: 한 줄에 효과 + 숫자
        const label = document.createElement('span');
        label.className = 'equipment-stat-label';
        label.textContent = stat.label || '';
        label.style.cssText = 'font-weight: 500; color: #ffffff; margin-right: auto;';
        
        const value = document.createElement('span');
        value.className = 'equipment-stat-value';
        value.textContent = stat.value || '';
        value.style.cssText = 'font-weight: 600; color: #ffffff;';
        
        statContainer.appendChild(label);
        statContainer.appendChild(value);
        
        column3.appendChild(statContainer);
      });
      
      card3.appendChild(column3);
    }
  }
  
  // 카드들을 statsDiv에 추가 (존재하는 카드만)
  statsDiv.appendChild(card1);
  if (card2) {
    statsDiv.appendChild(card2);
  }
  if (card3) {
    statsDiv.appendChild(card3);
  }
  
  // [최적화] 개별 아이템 상세 API 호출을 자동으로 하지 않고, 사용자가 장비를 클릭하거나 호버할 때만 호출
  // 자동 호출을 제거하여 페이지 로드 시 수백 번의 API 호출 방지
  // 필요시 itemDiv에 클릭 이벤트를 추가하여 사용자가 요청할 때만 호출하도록 변경 가능
  
  // statsDiv는 항상 추가 (3개 컬럼이 항상 있으므로)
  itemDiv.appendChild(statsDiv);
  
  // 신석 각인 (godStoneStat) - 장비 칸 가장 아래쪽에 별도 배지 형태로 표시 (statsDiv 밖으로)
  if (item.god_stone_stat && Array.isArray(item.god_stone_stat) && item.god_stone_stat.length > 0) {
    item.god_stone_stat.forEach(godStone => {
      if (!godStone || typeof godStone !== 'object') return;
      
      // 신석 배지 컨테이너 (전체 너비, statsDiv와 분리, 확실히 아래에 배치)
      const godStoneBadge = document.createElement('div');
      godStoneBadge.style.cssText = 'margin-top: 0.75rem; padding: 0.75rem; background: rgba(4, 7, 25, 0.5); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.15); width: 100%; box-sizing: border-box; position: relative; z-index: 0;';
      
      const godStoneContent = document.createElement('div');
      godStoneContent.style.cssText = 'display: flex; align-items: flex-start; gap: 0.5rem;';
      
      // 신석 아이콘
      if (godStone.icon) {
        const iconImg = document.createElement('img');
        iconImg.src = godStone.icon;
        iconImg.alt = godStone.name || '신석';
        const godStoneIconSize = isMobile ? '24px' : '32px';
        iconImg.style.cssText = `width: ${godStoneIconSize}; height: ${godStoneIconSize}; object-fit: contain; flex-shrink: 0;`;
        iconImg.onerror = function() {
          this.style.display = 'none';
        };
        godStoneContent.appendChild(iconImg);
      }
      
      // 신석 이름과 설명
      const godStoneText = document.createElement('div');
      godStoneText.style.cssText = 'display: flex; flex-direction: column; gap: 0.3rem; flex: 1;';
      
      const godStoneName = document.createElement('div');
      const grade = godStone.grade || '';
      const gradeColor = getGradeColor(grade);
      godStoneName.style.cssText = `font-weight: 600; font-size: 0.8rem; ${gradeColor ? `color: ${gradeColor};` : 'color: var(--text-primary);'}`;
      godStoneName.textContent = godStone.name || '';
      godStoneText.appendChild(godStoneName);
      
      if (godStone.desc) {
        const godStoneDesc = document.createElement('div');
        godStoneDesc.style.cssText = 'font-size: 0.7rem; color: var(--text-muted); line-height: 1.4;';
        // 설명을 한 줄로 표시 (줄바꿈을 공백으로)
        const descText = godStone.desc.replace(/\n/g, ' ');
        godStoneDesc.textContent = descText;
        godStoneText.appendChild(godStoneDesc);
      }
      
      godStoneContent.appendChild(godStoneText);
      godStoneBadge.appendChild(godStoneContent);
      
      // itemDiv의 맨 아래에 추가 (statsDiv 다음)
      itemDiv.appendChild(godStoneBadge);
    });
  }
  
  // 아이템 데이터를 data 속성에 저장
  itemDiv.setAttribute('data-item-data', JSON.stringify(item));
  
  return itemDiv;
}

// grade에 따른 색상 반환 함수
function getGradeColor(grade) {
  if (!grade) return null;
  const gradeLower = String(grade).toLowerCase().trim();
  const isDarkMode = document.documentElement.getAttribute('data-theme') !== 'light';
  
  if (gradeLower === 'legend' || gradeLower === 'legendary') return '#4a90e2'; // 파랑색
  if (gradeLower === 'rare') return '#4caf50'; // 초록색
  if (gradeLower === 'common' || gradeLower === '일반') {
    // 다크 모드에서는 흰색, 라이트 모드에서는 검정색
    return isDarkMode ? '#ffffff' : '#000000';
  }
  if (gradeLower === 'unique' || gradeLower === '유일') {
    // 다크 모드에서는 노란색, 라이트 모드에서는 주황색
    return isDarkMode ? '#FFD700' : '#ff8c00';
  }
  if (gradeLower === 'epic' || gradeLower === '고대') return '#FF6B35'; // 빨간색에 가까운 주황색
  return null; // 기본 색상
}

// 영혼 각인 옵션의 티어 판단 함수
function getSoulInscriptionTier(optionName) {
  if (!optionName) return 'C';
  
  const name = String(optionName).trim();
  
  // 주신 스탯이 포함된 경우 등급 판단 (장비/장신구 영혼각인에 주신 스탯이 붙는 경우)
  // S 등급 주신 스탯
  const sTierGodStones = [
    '환상[카이시넬]',
    '시간[시엘]',
    '파괴[지켈]',
    '죽음[트리니엘]',
    '자유[바이젤]',
    '지혜[루미엘]'
  ];
  
  // A 등급 주신 스탯
  const aTierGodStones = [
    '정의[네자칸]',
    '공간[이스라펠]'
  ];
  
  // 주신 스탯이 포함되어 있는지 확인
  for (const godStone of sTierGodStones) {
    if (name.includes(godStone)) {
      return 'S';
    }
  }
  
  for (const godStone of aTierGodStones) {
    if (name.includes(godStone)) {
      return 'A';
    }
  }
  
  // S 등급 (필수)
  const sTierOptions = [
    '무기 피해 증폭',
    '전투 속도',
    '피해 증폭',
    '치명타 피해 증폭',
    '위력',
    '다단 히트 적중',
    '정확'
  ];
  
  // A 등급 (유효)
  const aTierOptions = [
    '이동 속도',
    '공격력',
    '치명타',
    '명중'
  ];
  
  // B 등급 (애매)
  const bTierOptions = [
    '막기',
    '비행력',
    '회피',
    '생명력',
    '최대 생명력',
    '피해 내성',
    '방어력',
    '치명타 방어력',
    '후방 공격력',
    '정신력',
    '치명타 저항'
  ];
  
  // S 등급 확인 (옵션 이름에 포함되어 있는지 확인)
  for (const sOption of sTierOptions) {
    if (name.includes(sOption)) {
      return 'S';
    }
  }
  
  // B 등급 확인 (A 등급보다 먼저 체크하여 "치명타 방어력", "치명타 저항" 등을 정확히 분류)
  for (const bOption of bTierOptions) {
    if (name.includes(bOption)) {
      return 'B';
    }
  }
  
  // A 등급 확인 - "치명타"는 정확히 일치하거나 "치명타 "로 시작하는 경우만 (치명타 방어력, 치명타 저항 제외)
  for (const aOption of aTierOptions) {
    if (aOption === '치명타') {
      // "치명타"가 정확히 일치하거나 "치명타 "로 시작하되 "치명타 방어력"이나 "치명타 저항"이 아닌 경우
      if (name === '치명타' || (name.startsWith('치명타 ') && !name.includes('치명타 방어력') && !name.includes('치명타 저항'))) {
        return 'A';
      }
    } else if (name.includes(aOption)) {
      return 'A';
    }
  }
  
  // 기본값: B 등급 (나머지 모든 옵션)
  return 'B';
}

// 티어별 점수 반환 함수
function getTierScore(tier) {
  const tierScores = {
    'S': 100,
    'A': 60,
    'B': 0
  };
  return tierScores[tier] || 0;
}

// 장비별 영혼 각인 점수 계산 함수
function calculateEquipmentSoulScore(item) {
  if (!item) return { totalScore: 0, tierCounts: { S: 0, A: 0, B: 0 }, subSkillCount: 0 };
  
  let tierCounts = { S: 0, A: 0, B: 0 };
  let totalTierScore = 0;
  let subSkillCount = 0;
  
  // 크로메데 메인 무기인 경우 "늘어남" 옵션 추가 (S 티어)
  if (item.isKromedeMainWeapon) {
    tierCounts['S']++;
    totalTierScore += getTierScore('S');
  }
  
  // 영혼 각인 옵션 (sub_stats) 처리
  if (item.sub_stats) {
    const subStats = extractStats(item.sub_stats);
    if (subStats && subStats.length > 0) {
      subStats.forEach(stat => {
        const optionName = stat.label || '';
        const tier = getSoulInscriptionTier(optionName);
        tierCounts[tier]++;
        totalTierScore += getTierScore(tier);
      });
    }
  }
  
  // 부스킬 (sub_skills) 처리 - A 티어로 계산
  if (item.sub_skills && Array.isArray(item.sub_skills)) {
    item.sub_skills.forEach(subSkill => {
      if (subSkill && (subSkill.name || subSkill.title)) {
        subSkillCount++;
        tierCounts['A']++;
        totalTierScore += getTierScore('A');
      }
    });
  }
  
  // 영혼 각인율은 고려하지 않고 티어 점수 합만 사용
  return {
    totalScore: totalTierScore,
    tierCounts: tierCounts,
    subSkillCount: subSkillCount,
    tierScore: totalTierScore
  };
}

// 모든 장비의 영혼 각인 세팅 점수 계산 및 표시
function calculateAndDisplaySoulInscriptionScore(equipment, accessories) {
  const allItems = [...(equipment || []), ...(accessories || [])];
  
  let totalScore = 0;
  const itemScores = [];
  
  allItems.forEach((item, index) => {
    const scoreData = calculateEquipmentSoulScore(item);
    const itemName = item.name || `장비${index + 1}`;
    
    totalScore += scoreData.totalScore;
    
    itemScores.push({
      name: itemName,
      ...scoreData
    });
  });
  
  // 전역 변수에 저장 (DB 업데이트용)
  window.currentSoulScore = totalScore;
  
  // 장비 제목 밑에 점수 표시
  const equipmentInfo = document.getElementById('equipment-info');
  if (equipmentInfo) {
    // 기존 점수 표시 제거
    const existingScore = equipmentInfo.querySelector('.soul-inscription-score-container');
    if (existingScore) {
      existingScore.remove();
    }
    
    // 새 점수 표시 컨테이너 추가 (장비 제목 밑에)
    const scoreContainer = document.createElement('div');
    scoreContainer.className = 'soul-inscription-score-container';
    scoreContainer.style.cssText = 'margin-top: 1rem; margin-bottom: 1rem;';
    
    // 첫 번째 줄: 영혼 각인 세팅 점수
    const scoreLine = document.createElement('div');
    scoreLine.style.cssText = 'font-size: 0.9rem; color: #fbbf24; font-weight: 500; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;';
    const scoreValue = totalScore.toFixed(2);
    scoreLine.innerHTML = `(PVE 기준) 영혼 각인 딜 세팅 점수: <span style="font-size: 1.2rem; font-weight: 700;">${scoreValue}</span>점`;
    
    const infoButton = document.createElement('button');
    infoButton.textContent = '점수 산출 방식 보기';
    infoButton.style.cssText = `
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: rgba(157, 140, 255, 0.2);
      border: 1px solid rgba(157, 140, 255, 0.4);
      border-radius: 4px;
      color: #9d8cff;
      cursor: pointer;
      transition: all 0.2s ease;
    `;
    infoButton.onmouseenter = function() {
      this.style.background = 'rgba(157, 140, 255, 0.3)';
      this.style.borderColor = 'rgba(157, 140, 255, 0.6)';
    };
    infoButton.onmouseleave = function() {
      this.style.background = 'rgba(157, 140, 255, 0.2)';
      this.style.borderColor = 'rgba(157, 140, 255, 0.4)';
    };
    infoButton.onclick = function() {
      showSoulInscriptionScoreModal();
    };
    scoreLine.appendChild(infoButton);
    
    // 두 번째 줄: 전투력 ±500 구간 상위 % (비동기로 로드)
    const percentileLine = document.createElement('div');
    percentileLine.className = 'soul-score-percentile';
    percentileLine.style.cssText = 'font-size: 0.85rem; color: var(--text-muted);';
    percentileLine.textContent = '로딩 중...';
    scoreContainer.appendChild(scoreLine);
    scoreContainer.appendChild(percentileLine);
    
    // 장비 제목 다음에 삽입
    const equipmentTitle = equipmentInfo.querySelector('h4');
    if (equipmentTitle && equipmentTitle.nextSibling) {
      equipmentInfo.insertBefore(scoreContainer, equipmentTitle.nextSibling);
    } else {
      equipmentInfo.insertBefore(scoreContainer, equipmentInfo.firstChild.nextSibling);
    }
    
    // 전투력 ±500 구간 상위 % 조회 (임시 주석 처리)
    // 전투력은 result-combat-power 요소에서 가져오거나 전역 변수에서 가져옴
    // const combatPowerEl = document.getElementById('result-combat-power');
    // let combatPower = null;
    // if (combatPowerEl && combatPowerEl.textContent) {
    //   combatPower = parseInt(combatPowerEl.textContent.replace(/,/g, '')) || null;
    // }
    // if (!combatPower) {
    //   combatPower = window.currentCombatPower || window.characterData?.combat_power;
    // }
    // 
    // if (combatPower && totalScore > 0) {
    //   const combatPowerInt = parseInt(String(combatPower).replace(/,/g, '')) || 0;
    //   if (combatPowerInt > 0) {
    //     fetch(`/api/character/soul-score-percentile?combat_power=${combatPowerInt}&soul_score=${totalScore}`)
    //       .then(response => response.json())
    //       .then(data => {
    //         if (data.success && data.data) {
    //           const { power_range, rank, total, top_percent } = data.data;
    //           percentileLine.innerHTML = `${power_range.min}~${power_range.max} 구간 캐릭터 중 딜 세팅 점수 상위 <strong style="color: var(--accent);">${top_percent}%</strong> (${rank}/${total})`;
    //         } else {
    //           percentileLine.textContent = '상위 % 정보를 불러올 수 없습니다.';
    //         }
    //       })
    //       .catch(err => {
    //         percentileLine.textContent = '상위 % 정보를 불러올 수 없습니다.';
    //       });
    //   } else {
    //     percentileLine.textContent = '';
    //   }
    // } else {
    //   percentileLine.textContent = '';
    // }
    percentileLine.textContent = ''; // 임시로 빈 텍스트
  }
  
  return totalScore;
}

// 전투 점수 계산식 모달 표시 함수
function showDpsCalculationModal() {
  // 기존 모달이 있으면 제거
  const existingModal = document.getElementById('dps-calculation-modal');
  if (existingModal) {
    existingModal.remove();
  }
  
  // 모달 오버레이 생성
  const overlay = document.createElement('div');
  overlay.id = 'dps-calculation-modal';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
  `;
  
  // 모달 컨텐츠 생성
  const modal = document.createElement('div');
  modal.style.cssText = `
    background: #0a0e1a;
    border: 1px solid rgba(157, 140, 255, 0.3);
    border-radius: 12px;
    padding: 2rem;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    position: relative;
    width: 90%;
  `;
  
  // 닫기 버튼
  const closeButton = document.createElement('button');
  closeButton.textContent = '×';
  closeButton.style.cssText = `
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: transparent;
    border: none;
    color: #fff;
    font-size: 2rem;
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.2s ease;
  `;
  closeButton.onmouseenter = function() {
    this.style.background = 'rgba(255, 255, 255, 0.1)';
  };
  closeButton.onmouseleave = function() {
    this.style.background = 'transparent';
  };
  closeButton.onclick = function() {
    overlay.remove();
  };
  
  // 제목
  const title = document.createElement('h3');
  title.textContent = '아툴 전투 점수 계산 방식';
  title.style.cssText = 'margin: 0 0 1.5rem 0; font-size: 1.5rem; color: #9d8cff; font-weight: 600;';
  
  // 내용 컨테이너
  const content = document.createElement('div');
  content.style.cssText = 'color: var(--text-primary); line-height: 1.8;';
  
  // 포함되는 항목 박스
  const includedSection = document.createElement('div');
  includedSection.style.cssText = 'margin-bottom: 2rem;';
  
  const includedTitle = document.createElement('h4');
  includedTitle.textContent = '✅ 계산에 포함되는 항목';
  includedTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #4ade80; font-weight: 600;';
  
  const includedBox = document.createElement('div');
  includedBox.style.cssText = 'background: rgba(74, 222, 128, 0.1); padding: 1.5rem; border-radius: 8px; border-left: 3px solid #4ade80;';
  includedBox.innerHTML = `
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #4ade80;">1. 장비/장신구</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 기본 옵션 (공격력, 치명타, 초월 공증, 완벽, 다단 히트 등 딜 관련)<br>
        • 마석 각인 (공격력, 치명타, 각종 피해 증폭, 등 딜 관련)<br>
        • 영혼 각인 (각종 피해 증폭, 위력, 전투 속도, 정확, 다단히트, 공격력, 치명타, 등 딜 관련)<br>
        • 초월 효과
      </div>
    </div>
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #4ade80;">2. 타이틀 장착 효과</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 타이틀을 장착했을 때 적용되는 스탯 증가 효과 (피해 증폭, 공격력, 재사용 대기 시간, 강타, 완벽, 등등)
      </div>
    </div>
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #4ade80;">3. 일반 스킬/스티그마 스킬</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 스킬 포인트 및 레벨에 따른 전투 점수 계산
      </div>
    </div>
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #4ade80;">4. 주신 스탯</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 지혜 → 강타<br>
        • 파괴 → 공격력<br>
        • 정의 → 완벽<br>
        • 시간 → 전투 속도<br>
        • 환상 → 쿨타임 감소<br>
        • 죽음 → 치명타<br>
      </div>
    </div>
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #4ade80;">5. 일반 스탯</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 위력<br>
        • 정확
      </div>
    </div>
    <div>
      <strong style="color: #4ade80;">6. 데바니온</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 데바니온 포인트에 따른 스탯 증가 효과 (아스펠 (PVP) 제외)
      </div>
    </div>
  `;
  
  includedSection.appendChild(includedTitle);
  includedSection.appendChild(includedBox);
  
  // 포함되지 않는 항목 박스
  const excludedSection = document.createElement('div');
  excludedSection.style.cssText = 'margin-bottom: 2rem;';
  
  const excludedTitle = document.createElement('h4');
  excludedTitle.textContent = '❌ 계산에 포함되지 않는 항목';
  excludedTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #f87171; font-weight: 600;';
  
  const excludedBox = document.createElement('div');
  excludedBox.style.cssText = 'background: rgba(248, 113, 113, 0.1); padding: 1.5rem; border-radius: 8px; border-left: 3px solid #f87171;';
  excludedBox.innerHTML = `
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #f87171;">1. 펫 관련 내실, 타이틀 수집, 날개 수집 등 (정보 추출 불가)</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 펫 수집 효과<br>
        • 타이틀 수집 효과<br>
        • 날개 수집 효과<br>
        • 등의 효과는 정보 추출이 불가하여 계산에 포함 불가능
      </div>
    </div>
    <div style="margin-bottom: 0.75rem;">
      <strong style="color: #f87171;">2. 직업별 시너지</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 직업 고유 파티 시너지 효과로 인한 딜증은 조합에 따라 달라짐 <br>
        • 특정 스킬 조합으로 인한 추가 딜량
      </div>
    </div>
    <div>
      <strong style="color: #f87171;">4. 기타 방어 관련 옵션</strong>
      <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
        • 각종 내성/저항/방어 옵션<br>
        • 그 외 PVP 세팅 관련 방어 스탯, PVP 공격력, PVP 피해 증폭 등은 포함되지 않음.
      </div>
    </div>
  `;
  
  excludedSection.appendChild(excludedTitle);
  excludedSection.appendChild(excludedBox);
  
  // 추후 추가/수정될 항목 섹션
  const futureSection = document.createElement('div');
  futureSection.style.cssText = 'margin-bottom: 2rem;';
  
  const futureTitle = document.createElement('h4');
  futureTitle.textContent = '📋 추후 추가/수정될 항목';
  futureTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #fbbf24; font-weight: 600;';
  
  const futureBox = document.createElement('div');
  futureBox.style.cssText = 'background: rgba(251, 191, 36, 0.1); padding: 1.5rem; border-radius: 8px; border-left: 3px solid #fbbf24;';
  futureBox.innerHTML = `
    <div style="margin-bottom: 0.75rem;">
      <div style="font-size: 0.9rem; color: var(--text-muted);">
        • 날개 장착 효과로 인한 DPS 상승 (공격력, 관통, 재사용 시간 감소, 등)은 각 날개별 효과 반영할 예정
      </div>
    </div>
  `;
  
  futureSection.appendChild(futureTitle);
  futureSection.appendChild(futureBox);
  
  // 내용 조립
  content.appendChild(includedSection);
  content.appendChild(excludedSection);
  content.appendChild(futureSection);
  
  modal.appendChild(closeButton);
  modal.appendChild(title);
  modal.appendChild(content);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // 오버레이 클릭 시 닫기
  overlay.onclick = function(e) {
    if (e.target === overlay) {
      overlay.remove();
    }
  };
}

// 영혼 각인 점수 산출 방식 모달 표시 함수
function showSoulInscriptionScoreModal() {
  // 기존 모달이 있으면 제거
  const existingModal = document.getElementById('soul-inscription-score-modal');
  if (existingModal) {
    existingModal.remove();
  }
  
  // 모달 오버레이 생성
  const overlay = document.createElement('div');
  overlay.id = 'soul-inscription-score-modal';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
  `;
  
  // 모달 컨텐츠 생성
  const modal = document.createElement('div');
  modal.style.cssText = `
    background: #0a0e1a;
    border: 1px solid rgba(157, 140, 255, 0.3);
    border-radius: 12px;
    padding: 2rem;
    max-width: 700px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    position: relative;
  `;
  
  // 닫기 버튼
  const closeButton = document.createElement('button');
  closeButton.textContent = '×';
  closeButton.style.cssText = `
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: transparent;
    border: none;
    color: #fff;
    font-size: 2rem;
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: background 0.2s ease;
  `;
  closeButton.onmouseenter = function() {
    this.style.background = 'rgba(255, 255, 255, 0.1)';
  };
  closeButton.onmouseleave = function() {
    this.style.background = 'transparent';
  };
  closeButton.onclick = function() {
    overlay.remove();
  };
  
  // 제목
  const title = document.createElement('h3');
  title.textContent = '영혼 각인 세팅 점수 산출 방식';
  title.style.cssText = 'margin: 0 0 1.5rem 0; font-size: 1.5rem; color: #9d8cff; font-weight: 600;';
  
  // 내용 컨테이너
  const content = document.createElement('div');
  content.style.cssText = 'color: var(--text-primary); line-height: 1.8;';
  
  // 중요 안내 (제일 위)
  const importantNotice = document.createElement('div');
  importantNotice.style.cssText = 'margin-bottom: 2rem;';
  
  const noticeBox = document.createElement('div');
  noticeBox.style.cssText = 'background: rgba(255, 193, 7, 0.15); padding: 1.5rem; border-radius: 8px; border: 2px solid rgba(255, 193, 7, 0.4);';
  noticeBox.innerHTML = `
    <div style="font-size: 1.2rem; font-weight: 700; color: #FFC107; margin-bottom: 0.5rem; text-align: center;">
      ⚠️ 해당 점수는 "세팅 점수"입니다. "딜 점수"가 아닙니다.
    </div>
    <div style="font-size: 0.95rem; color: var(--text-primary); text-align: center;">
      점수 차이와 실제 딜이 비례하지 않습니다다.<br>
      PVE 세팅의 완성도와 옵션의 우선순위를 종합적으로 고려한 점수입니다.<br>
      <strong style="color: #FFC107;">※ PVE 기준, 딜 관련 유효옵션을 토대로 계산된 점수입니다.</strong> <br>
      <strong style="color: #FFC107;">※ PVP 세팅된 캐릭터의 경우, 점수가 낮게 나올 수 있습니다.</strong>
    </div>
  `;
  
  importantNotice.appendChild(noticeBox);
  
  // 공식 설명
  const formulaSection = document.createElement('div');
  formulaSection.style.cssText = 'margin-bottom: 2rem;';
  
  const formulaTitle = document.createElement('h4');
  formulaTitle.textContent = '📐 점수 산출 공식';
  formulaTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #9d8cff; font-weight: 600;';
  
  const formulaText = document.createElement('div');
  formulaText.style.cssText = 'background: rgba(157, 140, 255, 0.1); padding: 1rem; border-radius: 8px; border-left: 3px solid #9d8cff;';
  formulaText.innerHTML = `
    <div style="margin-bottom: 0.5rem;"><strong>장비 점수 = 각 슬롯의 티어 점수 총합</strong></div>
    <div style="font-size: 0.9rem; color: var(--text-muted);">
      예시: S(100점) + A(60점) + B(0점) = 160점
    </div>
  `;
  
  formulaSection.appendChild(formulaTitle);
  formulaSection.appendChild(formulaText);
  
  // 티어 점수 설명
  const tierSection = document.createElement('div');
  tierSection.style.cssText = 'margin-bottom: 2rem;';
  
  const tierTitle = document.createElement('h4');
  tierTitle.textContent = '? 티어별 점수';
  tierTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #9d8cff; font-weight: 600;';
  
  const tierList = document.createElement('div');
  tierList.style.cssText = 'background: rgba(157, 140, 255, 0.1); padding: 1rem; border-radius: 8px;';
  tierList.innerHTML = `
    <div style="margin-bottom: 0.5rem;"><strong style="color: #FFD700;">S (졸업)</strong>: 100점 - 해당 부위 종결 옵션</div>
    <div style="margin-bottom: 0.5rem;"><strong style="color: #2196F3;">A (유효)</strong>: 60점 - 공격력, 치명타 등 범용 딜 옵션</div>
    <div><strong style="color: #4CAF50;">B (평범)</strong>: 0점 - 나머지 모든 옵션</div>
  `;
  
  tierSection.appendChild(tierTitle);
  tierSection.appendChild(tierList);
  
  // 주의사항
  const warningSection = document.createElement('div');
  warningSection.style.cssText = 'margin-bottom: 2rem;';
  
  const warningTitle = document.createElement('h4');
  warningTitle.textContent = '⚠️ 주의사항';
  warningTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #ff6b6b; font-weight: 600;';
  
  const warningList = document.createElement('div');
  warningList.style.cssText = 'background: rgba(255, 107, 107, 0.1); padding: 1rem; border-radius: 8px; border-left: 3px solid #ff6b6b;';
  warningList.innerHTML = `
    <div style="margin-bottom: 0.8rem;">
      <strong>1. 직업별 옵션 효율 차이</strong><br>
      아직 직업별 옵션 효율이 다른 것은 고려되지 않았습니다. 예를 들어 일부 클래스(특정 딜러)의 경우 <strong>다단 히트 적중</strong>이 S 등급이 될 수 있습니다.<br>
      <span style="color: var(--text-muted); font-size: 0.9rem;">※ 향후 연구가 진행되며 클래스별로 다른 옵션에 다른 티어를 부여할 수도 있습니다.</span>
    </div>
    <div style="margin-bottom: 0.8rem;">
      <strong>2. 100% 딜만 고려한 티어가 아닙니다</strong><br>
      예를 들어 <strong>이동 속도</strong>의 경우 딜에 직접적인 관여가 없지만, 신발에 한해서 나오는 1순위 옵션이기에 A 등급을 부여했습니다.
    </div>
    <div style="margin-bottom: 0.8rem;">
      <strong>3. 모든 스킬은 A 티어로 계산</strong><br>
      부스킬(스킬)은 모두 A 티어(60점)로 계산됩니다.
    </div>
    <div>
      <strong>4. 방어력 관련 옵션</strong><br>
      방어력 관련 옵션이 선호되는 경우도 있지만, 이 점수는 <strong>딜 옵션 위주로만 고려</strong>하여 계산되므로 방어력 관련 옵션은 낮은 티어가 나올 수 있습니다.
    </div>
  `;
  
  warningSection.appendChild(warningTitle);
  warningSection.appendChild(warningList);
  
  // 크로메데 무기 특수 옵션
  const specialSection = document.createElement('div');
  specialSection.style.cssText = 'margin-bottom: 0;';
  
  const specialTitle = document.createElement('h4');
  specialTitle.textContent = '✨ 특수 옵션';
  specialTitle.style.cssText = 'margin: 0 0 1rem 0; font-size: 1.1rem; color: #9d8cff; font-weight: 600;';
  
  const specialText = document.createElement('div');
  specialText.style.cssText = 'background: rgba(157, 140, 255, 0.1); padding: 1rem; border-radius: 8px;';
  specialText.innerHTML = `
    <div><strong>크로메데 메인 무기</strong>: 이름에 "크로메데"가 포함된 메인 무기의 경우, <strong>"늘어남"</strong> 옵션이 S 티어(100점)로 자동 추가됩니다.</div>
  `;
  
  specialSection.appendChild(specialTitle);
  specialSection.appendChild(specialText);
  
  // 내용 조립
  content.appendChild(importantNotice);
  content.appendChild(formulaSection);
  content.appendChild(tierSection);
  content.appendChild(warningSection);
  content.appendChild(specialSection);
  
  modal.appendChild(closeButton);
  modal.appendChild(title);
  modal.appendChild(content);
  
  overlay.appendChild(modal);
  document.body.appendChild(overlay);
  
  // 오버레이 클릭 시 닫기
  overlay.onclick = function(e) {
    if (e.target === overlay) {
      overlay.remove();
    }
  };
  
  // ESC 키로 닫기
  const handleEsc = function(e) {
    if (e.key === 'Escape') {
      overlay.remove();
      document.removeEventListener('keydown', handleEsc);
    }
  };
  document.addEventListener('keydown', handleEsc);
}

// 티어 뱃지 생성 함수
function createTierBadge(tier) {
  const badge = document.createElement('span');
  badge.className = 'soul-inscription-tier-badge';
  
  // 티어별 스타일 설정 (빛나는 효과 제거)
  const tierStyles = {
    'S': {
      gradient: 'linear-gradient(135deg, #FFEB3B 0%, #FFD700 25%, #FFC107 50%, #FFD700 75%, #FFEB3B 100%)',
      text: '#FFFFFF',
      shadow: '0 2px 4px rgba(0, 0, 0, 0.3)',
      border: '1.5px solid rgba(255, 235, 59, 0.9)',
      size: '22px',
      fontSize: '0.75rem',
      textShadow: '0 1px 2px rgba(0, 0, 0, 0.6)'
    },
    'A': {
      gradient: 'linear-gradient(135deg, #42A5F5 0%, #2196F3 25%, #1976D2 50%, #2196F3 75%, #42A5F5 100%)',
      text: '#FFFFFF',
      shadow: '0 2px 3px rgba(0, 0, 0, 0.3)',
      border: '1.5px solid rgba(66, 165, 245, 0.8)',
      size: '21px',
      fontSize: '0.72rem',
      textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)'
    },
    'B': {
      gradient: 'linear-gradient(135deg, #66BB6A 0%, #4CAF50 25%, #388E3C 50%, #4CAF50 75%, #66BB6A 100%)',
      text: '#FFFFFF',
      shadow: '0 2px 2px rgba(0, 0, 0, 0.3)',
      border: '1.5px solid rgba(102, 187, 106, 0.7)',
      size: '20px',
      fontSize: '0.7rem',
      textShadow: '0 1px 2px rgba(0, 0, 0, 0.4)'
    }
  };
  
  const style = tierStyles[tier] || tierStyles['B'];
  
  badge.textContent = tier;
  badge.style.cssText = `
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: ${style.size};
    height: ${style.size};
    aspect-ratio: 1;
    border-radius: 50%;
    background: ${style.gradient};
    color: ${style.text};
    font-size: ${style.fontSize};
    font-weight: 900;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-right: 0.4rem;
    flex-shrink: 0;
    line-height: 1;
    border: ${style.border};
    box-shadow: ${style.shadow};
    text-shadow: ${style.textShadow || 'none'};
    position: relative;
    overflow: hidden;
  `;
  
  // 클릭 이벤트 추가: 모달 열기
  badge.addEventListener('click', function(e) {
    e.stopPropagation();
    openSoulEngravingGradeModal();
  });
  
  // 호버 효과 추가
  badge.addEventListener('mouseenter', function() {
    this.style.transform = 'scale(1.1)';
    this.style.opacity = '0.9';
  });
  
  badge.addEventListener('mouseleave', function() {
    this.style.transform = 'scale(1)';
    this.style.opacity = '1';
  });
  
  return badge;
}

// 스탯 정보 추출 함수 (subStats 또는 magicStoneStat에서)
function extractStats(statsData) {
  if (!statsData) return [];
  
  const result = [];
  
  // 배열인 경우
  if (Array.isArray(statsData)) {
    statsData.forEach((stat, index) => {
      if (typeof stat === 'object' && stat !== null) {
        // 객체 형태의 스탯
        const name = stat.name || stat.key || stat.type || stat.label || `스탯${index + 1}`;
        const value = stat.value || stat.amount || stat.val || stat.bonus || '';
        const grade = stat.grade || stat.rank || stat.tier || stat.quality || stat.rarity || '';
        if (name && value !== '') {
          result.push({ label: name, value: String(value), grade: String(grade) });
        }
      } else if (typeof stat === 'string') {
        // 문자열 형태
        result.push({ label: `옵션${index + 1}`, value: stat });
      }
    });
  }
  // 객체인 경우
  else if (typeof statsData === 'object') {
    for (const [key, value] of Object.entries(statsData)) {
      if (value !== null && value !== undefined && value !== '') {
        if (typeof value === 'object' && !Array.isArray(value)) {
          // 중첩된 객체
          const name = value.name || value.key || value.type || value.label || key;
          const val = value.value || value.amount || value.val || value.bonus || '';
          const grade = value.grade || value.rank || value.tier || value.quality || value.rarity || '';
          if (name && val !== '') {
            result.push({ label: name, value: String(val), grade: String(grade) });
          }
        } else if (Array.isArray(value)) {
          // 배열 값
          value.forEach((v, idx) => {
            if (typeof v === 'object' && v !== null) {
              const name = v.name || v.key || v.type || v.label || `${key}${idx + 1}`;
              const val = v.value || v.amount || v.val || v.bonus || '';
              const grade = v.grade || v.rank || v.tier || v.quality || v.rarity || '';
              if (name && val !== '') {
                result.push({ label: name, value: String(val), grade: String(grade) });
              }
            } else if (v !== null && v !== undefined && v !== '') {
              result.push({ label: `${key}${idx + 1}`, value: String(v) });
            }
          });
        } else {
          // 단순 값
          result.push({ label: key, value: String(value) });
        }
      }
    }
  }
  
  return result;
}

// 모든 키를 재귀적으로 찾는 함수
function getAllKeys(obj, prefix = '') {
  let keys = [];
  
  if (typeof obj === 'object' && obj !== null) {
    if (Array.isArray(obj)) {
      obj.forEach((item, index) => {
        if (typeof item === 'object' && item !== null) {
          keys = keys.concat(getAllKeys(item, `${prefix}[${index}]`));
        }
      });
    } else {
      for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}.${key}` : key;
        keys.push(fullKey);
        
        if (typeof value === 'object' && value !== null) {
          keys = keys.concat(getAllKeys(value, fullKey));
        }
      }
    }
  }
  
  return keys;
}

// 개별 아이템 상세 정보 가져오기 함수
function fetchEquipmentItemDetail(item, statsDiv) {
  if (!item.item_id || !window.currentCharacterId || !window.currentServerId) {
    return;
  }
  
  const params = new URLSearchParams();
  params.append('id', item.item_id);
  params.append('enchantLevel', item.enhance_level || 0);
  params.append('characterId', window.currentCharacterId);
  params.append('serverId', window.currentServerId);
  if (item.slot_index !== null && item.slot_index !== undefined) {
    params.append('slotPos', item.slot_index);
  }
  params.append('lang', 'ko');
  
  fetch('/api/character/equipment/item?' + params.toString())
    .then(response => response.json())
    .then(data => {
      if (data.success && data.data) {
        const detailData = data.data;
        
        // 상세 정보에서 subStats와 magicStoneStat 추출
        let subStats = detailData.subStats || detailData.subStat || detailData.sub_stats || detailData.sub_stat;
        let magicStoneStat = detailData.magicStoneStat || detailData.magicStone || detailData.magic_stone_stat || detailData.magic_stone;
        
        // 재귀적으로 찾기
        if (!subStats) {
          subStats = findNestedValue(detailData, ['subStats', 'subStat', 'sub_stats', 'sub_stat']);
        }
        if (!magicStoneStat) {
          magicStoneStat = findNestedValue(detailData, ['magicStoneStat', 'magicStone', 'magic_stone_stat', 'magic_stone']);
        }
        
        // 2컬럼 레이아웃에서 왼쪽(영혼 각인)과 오른쪽(마석 각인) 컬럼 찾기
        const soulColumn = statsDiv.querySelector('div:first-child');
        const stoneColumn = statsDiv.querySelector('div:last-child');
        
        // subStats 표시 (영혼 각인)
        if (subStats && soulColumn) {
          const subStatsExtracted = extractStats(subStats);
          if (subStatsExtracted && subStatsExtracted.length > 0) {
            // 기존 영혼 각인 항목들 제거 (헤더 제외)
            const existingStats = soulColumn.querySelectorAll('.equipment-stat-line');
            existingStats.forEach(el => el.remove());
            
            // 크로메데 메인 무기인 경우 "늘어남" 옵션을 맨 위에 추가
            if (item.isKromedeMainWeapon) {
              const neureomLine = document.createElement('div');
              neureomLine.className = 'equipment-stat-line';
              const tierBadge = createTierBadge('S');
              
              neureomLine.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; width: 100%;';
              
              neureomLine.appendChild(tierBadge);
              
              const label = document.createElement('span');
              label.className = 'equipment-stat-label';
              label.textContent = '늘어남';
              label.style.cssText = 'flex: 1; min-width: 0;';
              
              const value = document.createElement('span');
              value.className = 'equipment-stat-value';
              value.textContent = '';
              value.style.cssText = 'flex-shrink: 0; text-align: right; white-space: nowrap;';
              
              neureomLine.appendChild(label);
              neureomLine.appendChild(value);
              soulColumn.appendChild(neureomLine);
            }
            
            // 티어별 정렬: S -> A -> B 순으로
            const tierOrder = { 'S': 0, 'A': 1, 'B': 2, 'C': 3 };
            const sortedSubStatsExtracted = [...subStatsExtracted].sort((a, b) => {
              const tierA = getSoulInscriptionTier(a.label || '');
              const tierB = getSoulInscriptionTier(b.label || '');
              const orderA = tierOrder[tierA] !== undefined ? tierOrder[tierA] : 3;
              const orderB = tierOrder[tierB] !== undefined ? tierOrder[tierB] : 3;
              return orderA - orderB;
            });
            
            sortedSubStatsExtracted.forEach(stat => {
              const statLine = document.createElement('div');
              statLine.className = 'equipment-stat-line';
              
              // 티어 판단 및 뱃지 생성
              const optionName = stat.label || '';
              const tier = getSoulInscriptionTier(optionName);
              const tierBadge = createTierBadge(tier);
              
              statLine.style.cssText = 'display: flex; align-items: center; gap: 0.5rem; width: 100%;';
              
              // 티어 뱃지 추가
              statLine.appendChild(tierBadge);
              
              const label = document.createElement('span');
              label.className = 'equipment-stat-label';
              label.textContent = stat.label || '';
              label.style.cssText = 'flex: 1; min-width: 0;';
              
              const value = document.createElement('span');
              value.className = 'equipment-stat-value';
              value.textContent = stat.value || '';
              value.style.cssText = 'flex-shrink: 0; text-align: right; white-space: nowrap;';
              
              statLine.appendChild(label);
              statLine.appendChild(value);
              soulColumn.appendChild(statLine);
            });
          }
        }
        
        // magicStoneStat 표시 (마석 각인)
        if (magicStoneStat && stoneColumn) {
          const magicStoneExtracted = extractStats(magicStoneStat);
          
          if (magicStoneExtracted && magicStoneExtracted.length > 0) {
            // 기존 마석 각인 항목들 제거 (헤더 제외)
            const existingStats = stoneColumn.querySelectorAll('.equipment-stat-line');
            existingStats.forEach(el => el.remove());
            
            magicStoneExtracted.forEach((stat, idx) => {
              // 등급 색상 가져오기
              const gradeColor = stat.grade ? getGradeColor(stat.grade) : null;
              
              // 등급 색상이 있으면 해당 색상으로, 없으면 기본 색상
              let bgColor = 'rgba(255, 255, 255, 0.05)';
              let borderColor = 'rgba(255, 255, 255, 0.1)';
              
              if (gradeColor) {
                // hex 색상을 rgba로 변환 (투명도 추가)
                const hex = gradeColor.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                bgColor = `rgba(${r}, ${g}, ${b}, 0.15)`;
                borderColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
              }
              
              // 버튼 형태의 컨테이너 생성
              const statContainer = document.createElement('div');
              statContainer.className = 'equipment-stat-line';
              const statFontSize = '0.75rem';
              
              // 컨테이너 스타일: 버튼 형태, 최소 크기
              statContainer.style.cssText = `
                font-size: ${statFontSize};
                display: flex;
                align-items: center;
                gap: 0.35rem;
                padding: 0.35rem;
                background: ${bgColor};
                border: 1px solid ${borderColor};
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              
              statContainer.onmouseenter = function() {
                if (gradeColor) {
                  const hex = gradeColor.replace('#', '');
                  const r = parseInt(hex.substr(0, 2), 16);
                  const g = parseInt(hex.substr(2, 2), 16);
                  const b = parseInt(hex.substr(4, 2), 16);
                  this.style.background = `rgba(${r}, ${g}, ${b}, 0.25)`;
                } else {
                  this.style.background = 'rgba(255, 255, 255, 0.1)';
                }
                this.style.transform = 'translateY(-1px)';
              };
              statContainer.onmouseleave = function() {
                this.style.background = bgColor;
                this.style.transform = 'translateY(0)';
              };
              
              // 텍스트 영역: 한 줄에 효과 + 숫자
              const label = document.createElement('span');
              label.className = 'equipment-stat-label';
              label.textContent = stat.label || '';
              label.style.cssText = 'font-weight: 500; color: #ffffff; margin-right: auto;';
              
              const value = document.createElement('span');
              value.className = 'equipment-stat-value';
              value.textContent = stat.value || '';
              value.style.cssText = 'font-weight: 600; color: #ffffff;';
              
              statContainer.appendChild(label);
              statContainer.appendChild(value);
              
              stoneColumn.appendChild(statContainer);
            });
          }
        }
      }
    })
    .catch(error => {
    });
}

// 중첩된 객체에서 값을 재귀적으로 찾는 함수
function findNestedValue(obj, targetKeys) {
  if (!obj || typeof obj !== 'object') return null;
  
  if (Array.isArray(obj)) {
    for (const item of obj) {
      const found = findNestedValue(item, targetKeys);
      if (found !== null) return found;
    }
  } else {
    for (const key of targetKeys) {
      if (key in obj && obj[key] !== null && obj[key] !== undefined) {
        return obj[key];
      }
    }
    
    for (const value of Object.values(obj)) {
      if (typeof value === 'object' && value !== null) {
        const found = findNestedValue(value, targetKeys);
        if (found !== null) return found;
      }
    }
  }
  
  return null;
}

// gradeName에 따른 뱃지 생성 함수
function createGradeBadge(gradeName, contentType, isMobile) {
  if (!gradeName) return null;
  
  const badge = document.createElement('div');
  const badgeFontSize = isMobile ? '0.65rem' : '0.75rem';
  
  // 어비스 컨텐츠인 경우 (1급병, 2급병 등)
  if (contentType === 'abyss' && (gradeName.includes('급병') || gradeName.match(/^\d+급병/))) {
    // 이름표 느낌 뱃지
    badge.style.cssText = `
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
      color: #ffffff;
      font-size: ${badgeFontSize};
      font-weight: 600;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      text-align: center;
      letter-spacing: 0.5px;
    `;
    badge.textContent = gradeName;
    return badge;
  }
  
  // 일반 등급 뱃지 (아이언, 브론즈, 실버, 골드, 플래티넘, 다이아몬드, 마스터, 그랜드 마스터, 챌린저)
  const gradeStyles = {
    '아이언': { bg: '#78716c', color: '#ffffff', border: '#57534e' },
    '브론즈': { bg: '#92400e', color: '#ffffff', border: '#78350f' },
    '실버': { bg: '#6b7280', color: '#ffffff', border: '#4b5563' },
    '골드': { bg: '#d97706', color: '#ffffff', border: '#b45309' },
    '플래티넘': { bg: '#0ea5e9', color: '#ffffff', border: '#0284c7' },
    '다이아몬드': { bg: '#8b5cf6', color: '#ffffff', border: '#7c3aed' },
    '마스터': { bg: '#ec4899', color: '#ffffff', border: '#db2777' },
    '그랜드 마스터': { bg: '#f59e0b', color: '#ffffff', border: '#d97706' },
    '챌린저': { bg: 'linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%)', color: '#ffffff', border: '#d97706' }
  };
  
  // gradeName에서 등급 찾기
  let matchedGrade = null;
  let displayText = gradeName; // 기본값은 전체 gradeName
  
  // 챌린저는 "챌린저"로 시작하면 챌린저로 인식하되, 전체 텍스트 표시
  if (gradeName.startsWith('챌린저')) {
    matchedGrade = '챌린저';
    displayText = gradeName; // 전체 텍스트 (예: "챌린저 1", "챌린저 2")
  } else {
    // 다른 등급들은 기존 로직대로
    for (const grade in gradeStyles) {
      if (gradeName.includes(grade)) {
        matchedGrade = grade;
        displayText = grade; // 등급명만 표시
        break;
      }
    }
  }
  
  if (matchedGrade) {
    const style = gradeStyles[matchedGrade];
    badge.style.cssText = `
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 6px;
      background: ${style.bg};
      color: ${style.color};
      font-size: ${badgeFontSize};
      font-weight: 600;
      border: 1px solid ${style.border};
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      text-align: center;
    `;
    badge.textContent = displayText;
    return badge;
  }
  
  // 매칭되지 않은 경우 기본 스타일
  badge.style.cssText = `
    display: inline-block;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-muted);
    font-size: ${badgeFontSize};
    font-weight: 500;
    border: 1px solid rgba(255, 255, 255, 0.2);
    text-align: center;
  `;
  badge.textContent = gradeName;
  return badge;
}

// 컨텐츠 랭킹 정보 표시
function displayContentRankings(contentRankings) {
  const container = document.getElementById('content-rankings');
  const grid = container.querySelector('.content-rankings-grid');
  
  if (!container || !grid) {
    return;
  }
  
  // 컨텐츠 정보 매핑 (PvP: 빨강, PvE: 파랑)
  const contentInfo = {
    'abyss': { name: '어비스', icon: '⚔️', color: '#f87171' }, // PvP - 빨강
    'solo_arena': { name: '고독의 투기장', icon: '⚔️', color: '#f87171' }, // PvP - 빨강
    'coop_arena': { name: '협력의 투기장', icon: '⚔️', color: '#f87171' }, // PvP - 빨강
    'nightmare': { name: '악몽', icon: '👹', color: '#60a5fa' }, // PvE - 파랑
    'transcendence': { name: '초월', icon: '🌟', color: '#60a5fa' }, // PvE - 파랑
    'awakening': { name: '각성전', icon: '✨', color: '#60a5fa' }, // PvE - 파랑
    'subjugation': { name: '토벌전', icon: '🗡️', color: '#60a5fa' } // PvE - 파랑
  };
  
  // 그리드 초기화
  grid.innerHTML = '';
  
  // 컨텐츠별 카드 생성
  const contentOrder = ['abyss', 'solo_arena', 'coop_arena', 'nightmare', 'transcendence', 'awakening', 'subjugation'];
  
  let hasAnyRanking = false;
  
  contentOrder.forEach(contentType => {
    const info = contentInfo[contentType];
    const ranking = contentRankings[contentType];
    
    const card = document.createElement('div');
    // 테두리 색상: PvP는 빨강, PvE는 파랑
    const borderColor = info.color;
    const isMobile = window.innerWidth <= 768;
    const cardPadding = isMobile ? '0.5rem' : '0.75rem';
    const cardGap = isMobile ? '0.3rem' : '0.5rem';
    card.style.cssText = `padding: ${cardPadding}; border-radius: 8px; background: rgba(4, 7, 25, 0.35); border: 2px solid ${borderColor}; display: flex; flex-direction: column; gap: ${cardGap}; transition: all 0.2s ease; align-items: center; text-align: center;`;
    
    card.onmouseenter = () => {
      card.style.background = 'rgba(4, 7, 25, 0.5)';
      card.style.borderColor = borderColor;
      card.style.transform = 'translateY(-2px)';
      card.style.boxShadow = `0 4px 12px ${borderColor}40`;
    };
    card.onmouseleave = () => {
      card.style.background = 'rgba(4, 7, 25, 0.35)';
      card.style.borderColor = borderColor;
      card.style.transform = 'translateY(0)';
      card.style.boxShadow = 'none';
    };
    
    // 컨텐츠 이름
    const nameDiv = document.createElement('div');
    const nameFontSize = isMobile ? '0.65rem' : '0.95rem';
    nameDiv.style.cssText = `font-size: ${nameFontSize}; color: var(--text-muted); display: flex; align-items: center; justify-content: center; gap: 0.25rem; text-align: center;`;
    nameDiv.innerHTML = `<span>${info.icon}</span><span>${info.name}</span>`;
    card.appendChild(nameDiv);
    
    if (ranking && ranking.rank !== undefined && ranking.rank !== null) {
      hasAnyRanking = true;
      
      // 순위 표시
      const rankDiv = document.createElement('div');
      const rankFontSize = isMobile ? '0.9rem' : '1.1rem';
      rankDiv.style.cssText = `font-size: ${rankFontSize}; font-weight: 600; color: var(--text-primary); text-align: center;`;
      rankDiv.textContent = `${ranking.rank}위`;
      card.appendChild(rankDiv);
      
      // 포인트 표시 (0이어도 표시)
      if (ranking.point !== undefined && ranking.point !== null) {
        const pointDiv = document.createElement('div');
        const pointFontSize = isMobile ? '0.7rem' : '0.85rem';
        pointDiv.style.cssText = `font-size: ${pointFontSize}; color: var(--text-muted); text-align: center;`;
        pointDiv.textContent = `${parseInt(ranking.point || 0).toLocaleString()}점`;
        card.appendChild(pointDiv);
      } else if (ranking.rank !== undefined && ranking.rank !== null) {
        // rank는 있지만 point가 없는 경우 (포인트 정보 없음 표시)
        const pointDiv = document.createElement('div');
        const pointFontSize = isMobile ? '0.7rem' : '0.85rem';
        pointDiv.style.cssText = `font-size: ${pointFontSize}; color: var(--text-muted); font-style: italic; text-align: center;`;
        pointDiv.textContent = '-';
        card.appendChild(pointDiv);
      }
      
      // gradeName 뱃지 표시
      if (ranking.gradeName) {
        const gradeBadge = createGradeBadge(ranking.gradeName, contentType, isMobile);
        if (gradeBadge) {
          card.appendChild(gradeBadge);
        }
      } else {
        // 디버깅: gradeName이 없는 경우 확인
      }
      
    } else {
      // 랭킹 정보 없음
      const noRankDiv = document.createElement('div');
      const noRankFontSize = isMobile ? '0.75rem' : '0.9rem';
      noRankDiv.style.cssText = `font-size: ${noRankFontSize}; color: var(--text-muted); font-style: italic; text-align: center;`;
      noRankDiv.textContent = '-위';
      card.appendChild(noRankDiv);
    }
    
    grid.appendChild(card);
  });
  
  // 컨텐츠 랭킹 섹션 표시/숨김
  if (hasAnyRanking) {
    container.style.display = 'block';
  } else {
    container.style.display = 'none';
  }
}

// 캐릭터 랭킹 정보 로드
function loadCharacterRanking(nickname, server, race) {
  const params = new URLSearchParams();
  params.append('nickname', nickname);
  params.append('server', server);
  params.append('race', race);
  
  fetch('/api/character/ranking?' + params.toString())
    .then(res => res.json())
    .then(data => {
      if (data.success && data.data) {
        const ranking = data.data;
        
        // 전체 랭킹
        document.getElementById('result-overall-rank').textContent = `${ranking.overall.rank}등 / ${ranking.overall.total}명`;
        document.getElementById('result-overall-percentage').textContent = `상위 ${ranking.overall.percentage}%`;
        
        // 직업 랭킹
        document.getElementById('result-job-rank').textContent = `${ranking.job.rank}등 / ${ranking.job.total}명`;
        document.getElementById('result-job-percentage').textContent = `상위 ${ranking.job.percentage}%`;
        
        // 서버 랭킹
        document.getElementById('result-server-rank').textContent = `${ranking.server.rank}등 / ${ranking.server.total}명`;
        document.getElementById('result-server-percentage').textContent = `상위 ${ranking.server.percentage}%`;
        
        // 랭킹 정보 표시
        document.getElementById('ranking-info').style.display = 'block';
      } else {
        document.getElementById('ranking-info').style.display = 'none';
      }
    })
    .catch(error => {
      document.getElementById('ranking-info').style.display = 'none';
    });
}

// 캐릭터 탭 상태 초기화 함수
function resetCharacterTabs() {
  const tabButtons = document.querySelectorAll('.character-tab-btn');
  const tabPanels = document.querySelectorAll('.character-tab-panel');
  
  // 모든 탭 버튼 비활성화
  tabButtons.forEach(b => {
    b.classList.remove('active');
    b.style.color = 'var(--text-muted)';
    b.style.borderBottomColor = 'transparent';
    b.style.background = 'transparent';
  });
  
  // 모든 탭 패널 숨김
  tabPanels.forEach(p => {
    p.classList.remove('active');
    p.style.display = 'none';
  });
  
  // 기본 정보 탭 활성화
  const basicInfoBtn = document.querySelector('.character-tab-btn[data-tab="basic-info"]');
  const basicInfoPanel = document.getElementById('panel-basic-info');
  if (basicInfoBtn && basicInfoPanel) {
    basicInfoBtn.classList.add('active');
    basicInfoBtn.style.color = 'var(--text-primary)';
    basicInfoBtn.style.borderBottomColor = 'var(--accent)';
    basicInfoPanel.classList.add('active');
    basicInfoPanel.style.display = 'block';
  }
  
  // 데바니온 컨텐츠 초기화
  const daevanionContent = document.getElementById('daevanion-content');
  if (daevanionContent) {
    daevanionContent.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">서브탭을 선택하여 데바니온 정보를 확인하세요.</div>';
  }
  
  // 데바니온 서브탭도 초기화
  const subtabButtons = document.querySelectorAll('.daevanion-subtab-btn');
  subtabButtons.forEach(b => {
    b.classList.remove('active');
    b.style.background = 'rgba(255, 255, 255, 0.04)';
    b.style.borderColor = 'rgba(255, 255, 255, 0.1)';
    b.style.color = 'var(--text-muted)';
  });
  
  // 첫 번째 서브탭 활성화
  const firstSubtab = document.querySelector('.daevanion-subtab-btn[data-boardid="41"]');
  if (firstSubtab) {
    firstSubtab.classList.add('active');
    firstSubtab.style.background = 'rgba(157, 140, 255, 0.12)';
    firstSubtab.style.borderColor = 'rgba(157, 140, 255, 0.3)';
    firstSubtab.style.color = 'var(--accent)';
  }
}

// 캐릭터 정보 탭 전환 함수
function setupCharacterTabs() {
  const tabButtons = document.querySelectorAll('.character-tab-btn');
  const tabPanels = document.querySelectorAll('.character-tab-panel');
  
  // 기존 이벤트 리스너 제거를 위해 클론 후 교체 (한 번만 등록되도록)
  tabButtons.forEach(btn => {
    // 기존 클릭 이벤트 제거
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
  });
  
  // 새로 선택된 버튼들에 이벤트 리스너 추가
  const newTabButtons = document.querySelectorAll('.character-tab-btn');
  newTabButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const targetTab = btn.getAttribute('data-tab');
      
      // 모든 탭 버튼 비활성화
      newTabButtons.forEach(b => {
        b.classList.remove('active');
        b.style.color = 'var(--text-muted)';
        b.style.borderBottomColor = 'transparent';
        b.style.background = 'transparent';
      });
      
      // 모든 탭 패널 숨김
      tabPanels.forEach(p => {
        p.classList.remove('active');
        p.style.display = 'none';
      });
      
      // 선택된 탭 활성화
      btn.classList.add('active');
      btn.style.color = 'var(--text-primary)';
      btn.style.borderBottomColor = 'var(--accent)';
      
      // 선택된 탭 패널 표시
      const targetPanel = document.getElementById(`panel-${targetTab}`);
      if (targetPanel) {
        targetPanel.classList.add('active');
        targetPanel.style.display = 'block';
      }
      
      // 데바니온 탭이면 첫 번째 서브탭 로드 및 결정 포인트 정보 업데이트
      if (targetTab === 'daevanion') {
        const firstSubtab = document.querySelector('.daevanion-subtab-btn[data-boardid="41"]');
        if (firstSubtab) {
          firstSubtab.click();
        }
        // 데바니온 결정 포인트 정보 업데이트 (한 번만 호출)
        updateAllDaevanionSkillPoints();
        
        // 데바니온 탭이 열릴 때 랭킹 정보 다시 로드
        if (window.currentCharacterNickname && window.currentCharacterServer && window.currentCharacterRace) {
          setTimeout(() => {
            loadCharacterRankingInfo(window.currentCharacterNickname, window.currentCharacterServer, window.currentCharacterRace);
          }, 500); // 데바니온 포인트 계산 후 랭킹 정보 로드
        }
      }
      
      // 성장기록 탭이면 그래프 로드
      if (targetTab === 'growth-history') {
        loadGrowthHistory();
      }
    });
  });
  
  // 데바니온 서브탭 이벤트 리스너 (중복 방지)
  const subtabButtons = document.querySelectorAll('.daevanion-subtab-btn');
  // 기존 이벤트 리스너 제거를 위해 클론 후 교체
  subtabButtons.forEach(btn => {
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
  });
  
  // 새로 선택된 서브탭 버튼들에 이벤트 리스너 추가
  const newSubtabButtons = document.querySelectorAll('.daevanion-subtab-btn');
  newSubtabButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const boardId = btn.getAttribute('data-boardid');
      
      // 모든 서브탭 버튼 비활성화
      newSubtabButtons.forEach(b => {
        b.classList.remove('active');
        b.style.background = 'rgba(255, 255, 255, 0.04)';
        b.style.borderColor = 'rgba(255, 255, 255, 0.1)';
        b.style.color = 'var(--text-muted)';
      });
      
      // 선택된 서브탭 활성화
      btn.classList.add('active');
      btn.style.background = 'rgba(157, 140, 255, 0.12)';
      btn.style.borderColor = 'rgba(157, 140, 255, 0.3)';
      btn.style.color = 'var(--accent)';
      
      // 데바니온 정보 로드
      loadDaevanionInfo(boardId);
    });
  });
}

// 직업별 boardId 앞자리 매핑 (네자칸~아스펠 순: 1~6)
const JOB_BOARD_ID_PREFIX = {
  '검성': 1,      // 11~16
  '수호성': 2,    // 21~26
  '궁성': 3,      // 31~36
  '살성': 4,      // 41~46
  '정령성': 5,    // 51~56
  '마도성': 6,    // 61~66
  '치유성': 7,    // 71~76
  '호법성': 8     // 81~86
};

// boardId를 직업에 맞게 변환하는 함수
function convertBoardIdForJob(baseBoardId, jobName) {
  // baseBoardId의 뒷자리 추출 (1~6: 네자칸~아스펠)
  const boardSuffix = baseBoardId % 10;
  
  // 직업별 앞자리 가져오기 (기본값: 살성 = 4)
  const jobPrefix = JOB_BOARD_ID_PREFIX[jobName] || 4;
  
  // 새로운 boardId 생성 (앞자리 + 뒷자리)
  return jobPrefix * 10 + boardSuffix;
}

// 데바니온 정보 로드 함수
function loadDaevanionInfo(boardId) {
  if (!window.currentCharacterId || !window.currentServerId) {
    document.getElementById('daevanion-content').innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">캐릭터 정보가 없습니다.</div>';
    return;
  }
  
  // 저장된 데바니온 데이터가 있으면 API 호출 없이 사용
  if (window.daevanionData && window.daevanionData[boardId]) {
    const boardData = window.daevanionData[boardId];
    displayDaevanionInfo(boardData, boardId);
    return;
  }
  
  // 저장된 데이터가 없으면 API 호출 (fallback)
  document.getElementById('daevanion-content').innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">데바니온 정보를 불러오는 중...</div>';
  
  // 직업에 맞게 boardId 변환
  const jobName = window.currentJobName || '살성';
  const convertedBoardId = convertBoardIdForJob(parseInt(boardId), jobName);
  
  const params = new URLSearchParams();
  params.append('characterId', window.currentCharacterId);
  params.append('serverId', window.currentServerId);
  params.append('boardId', convertedBoardId.toString());
  params.append('lang', 'ko');
  
  fetch('/api/character/daevanion/detail?' + params.toString())
    .then(response => response.json())
    .then(data => {
      if (data.success && data.data) {
        const nodeList = data.data.nodeList || [];
        
        if (nodeList.length === 0) {
          document.getElementById('daevanion-content').innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">데바니온 노드 정보가 없습니다.</div>';
          return;
        }
        
        // 데바니온 데이터를 전역 변수에 저장 (스킬 breakdown 계산용)
        if (!window.daevanionData) {
          window.daevanionData = {};
        }
        window.daevanionData[boardId] = data.data;
        
        displayDaevanionInfo(data.data, boardId);
      } else {
        const errorMsg = data.error || '데바니온 정보를 불러올 수 없습니다.';
        document.getElementById('daevanion-content').innerHTML = `<div style="text-align: center; color: var(--text-muted); padding: 2rem;">${errorMsg}</div>`;
      }
    })
    .catch(error => {
      document.getElementById('daevanion-content').innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">데바니온 정보를 불러오는 중 오류가 발생했습니다.</div>';
    });
}

// 노드 색상에 따른 데바니온 결정 포인트 계산 함수
function calculateNodePoint(grade) {
  if (!grade) return 1;
  
  const gradeLower = String(grade).toLowerCase().trim();
  
  // 초록색 (rare): 2포인트
  if (gradeLower === 'rare') return 2;
  
  // 파란색 (legend/legendary): 3포인트
  if (gradeLower === 'legend' || gradeLower === 'legendary') return 3;
  
  // 노란색 (unique/유일): 4포인트
  if (gradeLower === 'unique' || gradeLower === '유일') return 4;
  
  // 기본값: 흰색 노드 (common/일반 등): 1포인트
  return 1;
}

// 모든 데바니온의 결정 포인트 정보 업데이트 함수 (최적화: 한 번만 호출)
// 중복 선언 방지
if (typeof daevanionPointsCache === 'undefined') {
  var daevanionPointsCache = null;
}
if (typeof isUpdatingDaevanionPoints === 'undefined') {
  var isUpdatingDaevanionPoints = false;
}

function updateAllDaevanionSkillPoints(forceRefresh = false) {
  if (!window.currentCharacterId || !window.currentServerId) {
    return;
  }
  
  // 이미 업데이트 중이면 중복 호출 방지 (단, 강제 갱신 시에는 허용)
  if (isUpdatingDaevanionPoints && !forceRefresh) {
    return;
  }
  
  // 포인트 정보 영역 숨기기 (계산 시작 시)
  const pointsInfo = document.getElementById('daevanion-points-info');
  if (pointsInfo) {
    pointsInfo.style.display = 'none';
  }
  
  isUpdatingDaevanionPoints = true;
  
  const jobName = window.currentJobName || '살성';
  const boardIds = [41, 42, 43, 44, 45, 46]; // 네자칸, 지켈, 바이젤, 트리니엘, 아리엘, 아스펠
  
  // 공유 포인트 (네자칸, 지켈, 바이젤, 트리니엘)
  let sharedPoints = 0;
  // 아리엘 전용 포인트
  let arielPoints = 0;
  // 아스펠 전용 포인트
  let aspelPoints = 0;
  
  let completedCount = 0;
  
  // 저장된 데바니온 데이터가 있으면 API 호출 없이 사용
  if (window.daevanionData && Object.keys(window.daevanionData).length > 0) {
    
    // 저장된 데이터로 포인트 계산
    boardIds.forEach((boardId) => {
      const boardData = window.daevanionData[boardId];
      if (!boardData) return;
      
      const nodeList = boardData.nodeList || [];
      
      // 활성화된 노드만 필터링 (open === 1) - 포인트 계산용
      const activeNodes = nodeList.filter(n => parseInt(n.open || 0) === 1);
            
            // 각 노드의 포인트 계산
            let boardPoints = 0;
            activeNodes.forEach(node => {
              const grade = node.grade || 'None';
              const point = calculateNodePoint(grade);
              boardPoints += point;
            });
            
            // 보드 타입에 따라 포인트 분류
            if (boardId === 45) { // 아리엘
              arielPoints = boardPoints;
            } else if (boardId === 46) { // 아스펠
              aspelPoints = boardPoints;
            } else { // 네자칸(41), 지켈(42), 바이젤(43), 트리니엘(44) - 공유 포인트
              sharedPoints += boardPoints;
            }
            
            // 서브탭 버튼 업데이트 (활성화된 노드 개수 표시)
            const subtabBtn = document.querySelector(`.daevanion-subtab-btn[data-boardid="${boardId}"]`);
            if (subtabBtn) {
              const boardNames = {
                41: '네자칸',
                42: '지켈',
                43: '바이젤',
                44: '트리니엘',
                45: '아리엘',
                46: '아스펠'
              };
              const boardName = boardNames[boardId] || '';
              const activeCount = activeNodes.length;
              let maxCount = 88;
              if (boardId === 44) maxCount = 116;
              else if (boardId === 45 || boardId === 46) maxCount = 152;
              subtabBtn.textContent = `${boardName} (${activeCount}/${maxCount})`;
            }
    });
    
    // 모든 보드 처리 완료 후 포인트 정보 표시 및 계산
    displayDaevanionPoints(sharedPoints, arielPoints, aspelPoints);
    
    // 데바니온 데이터가 준비되었으므로 모든 스탯을 다시 계산하고 전투 점수 계산
    if (window.currentEquipment && window.currentAccessories && window.currentStatData) {
      // 공격력 계산 (데바니온 데이터 포함)
      const attackPowerResult = calculateAttackPowerWithDaevanion(
        window.currentEquipment,
        window.currentAccessories,
        window.currentStatData,
        window.daevanionData
      );
      
      // 전투 속도 계산 (데바니온 데이터 포함)
      calculateCombatSpeed(window.currentEquipment, window.currentAccessories, window.currentStatData, window.daevanionData, window.currentTitles || []);
      
      // 피해 증폭 계산 (데바니온 데이터 포함)
      calculateDamageAmplification(window.currentEquipment, window.currentAccessories, window.daevanionData, window.currentTitles || []);
      
      // 재사용 대기 시간 감소 계산 (데바니온 데이터 포함)
      calculateCooldownReduction(window.currentStatData, window.daevanionData, window.currentTitles || []);
      
      // 다단 히트 적중 계산 (데바니온 데이터 포함)
      calculateMultiHit(window.currentEquipment, window.currentAccessories, window.daevanionData);
      
      // 모든 스탯 계산이 완료되었으므로 전투 점수 계산
      // 검색 ID를 캡처하여 동시 검색 시 데이터 충돌 방지
      const daevanionSearchId = window.currentSearchId;
      setTimeout(() => {
        // 검색 ID가 변경되었으면 다른 캐릭터 검색이 진행 중이므로 무시
        if (daevanionSearchId !== window.currentSearchId) return;
        calculateDpsScore(daevanionSearchId);
      }, 100);
    }
    
    // 데바니온 포인트 표시 후 랭킹 정보 업데이트
    // 캐릭터 정보를 클로저로 캡처 (동시 검색 시 데이터 충돌 방지)
    const daevanionNickname = window.currentCharacterNickname;
    const daevanionServer = window.currentCharacterServer;
    const daevanionRace = window.currentCharacterRace;
    const daevanionSearchIdForRanking = window.currentSearchId;
    if (daevanionNickname && daevanionServer && daevanionRace) {
      setTimeout(() => {
        // 검색 ID 검증
        if (daevanionSearchIdForRanking !== window.currentSearchId) return;
        loadCharacterRankingInfo(daevanionNickname, daevanionServer, daevanionRace);
      }, 100);
    }
    
    // 캐릭터 정보 로그에 데바니온 포인트 추가 출력
    if (window.logCharacterInfoCalled) {
      // DB에 저장
      if (daevanionNickname && daevanionServer && daevanionRace) {
        // 캡처된 캐릭터 정보 (동시 검색 시 데이터 충돌 방지)
        const capturedInfo = {
          nickname: daevanionNickname,
          server: daevanionServer,
          race: daevanionRace
        };
        updateCharacterInfoInDB({
          total_stat_value: window.currentTotalStatValue || null,
          stigma_shards: window.currentStigmaShards || null,
          title_count: window.currentTitleCount || null,
          arcana_set_option: window.currentArcanaSetOption || null,
          weapon_names: window.currentWeaponNames || null,
          armor_names: window.currentArmorNames || null,
          accessory_names: window.currentAccessoryNames || null,
          daevanion_crystal: sharedPoints,
          daevanion_crystal_ariel: arielPoints,
          daevanion_crystal_aspel: aspelPoints,
          soul_score: window.currentSoulScore || null
        }, capturedInfo);
      }
    }
    
    isUpdatingDaevanionPoints = false;
  } else {
    // 저장된 데이터가 없으면 기존 API 호출 방식 사용 (fallback)
    boardIds.forEach((boardId, index) => {
      const convertedBoardId = convertBoardIdForJob(boardId, jobName);
      
      setTimeout(() => {
        const params = new URLSearchParams();
        params.append('characterId', window.currentCharacterId);
        params.append('serverId', window.currentServerId);
        params.append('boardId', convertedBoardId.toString());
        params.append('lang', 'ko');
        
        fetch('/api/character/daevanion/detail?' + params.toString())
          .then(response => response.json())
          .then(data => {
            if (data.success && data.data) {
              // 데바니온 데이터를 전역 변수에 저장 (스킬 breakdown 계산용)
              if (!window.daevanionData) {
                window.daevanionData = {};
              }
              window.daevanionData[boardId] = data.data;
              
              const nodeList = data.data.nodeList || [];
              
              // 활성화된 노드만 필터링 (open === 1)
              const activeNodes = nodeList.filter(n => parseInt(n.open || 0) === 1);
              
              // 각 노드의 포인트 계산
              let boardPoints = 0;
              activeNodes.forEach(node => {
                const grade = node.grade || 'None';
                const point = calculateNodePoint(grade);
                boardPoints += point;
              });
              
              // 보드 타입에 따라 포인트 분류
              if (boardId === 45) { // 아리엘
                arielPoints = boardPoints;
              } else if (boardId === 46) { // 아스펠
                aspelPoints = boardPoints;
              } else { // 네자칸(41), 지켈(42), 바이젤(43), 트리니엘(44) - 공유 포인트
                sharedPoints += boardPoints;
              }
              
              // 서브탭 버튼 업데이트 (활성화된 노드 개수 표시)
              const subtabBtn = document.querySelector(`.daevanion-subtab-btn[data-boardid="${boardId}"]`);
              if (subtabBtn) {
                const boardNames = {
                  41: '네자칸',
                  42: '지켈',
                  43: '바이젤',
                  44: '트리니엘',
                  45: '아리엘',
                  46: '아스펠'
                };
                const boardName = boardNames[boardId] || '';
                const activeCount = activeNodes.length;
                let maxCount = 88;
                if (boardId === 44) maxCount = 116;
                else if (boardId === 45 || boardId === 46) maxCount = 152;
                subtabBtn.textContent = `${boardName} (${activeCount}/${maxCount})`;
              }
            }
            
            completedCount++;
            if (completedCount === boardIds.length) {
              // 모든 데바니온 정보 수집 완료 - 포인트 정보 표시
              displayDaevanionPoints(sharedPoints, arielPoints, aspelPoints);
              
              // 데바니온 데이터가 준비되었으므로 모든 스탯을 다시 계산하고 전투 점수 계산
              if (window.currentEquipment && window.currentAccessories && window.currentStatData) {
                // 공격력 계산 (데바니온 데이터 포함)
                const attackPowerResult = calculateAttackPowerWithDaevanion(
                  window.currentEquipment,
                  window.currentAccessories,
                  window.currentStatData,
                  window.daevanionData
                );
                
                // 전투 속도 계산 (데바니온 데이터 포함)
                calculateCombatSpeed(window.currentEquipment, window.currentAccessories, window.currentStatData, window.daevanionData, window.currentTitles || []);
                
                // 피해 증폭 계산 (데바니온 데이터 포함)
                calculateDamageAmplification(window.currentEquipment, window.currentAccessories, window.daevanionData, window.currentTitles || []);
                
                // 재사용 대기 시간 감소 계산 (데바니온 데이터 포함)
                calculateCooldownReduction(window.currentStatData, window.daevanionData, window.currentTitles || []);
                
                // 모든 스탯 계산이 완료되었으므로 전투 점수 계산
                // 검색 ID를 캡처하여 동시 검색 시 데이터 충돌 방지
                const fallbackSearchId = window.currentSearchId;
                setTimeout(() => {
                  // 검색 ID가 변경되었으면 다른 캐릭터 검색이 진행 중이므로 무시
                  if (fallbackSearchId !== window.currentSearchId) return;
                  calculateDpsScore(fallbackSearchId);
                }, 100);
              } else {
              }
              
              // 데바니온 포인트 표시 후 랭킹 정보 업데이트
              // 캐릭터 정보를 클로저로 캡처 (동시 검색 시 데이터 충돌 방지)
              const fallbackNickname = window.currentCharacterNickname;
              const fallbackServer = window.currentCharacterServer;
              const fallbackRace = window.currentCharacterRace;
              const fallbackSearchIdForRanking = window.currentSearchId;
              if (fallbackNickname && fallbackServer && fallbackRace) {
                setTimeout(() => {
                  // 검색 ID 검증
                  if (fallbackSearchIdForRanking !== window.currentSearchId) return;
                  loadCharacterRankingInfo(fallbackNickname, fallbackServer, fallbackRace);
                }, 100);
              }
              
              // 캐릭터 정보 로그에 데바니온 포인트 추가 출력
              if (window.logCharacterInfoCalled) {
                
                // DB에 저장
                if (fallbackNickname && fallbackServer && fallbackRace) {
                  // 캡처된 캐릭터 정보 (동시 검색 시 데이터 충돌 방지)
                  const capturedInfo = {
                    nickname: fallbackNickname,
                    server: fallbackServer,
                    race: fallbackRace
                  };
                  updateCharacterInfoInDB({
                    total_stat_value: window.currentTotalStatValue || null,
                    stigma_shards: window.currentStigmaShards || null,
                    title_count: window.currentTitleCount || null,
                    arcana_set_option: window.currentArcanaSetOption || null,
                    weapon_names: window.currentWeaponNames || null,
                    armor_names: window.currentArmorNames || null,
                    accessory_names: window.currentAccessoryNames || null,
                    daevanion_crystal: sharedPoints,
                    daevanion_crystal_ariel: arielPoints,
                    daevanion_crystal_aspel: aspelPoints,
                    soul_score: window.currentSoulScore || null
                  }, capturedInfo);
                }
              }
              
              isUpdatingDaevanionPoints = false;
            }
          })
          .catch(error => {
            completedCount++;
            if (completedCount === boardIds.length) {
              displayDaevanionPoints(sharedPoints, arielPoints, aspelPoints);
              
              // 데바니온 포인트 표시 후 랭킹 정보 업데이트
              if (window.currentCharacterNickname && window.currentCharacterServer && window.currentCharacterRace) {
                setTimeout(() => {
                  loadCharacterRankingInfo(window.currentCharacterNickname, window.currentCharacterServer, window.currentCharacterRace);
                }, 100);
              }
              
              // 캐릭터 정보 로그에 데바니온 포인트 추가 출력
              if (window.logCharacterInfoCalled) {
                
                // DB에 저장 (fallback 캡처 변수 사용 - 동시 검색 시 데이터 충돌 방지)
                if (fallbackNickname && fallbackServer && fallbackRace) {
                  const capturedInfo = {
                    nickname: fallbackNickname,
                    server: fallbackServer,
                    race: fallbackRace
                  };
                  updateCharacterInfoInDB({
                    total_stat_value: window.currentTotalStatValue || null,
                    stigma_shards: window.currentStigmaShards || null,
                    title_count: window.currentTitleCount || null,
                    arcana_set_option: window.currentArcanaSetOption || null,
                    weapon_names: window.currentWeaponNames || null,
                    armor_names: window.currentArmorNames || null,
                    accessory_names: window.currentAccessoryNames || null,
                    daevanion_crystal: sharedPoints,
                    daevanion_crystal_ariel: arielPoints,
                    daevanion_crystal_aspel: aspelPoints,
                    soul_score: window.currentSoulScore || null
                  }, capturedInfo);
                }
              }
              
              isUpdatingDaevanionPoints = false;
            }
          });
      }, index * 200); // 각 요청 사이에 200ms 딜레이
    });
  }
}

// 캐릭터 랭킹 정보 로드 함수
function loadCharacterRankingInfo(nickname, server, race) {
  const params = new URLSearchParams({
    nickname: nickname,
    server: server,
    race: race
  });
  
  fetch(`/api/character/ranking-info?${params}`)
    .then(response => response.json())
    .then(data => {
      if (!data.success || !data.data) {
        return;
      }
      
      const rankingInfo = data.data;
      
      // 랭킹 정보를 HTML로 생성하는 헬퍼 함수
      function createRankText(rankInfo) {
        const rankSpan = `<span style="color: #fbbf24; font-weight: 600; margin-left: 0.3rem;">전서버 ${rankInfo.rank.toLocaleString()}위</span>`;
        const percentSpan = `<span style="color: #8b95b5; font-size: 0.85em; margin-left: 0.3rem;">(상위 ${rankInfo.top_percent}%)</span>`;
        return ` ${rankSpan}${percentSpan}`;
      }
      
      // 기존 랭킹 정보를 제거하는 헬퍼 함수
      function removeExistingRankInfo(html) {
        // 전서버로 시작하는 span 태그와 (상위로 시작하는 span 태그 모두 제거
        return html.replace(/\s*<span[^>]*>전서버\s*[\d,]+위<\/span>/gi, '')
                   .replace(/\s*<span[^>]*>\(상위\s*[\d.]+%\)<\/span>/gi, '')
                   .replace(/\s*전서버\s*[\d,]+위/gi, '')
                   .replace(/\s*\(상위\s*[\d.]+%\)/gi, '');
      }
      
      // 타이틀 랭킹 정보 업데이트
      if (rankingInfo.title_count) {
        const titleSummaryEl = document.getElementById('title-summary');
        if (titleSummaryEl) {
          // 기존 랭킹 정보 제거
          let currentHTML = titleSummaryEl.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          const rankText = createRankText(rankingInfo.title_count);
          titleSummaryEl.innerHTML = currentHTML + rankText;
        }
      }
      
      // 스티그마 샤드 랭킹 정보 업데이트
      if (rankingInfo.stigma_shards) {
        const stigmaHeader = document.getElementById('stigma-header');
        if (stigmaHeader) {
          // 기존 랭킹 정보 제거 후 추가
          let currentHTML = stigmaHeader.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          const rankText = createRankText(rankingInfo.stigma_shards);
          stigmaHeader.innerHTML = currentHTML + rankText;
        }
      }
      
      // 스탯 총합 랭킹 정보 업데이트
      if (rankingInfo.total_stat_value) {
        const statsHeader = document.getElementById('stats-header');
        if (statsHeader) {
          // 기존 랭킹 정보 제거 후 추가
          let currentHTML = statsHeader.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          const rankText = createRankText(rankingInfo.total_stat_value);
          statsHeader.innerHTML = currentHTML + rankText;
        }
      }
      
      // 데바니온 결정 랭킹 정보 업데이트
      if (rankingInfo.daevanion_crystal) {
        const rankText = createRankText(rankingInfo.daevanion_crystal);
        
        // 데스크톱 버전 (모바일에서도 사용)
        const sharedInfoDesktop = document.getElementById('daevanion-shared-points-desktop');
        if (sharedInfoDesktop) {
          let currentHTML = sharedInfoDesktop.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          sharedInfoDesktop.innerHTML = currentHTML + rankText;
        }
        
        // 모바일 버전
        const sharedInfoMobile = document.getElementById('daevanion-shared-points-mobile');
        if (sharedInfoMobile) {
          let currentHTML = sharedInfoMobile.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          sharedInfoMobile.innerHTML = currentHTML + rankText;
        }
      }
      
      // 데바니온 결정 - 아리엘 랭킹 정보 업데이트
      if (rankingInfo.daevanion_crystal_ariel) {
        const rankText = createRankText(rankingInfo.daevanion_crystal_ariel);
        
        // 데스크톱 버전 (모바일에서도 사용)
        const arielInfoDesktop = document.getElementById('daevanion-ariel-points-desktop');
        if (arielInfoDesktop) {
          let currentHTML = arielInfoDesktop.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          arielInfoDesktop.innerHTML = currentHTML + rankText;
        }
        
        // 모바일 버전
        const arielInfoMobile = document.getElementById('daevanion-ariel-points-mobile');
        if (arielInfoMobile) {
          let currentHTML = arielInfoMobile.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          arielInfoMobile.innerHTML = currentHTML + rankText;
        }
      }
      
      // 데바니온 결정 - 아스펠 랭킹 정보 업데이트
      if (rankingInfo.daevanion_crystal_aspel) {
        const rankText = createRankText(rankingInfo.daevanion_crystal_aspel);
        
        // 데스크톱 버전 (모바일에서도 사용)
        const aspelInfoDesktop = document.getElementById('daevanion-aspel-points-desktop');
        if (aspelInfoDesktop) {
          let currentHTML = aspelInfoDesktop.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          aspelInfoDesktop.innerHTML = currentHTML + rankText;
        }
        
        // 모바일 버전
        const aspelInfoMobile = document.getElementById('daevanion-aspel-points-mobile');
        if (aspelInfoMobile) {
          let currentHTML = aspelInfoMobile.innerHTML;
          currentHTML = removeExistingRankInfo(currentHTML);
          aspelInfoMobile.innerHTML = currentHTML + rankText;
        }
      }
    })
    .catch(error => {
    });
}

// 데바니온 결정 포인트 정보 표시 함수
function displayDaevanionPoints(sharedPoints, arielPoints, aspelPoints) {
  // 전역 변수에 포인트 정보 저장 (모바일에서 보드 그린 후 재사용)
  window.daevanionSharedPoints = sharedPoints;
  window.daevanionArielPoints = arielPoints;
  window.daevanionAspelPoints = aspelPoints;
  
  const subtabsContainer = document.querySelector('.daevanion-subtabs');
  if (!subtabsContainer) return;
  
  // 모바일 감지
  const isMobile = window.innerWidth <= 768;
  
  // 기존 포인트 정보 제거
  const existingInfo = document.getElementById('daevanion-points-info');
  if (existingInfo) {
    existingInfo.remove();
  }
  
  // 포인트 정보 컨테이너 생성
  const pointsInfo = document.createElement('div');
  pointsInfo.id = 'daevanion-points-info';
  
  if (isMobile) {
    // 모바일: 보드 아래에 표시
    const daevanionContent = document.getElementById('daevanion-content');
    if (!daevanionContent) return;
    
    pointsInfo.style.cssText = `
      display: block;
      width: 100%;
      padding: 1rem;
      margin-top: 1rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    `;
    
    // 타이틀
    const title = document.createElement('div');
    title.style.cssText = 'font-size: 0.9rem; color: var(--text-muted); font-weight: 600; margin-bottom: 0.75rem; text-align: center;';
    title.textContent = '투자된 포인트';
    pointsInfo.appendChild(title);
    
    // 포인트 정보 컨테이너
    const pointsContainer = document.createElement('div');
    pointsContainer.style.cssText = 'display: flex; flex-direction: column; gap: 0.5rem;';
    
    // 공유 포인트 표시
    const sharedInfo = document.createElement('div');
    sharedInfo.className = 'daevanion-shared-points';
    sharedInfo.id = 'daevanion-shared-points-desktop';
    sharedInfo.style.cssText = 'font-size: 0.85rem; color: var(--text-primary); font-weight: 500; text-align: center;';
    sharedInfo.innerHTML = `데바니온 결정: ${sharedPoints}`;
    pointsContainer.appendChild(sharedInfo);
    
    // 아리엘 포인트 표시
    const arielInfo = document.createElement('div');
    arielInfo.className = 'daevanion-ariel-points';
    arielInfo.id = 'daevanion-ariel-points-desktop';
    arielInfo.style.cssText = 'font-size: 0.85rem; color: var(--text-primary); font-weight: 500; text-align: center;';
    arielInfo.innerHTML = `데바니온 결정 - 아리엘: ${arielPoints}`;
    pointsContainer.appendChild(arielInfo);
    
    // 아스펠 포인트 표시
    const aspelInfo = document.createElement('div');
    aspelInfo.className = 'daevanion-aspel-points';
    aspelInfo.id = 'daevanion-aspel-points-desktop';
    aspelInfo.style.cssText = 'font-size: 0.85rem; color: var(--text-primary); font-weight: 500; text-align: center;';
    aspelInfo.innerHTML = `데바니온 결정 - 아스펠: ${aspelPoints}`;
    pointsContainer.appendChild(aspelInfo);
    
    pointsInfo.appendChild(pointsContainer);
    
    // 보드 컨테이너 다음에 추가
    const boardContainer = daevanionContent.querySelector('.daevanion-board-container');
    if (boardContainer && boardContainer.nextSibling) {
      daevanionContent.insertBefore(pointsInfo, boardContainer.nextSibling);
    } else {
      daevanionContent.appendChild(pointsInfo);
    }
  } else {
    // 데스크톱: 서브탭 옆에 표시
    const aspelBtn = document.querySelector('.daevanion-subtab-btn[data-boardid="46"]');
    if (!aspelBtn) return;
    
    pointsInfo.style.cssText = 'flex: 1; display: flex; flex-direction: column; align-items: flex-end; justify-content: flex-start; gap: 0.25rem; margin-left: auto;';
    
    // 타이틀
    const title = document.createElement('div');
    title.style.cssText = 'font-size: 0.75rem; color: var(--text-muted); font-weight: 500; margin-bottom: 0.25rem;';
    title.textContent = '투자된 포인트';
    pointsInfo.appendChild(title);
    
    // 공유 포인트 표시
    const sharedInfo = document.createElement('div');
    sharedInfo.className = 'daevanion-shared-points';
    sharedInfo.id = 'daevanion-shared-points-mobile';
    sharedInfo.style.cssText = 'font-size: 0.85rem; color: var(--text-primary); font-weight: 500; text-align: right;';
    sharedInfo.innerHTML = `데바니온 결정: ${sharedPoints}`;
    pointsInfo.appendChild(sharedInfo);
    
    // 아리엘 포인트 표시
    const arielInfo = document.createElement('div');
    arielInfo.className = 'daevanion-ariel-points';
    arielInfo.id = 'daevanion-ariel-points-mobile';
    arielInfo.style.cssText = 'font-size: 0.85rem; color: var(--text-primary); font-weight: 500; text-align: right;';
    arielInfo.innerHTML = `데바니온 결정 - 아리엘: ${arielPoints}`;
    pointsInfo.appendChild(arielInfo);
    
    // 아스펠 포인트 표시
    const aspelInfo = document.createElement('div');
    aspelInfo.className = 'daevanion-aspel-points';
    aspelInfo.id = 'daevanion-aspel-points-mobile';
    aspelInfo.style.cssText = 'font-size: 0.85rem; color: var(--text-primary); font-weight: 500; text-align: right;';
    aspelInfo.innerHTML = `데바니온 결정 - 아스펠: ${aspelPoints}`;
    pointsInfo.appendChild(aspelInfo);
    
    // 서브탭 컨테이너에 추가 (아스펠 버튼 다음에)
    subtabsContainer.appendChild(pointsInfo);
  }
}

// [수정됨] 데바니온 정보 표시 함수
function displayDaevanionInfo(data, boardId) {
  const container = document.getElementById('daevanion-content');
  
  // 모바일에서 포인트 정보 보존 (innerHTML로 지우기 전에)
  const isMobileForPoints = window.innerWidth <= 768;
  let pointsInfoElement = null;
  if (isMobileForPoints) {
    pointsInfoElement = document.getElementById('daevanion-points-info');
    // 포인트 정보를 임시로 제거 (나중에 다시 추가하기 위해)
    if (pointsInfoElement && pointsInfoElement.parentElement) {
      pointsInfoElement.parentElement.removeChild(pointsInfoElement);
    }
  }
  
  container.innerHTML = '';
  
  if (!data || typeof data !== 'object') {
    container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">데바니온 정보가 없습니다.</div>';
    // 모바일에서 포인트 정보 다시 추가
    if (isMobileForPoints && pointsInfoElement) {
      container.appendChild(pointsInfoElement);
    }
    return;
  }
  
  const nodeList = data.nodeList || [];
  const boardInfo = data.boardInfo || {};
  
  // 보드 크기 정보 가져오기
  const boardRows = boardInfo.rows || 0;
  const boardCols = boardInfo.cols || 0;
  const startRow = boardInfo.startRow || 9;
  const startCol = boardInfo.startCol || 9;
  
  // 정중앙 노드 위치 계산 (보드 크기에 따라)
  let centerRow, centerCol;
  if (boardRows > 0 && boardCols > 0) {
    // 보드 크기가 있으면 정중앙 계산
    centerRow = Math.floor(boardRows / 2);
    centerCol = Math.floor(boardCols / 2);
  } else {
    // 보드 크기 정보가 없으면 startRow, startCol 사용 (기본값 9, 9)
    centerRow = startRow;
    centerCol = startCol;
  }
  
  // 모든 노드 표시 (비활성 노드 포함) - grade가 'None'이 아닌 노드만 (빈 공간 제외)
  const validNodes = nodeList.filter(n => {
    const grade = n.grade || 'None';
    const isValid = grade !== 'None';
    
    return isValid;
  });
  
  if (validNodes.length === 0) {
    container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">노드 정보가 없습니다.</div>';
    return;
  }
  
  // 정중앙 노드 찾기
  const centerNode = nodeList.find(n => {
    const row = parseInt(n.row || 0);
    const col = parseInt(n.col || 0);
    return row === centerRow && col === centerCol;
  });
  
  // 실제 데이터가 있는 영역의 min/max 계산
  let minRow = Infinity;
  let maxRow = -Infinity;
  let minCol = Infinity;
  let maxCol = -Infinity;
  
  validNodes.forEach(n => {
    const row = parseInt(n.row || 0);
    const col = parseInt(n.col || 0);
    if (row < minRow) minRow = row;
    if (row > maxRow) maxRow = row;
    if (col < minCol) minCol = col;
    if (col > maxCol) maxCol = col;
  });
  
  // 정중앙 노드가 있으면 min/max 계산에 포함
  if (centerNode) {
    if (centerRow < minRow) minRow = centerRow;
    if (centerRow > maxRow) maxRow = centerRow;
    if (centerCol < minCol) minCol = centerCol;
    if (centerCol > maxCol) maxCol = centerCol;
  }
  
  // 실제 보여야 할 영역 크기 계산
  const actualRows = maxRow - minRow + 1;
  const actualCols = maxCol - minCol + 1;
  
  
  // 모바일 감지
  const isMobile = window.innerWidth <= 768;
  const isSmallMobile = window.innerWidth <= 480;
  
  // boardId를 숫자로 변환
  const boardIdNum = parseInt(boardId) || 0;
  
  // 모바일에서 노드 크기 조정 (매우 작게 - 화면에 맞춰 자동 계산)
  let nodeSize, nodeGap, nodePadding, nodeFontSize;
  
  if (isSmallMobile) {
    // 작은 모바일: 화면 너비에 맞춰 자동 계산 (매우 작게)
    const screenWidth = window.innerWidth - 40; // 좌우 패딩 20px씩
    const maxCols = Math.max(actualCols, 1);
    // 큰 보드(트리니엘, 아리엘, 아스펠)는 더 작게
    const isLargeBoard = actualCols > 10 || actualRows > 10 || boardIdNum == 44 || boardIdNum == 45 || boardIdNum == 46;
    if (isLargeBoard) {
      nodeSize = Math.floor((screenWidth - (maxCols - 1) * 1) / maxCols);
      nodeSize = Math.max(12, Math.min(nodeSize, 18)); // 큰 보드는 더 작게
    } else {
      nodeSize = Math.floor((screenWidth - (maxCols - 1) * 1) / maxCols);
      nodeSize = Math.max(14, Math.min(nodeSize, 22)); // 작은 보드도 작게
    }
    nodeGap = 1;
    nodePadding = '0.25rem';
    nodeFontSize = isLargeBoard ? '4px' : '5px';
  } else if (isMobile) {
    // 모바일: 화면 너비에 맞춰 자동 계산 (큰 보드 고려)
    const screenWidth = window.innerWidth - 56; // 좌우 패딩 28px씩
    const maxCols = Math.max(actualCols, 1);
    // 큰 보드(트리니엘, 아리엘, 아스펠 등)는 더 작게
    const isLargeBoard = actualCols > 10 || actualRows > 10 || boardIdNum == 44 || boardIdNum == 45 || boardIdNum == 46;
    if (isLargeBoard) {
      nodeSize = Math.floor((screenWidth - (maxCols - 1) * 1) / maxCols);
      nodeSize = Math.max(14, Math.min(nodeSize, 22)); // 큰 보드는 더 작게
    } else {
      nodeSize = Math.floor((screenWidth - (maxCols - 1) * 1) / maxCols);
      nodeSize = Math.max(16, Math.min(nodeSize, 24)); // 작은 보드도 작게
    }
    nodeGap = 1;
    nodePadding = '0.5rem';
    nodeFontSize = isLargeBoard ? '5px' : '6px';
  } else {
    // 데스크톱
    nodeSize = 75;
    nodeGap = 8;
    nodePadding = '1.5rem';
    nodeFontSize = '12px';
  }
  
  // 보드 컨테이너 (CSS Grid) - 실제 데이터 영역만 표시
  const boardContainer = document.createElement('div');
  boardContainer.className = 'daevanion-board-container';
  
  // 모바일에서 보드 크기 제한 (큰 보드는 더 작게)
  const isLargeBoard = actualCols > 10 || actualRows > 10 || boardIdNum == 44 || boardIdNum == 45 || boardIdNum == 46;
  const maxBoardWidth = isMobile ? (isLargeBoard ? '95vw' : '98vw') : '100%';
  
  boardContainer.style.cssText = `
    display: grid;
    grid-template-rows: repeat(${actualRows}, ${nodeSize}px);
    grid-template-columns: repeat(${actualCols}, ${nodeSize}px);
    gap: ${nodeGap}px;
    padding: ${nodePadding};
    background: rgba(0, 0, 0, 0.2);
    border-radius: ${isMobile ? '8px' : '16px'};
    justify-content: flex-start;
    max-width: ${maxBoardWidth};
    overflow-x: visible;
    overflow-y: visible;
    width: fit-content;
    box-sizing: border-box;
    margin: 0 auto;
  `;
  
  // 정중앙 노드 렌더링 (직업 로고 표시)
  if (centerNode || true) { // centerNode가 없어도 정중앙에 표시
    const relativeRow = centerRow - minRow + 1;
    const relativeCol = centerCol - minCol + 1;
    
    const centerNodeDiv = document.createElement('div');
    centerNodeDiv.style.cssText = `
      grid-row: ${relativeRow};
      grid-column: ${relativeCol};
      display: ${isMobile ? 'block' : 'flex'};
      align-items: center;
      justify-content: center;
      width: ${nodeSize}px;
      height: ${nodeSize}px;
      position: relative;
      border-radius: ${isMobile ? '4px' : '10px'};
      background: #000000;
      border: ${isMobile ? '1px' : '2px'} solid rgba(255, 255, 255, 0.3);
      padding: ${isMobile ? '2px' : '8px'};
    `;
    
    // 직업 이미지 URL 가져오기
    const jobImageUrl = window.currentJobImageUrl || '';
    
    if (jobImageUrl) {
      const jobImage = document.createElement('img');
      jobImage.src = jobImageUrl;
      jobImage.alt = window.currentJobName || '직업';
      jobImage.style.cssText = `
        width: 100%;
        height: 100%;
        object-fit: contain;
        pointer-events: none;
      `;
      centerNodeDiv.appendChild(jobImage);
    } else {
      // 이미지가 없으면 직업 이름 표시
      const jobNameText = document.createElement('div');
      jobNameText.textContent = window.currentJobName || '?';
      jobNameText.style.cssText = `
        color: rgba(255, 255, 255, 0.8);
        font-size: ${isMobile ? '10px' : '14px'};
        font-weight: 600;
        text-align: center;
        pointer-events: none;
      `;
      centerNodeDiv.appendChild(jobNameText);
    }
    
    centerNodeDiv.title = `시작 노드\n직업: ${window.currentJobName || '미확인'}`;
    centerNodeDiv.style.cursor = 'default';
    
    boardContainer.appendChild(centerNodeDiv);
  }
  
  // 각 노드 배치 (유효한 노드만 렌더링, 중앙 노드 제외)
  let renderedCount = 0;
  validNodes.forEach((node) => {
    if (typeof node !== 'object' || node === null) return;
    
    const originalRow = parseInt(node.row || 0);
    const originalCol = parseInt(node.col || 0);
    
    // 정중앙 노드는 이미 렌더링했으므로 건너뜀
    if (originalRow === centerRow && originalCol === centerCol) {
      return;
    }
    
    // 실제 데이터 영역 기준으로 상대 좌표 계산 (1부터 시작)
    const relativeRow = originalRow - minRow + 1;
    const relativeCol = originalCol - minCol + 1;
    
    const grade = node.grade || 'None';
    const isOpen = parseInt(node.open || 0);
    const name = node.name || '';
    const effectList = node.effectList || [];
    
    // [이미지 제거] 아이콘 이미지 관련 코드 모두 제거 - 이미지 사용 안 함
    
    // 효과 이름과 수치 추출 (effectList의 desc 값) - 활성/비활성 모두에서 추출
    let effectName = '';
    if (effectList.length > 0) {
      // effectList의 모든 항목을 확인하여 desc 찾기
      for (const effect of effectList) {
        if (effect && effect.desc) {
          effectName = effect.desc;
          break; // 첫 번째 desc 사용
        }
      }
    }
    
    // effectName이 없으면 name에서 수치 정보 추출 시도
    // name에 "+ 숫자" 패턴이 있으면 그대로 사용
    if (!effectName && name) {
      // name에 수치가 포함되어 있는지 확인 (예: "생명력 +100", "정신력 +50")
      if (name.includes('+') || name.includes('＋')) {
        effectName = name;
      } else {
        // name에 수치가 없어도 name 자체를 표시 (예: "최대 생명력", "최대 정신력")
        effectName = name;
      }
    }
    
    // 등급 색상 가져오기
    const gradeColor = getGradeColor(grade);
    
    // 노드 아이템 생성
    const nodeDiv = document.createElement('div');
    
    // 노드 스타일 설정 (활성/비활성 구분)
    let borderColor = 'rgba(255, 255, 255, 0.1)';
    let backgroundColor = 'rgba(255, 255, 255, 0.05)';
    let opacity = '1';
    let textColor = 'var(--text-muted)';
    
    if (isOpen === 1 && gradeColor) {
      // 활성화된 노드는 등급 색상으로 테두리
      borderColor = gradeColor;
      // 배경은 약간 투명하게 (hex 색상을 rgba로 변환)
      const hexToRgba = (hex, alpha) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      };
      backgroundColor = hexToRgba(gradeColor, 0.15);
      opacity = '1';
      textColor = gradeColor;
    } else {
      // 비활성 노드는 회색으로 표시
      borderColor = 'rgba(128, 128, 128, 0.3)';
      backgroundColor = 'rgba(64, 64, 64, 0.1)';
      opacity = '0.5';  // 비활성 노드는 반투명
      textColor = 'rgba(128, 128, 128, 0.7)';
    }
    
    nodeDiv.style.cssText = `
      grid-row: ${relativeRow};
      grid-column: ${relativeCol};
      display: ${isMobile ? 'block' : 'flex'};
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: ${nodeSize}px;
      height: ${nodeSize}px;
      position: relative;
      border-radius: ${isMobile ? '4px' : '10px'};
      transition: transform 0.2s;
      padding: ${isMobile ? '1px' : '4px'};
      border: ${isMobile ? '1px' : '2px'} solid ${borderColor};
      background: ${backgroundColor};
      opacity: ${opacity};
    `;
    
    // 텍스트를 배치하기 위한 컨테이너
    const contentWrapper = document.createElement('div');
    contentWrapper.style.cssText = `
      display: block;
      width: 100%;
      height: 100%;
      padding: ${isMobile ? '1px' : '2px'};
      text-align: center;
      vertical-align: middle;
    `;
    
    // [이미지 제거] 아이콘 이미지 생성 코드 제거 - 이미지 사용 안 함
    
    // 텍스트 표시 (모든 노드에 이름과 수치 표시, 비활성 노드도 포함)
    // effectName이 있으면 표시, 없으면 name 표시
    const displayText = effectName || name || '';
    if (displayText) {
      const textDiv = document.createElement('div');
      textDiv.style.cssText = `
        font-size: ${nodeFontSize};
        color: ${isOpen === 1 ? (gradeColor || 'var(--text-primary)') : textColor};
        text-align: center;
        line-height: 1.3;
        pointer-events: none;
        width: 100%;
        overflow: visible;
        font-weight: ${isOpen === 1 ? '700' : '500'};
        text-shadow: ${isOpen === 1 ? '0 1px 3px rgba(0, 0, 0, 0.9), 0 0 2px rgba(0, 0, 0, 0.8)' : 'none'};
        word-break: break-word;
        padding: 0 ${isMobile ? '2px' : '4px'};
        letter-spacing: ${isMobile ? '0.1px' : '0.3px'};
        display: block;
        white-space: normal;
        max-height: none;
      `;
      
      textDiv.textContent = displayText;
      contentWrapper.appendChild(textDiv);
    }
    
    nodeDiv.appendChild(contentWrapper);
    
    // 호버 효과 및 툴팁
    nodeDiv.style.cursor = 'pointer';
    nodeDiv.title = `${name || ''} \n[${grade}] ${isOpen ? '활성화' : '잠김'} \n위치: (${originalRow}, ${originalCol})${effectName ? `\n효과: ${effectName}` : ''}`;
    
    nodeDiv.onmouseenter = () => { 
      nodeDiv.style.transform = 'scale(1.15)';
      nodeDiv.style.zIndex = '10';
    };
    nodeDiv.onmouseleave = () => { 
      nodeDiv.style.transform = 'scale(1)';
      nodeDiv.style.zIndex = '1';
    };
    
    boardContainer.appendChild(nodeDiv);
    renderedCount++;
  });
  
  container.appendChild(boardContainer);
  
  // 모바일에서 포인트 정보를 보드 아래로 항상 추가
  if (isMobileForPoints) {
    // 포인트 정보가 이미 있으면 재사용, 없으면 새로 찾거나 생성
    let pointsInfo = pointsInfoElement || document.getElementById('daevanion-points-info');
    
    if (!pointsInfo) {
      // 포인트 정보가 없으면 전역 변수에서 가져오기
      if (window.daevanionSharedPoints !== undefined) {
        // displayDaevanionPoints 함수를 호출하여 포인트 정보 생성
        displayDaevanionPoints(
          window.daevanionSharedPoints || 0,
          window.daevanionArielPoints || 0,
          window.daevanionAspelPoints || 0
        );
        pointsInfo = document.getElementById('daevanion-points-info');
      }
    }
    
    if (pointsInfo) {
      // 포인트 정보를 보드 컨테이너 다음에 추가
      if (pointsInfo.parentElement && pointsInfo.parentElement !== container) {
        pointsInfo.parentElement.removeChild(pointsInfo);
      }
      container.appendChild(pointsInfo);
    }
  }
}

// 전투력 랭킹 로딩
const rankingBody = document.getElementById('ranking-body');
const rankingPagination = document.getElementById('ranking-pagination');
// 중복 선언 방지
if (typeof currentJobFilter === 'undefined') {
  var currentJobFilter = 'all';
}
if (typeof currentServerFilter === 'undefined') {
  var currentServerFilter = 'all';
}
if (typeof currentServerRaceFilter === 'undefined') {
  var currentServerRaceFilter = 'all';
}
if (typeof currentPage === 'undefined') {
  var currentPage = 1;
}

// [제거됨] 전투력 구간 변수 - slow query 유발 및 캐시 효율 저하

// 랭킹 데이터 메모리 캐시
// 중복 선언 방지
if (typeof rankingDataCache === 'undefined') {
  var rankingDataCache = {};
}
const RANKING_CACHE_DURATION = 9 * 60 * 1000; // 9분 (서버 캐시 10분보다 짧게)

// 오래된 캐시 정리 함수
function cleanupRankingCache() {
  const now = Date.now();
  const keys = Object.keys(rankingDataCache);
  let cleaned = 0;
  keys.forEach(key => {
    if ((now - rankingDataCache[key].timestamp) >= RANKING_CACHE_DURATION) {
      delete rankingDataCache[key];
      cleaned++;
    }
  });
  if (cleaned > 0) {
  }
}

// 주기적으로 캐시 정리 (5분마다)
setInterval(cleanupRankingCache, 5 * 60 * 1000);

// 직업 필터 버튼
const jobFilterButtons = document.querySelectorAll('#ranking-job-filters .ranking-filter-btn');
if (jobFilterButtons) {
  jobFilterButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const job = btn.getAttribute('data-value') || 'all';
      currentJobFilter = job;

      // active 클래스 토글
      jobFilterButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      // URL 업데이트
      const rankingURL = buildRankingURL(currentJobFilter, currentServerFilter, currentServerRaceFilter);
      updateURL(rankingURL);

      loadRanking(currentJobFilter, currentServerFilter, currentServerRaceFilter, 1);
    });
  });
}

// 서버 필터 버튼 (동적으로 생성)
const serverFilterContainer = document.getElementById('ranking-server-filters');
let currentServerRaceTab = 'all';
const allServerFilterButton = serverFilterContainer ? serverFilterContainer.querySelector('[data-value="all"]') : null;

if (allServerFilterButton) {
  allServerFilterButton.addEventListener('click', () => {
    currentServerFilter = 'all';
    serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
    allServerFilterButton.classList.add('active');
    
    // URL 업데이트
    const rankingURL = buildRankingURL(currentJobFilter, currentServerFilter, currentServerRaceFilter);
    updateURL(rankingURL);
    
    loadRanking(currentJobFilter, currentServerFilter, currentServerRaceFilter, 1);
  });
}

// 서버 필터 탭 버튼 (전체/천족/마족)
const serverTabButtons = document.querySelectorAll('.ranking-server-tab-btn');
if (serverTabButtons) {
  serverTabButtons.forEach(tabBtn => {
    tabBtn.addEventListener('click', () => {
      const race = tabBtn.getAttribute('data-race');
      currentServerRaceFilter = race;
      currentServerFilter = 'all';
      
      // 탭 버튼 active 토글
      serverTabButtons.forEach(b => {
        b.classList.remove('active');
        b.style.background = 'rgba(255, 255, 255, 0.05)';
        b.style.borderColor = 'var(--card-border)';
        b.style.color = 'var(--text-primary)';
      });
      tabBtn.classList.add('active');
      tabBtn.style.background = 'rgba(157, 140, 255, 0.16)';
      tabBtn.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      tabBtn.style.color = 'var(--accent)';
      
      // 서버 버튼 업데이트
      updateServerFilters(race);
      
      // URL 업데이트
      const rankingURL = buildRankingURL(currentJobFilter, currentServerFilter, currentServerRaceFilter);
      updateURL(rankingURL);
      
      if (race === 'all') {
        const allServerBtn = serverFilterContainer.querySelector('[data-value="all"]');
        if (allServerBtn) {
          serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
          allServerBtn.classList.add('active');
        }
        loadRanking(currentJobFilter, currentServerFilter, currentServerRaceFilter, 1);
      } else {
        loadRanking(currentJobFilter, currentServerFilter, currentServerRaceFilter, 1);
      }
    });
  });
}

// 서버 필터 버튼 업데이트 함수
function updateServerFilters(race) {
  if (!serverFilterContainer || !servers) return;
  
  // 기존 서버 버튼 제거 (전체 버튼 제외)
  const existingButtons = serverFilterContainer.querySelectorAll('.ranking-filter-btn:not([data-value="all"])');
  existingButtons.forEach(btn => btn.remove());
  
  // 전체 탭이면 서버 리스트 숨김
  if (race === 'all') {
    serverFilterContainer.style.display = 'none';
    return; // 서버 리스트 표시 안함
  }
  
  serverFilterContainer.style.display = 'flex';
  
  let serversToShow = [];
  
  if (race === 'elyos' && servers.elyos) {
    // 천족 서버만 표시
    servers.elyos.forEach(s => {
      serversToShow.push(s.name);
    });
  } else if (race === 'asmodian' && servers.asmodian) {
    // 마족 서버만 표시
    servers.asmodian.forEach(s => {
      serversToShow.push(s.name);
    });
  }
  
  // 서버 버튼 생성
  serversToShow.forEach(serverName => {
    const btn = document.createElement('button');
    btn.className = 'ranking-filter-btn';
    btn.setAttribute('data-filter-type', 'server');
    btn.setAttribute('data-value', serverName);
    btn.textContent = serverName;
    btn.addEventListener('click', () => {
      currentServerFilter = serverName;
      
      // active 클래스 토글
      serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // URL 업데이트
      const rankingURL = buildRankingURL(currentJobFilter, currentServerFilter, currentServerRaceFilter);
      updateURL(rankingURL);
      
      loadRanking(currentJobFilter, currentServerFilter, currentServerRaceFilter, 1);
    });
    serverFilterContainer.appendChild(btn);
  });
}

// 초기 서버 필터 설정
if (serverFilterContainer && servers) {
  updateServerFilters('all');
}

// 랭킹 필터 초기화 함수
function initializeRankingFilters() {
  // 필터 변수 초기화
  currentJobFilter = 'all';
  currentServerFilter = 'all';
  currentServerRaceFilter = 'all';
  currentPage = 1;
  
  // 직업 필터 버튼 초기화 (전체 버튼 active)
  const jobFilterButtons = document.querySelectorAll('#ranking-job-filters .ranking-filter-btn');
  jobFilterButtons.forEach(btn => {
    btn.classList.remove('active');
    if (btn.getAttribute('data-value') === 'all') {
      btn.classList.add('active');
    }
  });
  
  // 서버 필터 탭 버튼 초기화 (전체 탭 active)
  const serverTabButtons = document.querySelectorAll('.ranking-server-tab-btn');
  serverTabButtons.forEach(btn => {
    btn.classList.remove('active');
    btn.style.background = 'rgba(255, 255, 255, 0.05)';
    btn.style.borderColor = 'var(--card-border)';
    btn.style.color = 'var(--text-primary)';
    if (btn.getAttribute('data-race') === 'all') {
      btn.classList.add('active');
      btn.style.background = 'rgba(157, 140, 255, 0.16)';
      btn.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      btn.style.color = 'var(--accent)';
    }
  });
  
  // 서버 필터 초기화
  if (serverFilterContainer) {
    updateServerFilters('all');
    const allServerBtn = serverFilterContainer.querySelector('[data-value="all"]');
    if (allServerBtn) {
      serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
      allServerBtn.classList.add('active');
    }
  }
  
  // 랭킹 로드
  if (rankingBody) {
    loadRanking('all', 'all', 'all', 1);
  }
}

// 초기 로딩: 랭킹 탭이 활성화되어 있을 때만 로드
// 페이지 로드 시 자동 호출하지 않음 (랭킹 탭 클릭 시에만 호출)

function loadRanking(job, server, race, page = 1) {
  currentPage = page;
  const params = new URLSearchParams();
  if (job && job !== 'all') {
    params.append('job', job);
  } else {
    params.append('job', 'all');
  }
  
  if (server && server !== 'all') {
    params.append('server', server);
  } else {
    params.append('server', 'all');
  }
  
  if (race && race !== 'all') {
    params.append('race', race);
  } else {
    params.append('race', 'all');
  }

  // [제거됨] 전투력 구간 필터 - slow query 유발 및 캐시 효율 저하
  
  params.append('page', page);
  params.append('per_page', 10);

  // 캐시 키 생성 (모든 필터 파라미터 포함)
  const cacheKey = params.toString();
  
  // 메모리 캐시 확인
  const now = Date.now();
  const cached = rankingDataCache[cacheKey];
  if (cached && (now - cached.timestamp) < RANKING_CACHE_DURATION) {
    // 캐시된 데이터 사용
    const data = cached.data;
    if (data.success) {
      // [제거됨] 전투력 구간 요약 업데이트 - 필터 제거로 불필요

      const rows = data.data || [];
      if (!rows.length) {
        rankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">아직 랭킹 데이터가 없습니다. 먼저 캐릭터를 검색해보세요.</td></tr>';
        return;
      }

      // rowElements 준비
      const rowElements = [];
      
      rows.forEach((row, index) => {
        const tr = document.createElement('tr');
        const jobLabel = row.job || '';
        const jobImageUrl = row.job_image_url || '';
        const guild = row.guild || '-';
        const nickname = row.nickname || '';
        const serverName = row.server || '';
        const raceName = row.race || '';
        
        // race를 숫자로 변환 (천족=1, 마족=2)
        let raceValue = '';
        let serverId = '';
        
        if (raceName === '천족') {
          raceValue = '1';
          if (servers && servers.elyos) {
            const serverInfo = servers.elyos.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        } else if (raceName === '마족') {
          raceValue = '2';
          if (servers && servers.asmodian) {
            const serverInfo = servers.asmodian.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        }
        
        // 직업 이미지가 있으면 표시
        let jobCell = '';
        if (jobImageUrl) {
          jobCell = `<img src="${jobImageUrl}" alt="${jobLabel}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">${jobLabel}`;
        } else {
          jobCell = jobLabel;
        }
        
        // 닉네임을 클릭 가능하게 만들기
        const nicknameCell = serverId && raceValue 
          ? `<a href="/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" data-nickname="${nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: var(--accent); text-decoration: none; cursor: pointer; transition: opacity 0.2s;">${nickname}</a>`
          : nickname;
        
        // 순위 계산 (페이지네이션 고려)
        const rank = (page - 1) * 10 + index + 1;
        
        // 종족 색상 설정 (천족: 파란색, 마족: 빨간색)
        let raceCell = row.race || '';
        if (raceName === '천족') {
          raceCell = `<span style="color: #4a90e2;">${raceName}</span>`;
        } else if (raceName === '마족') {
          raceCell = `<span style="color: #e24a4a;">${raceName}</span>`;
        }
        
        tr.innerHTML = `
          <td class="ranking-position col-rank">${rank}</td>
          <td class="col-nickname">${nicknameCell}</td>
          <td class="col-job">${jobCell}</td>
          <td class="col-race">${raceCell}</td>
          <td class="col-server">${row.server || ''}</td>
          <td class="col-guild">${guild}</td>
          <td class="combat-power-cell col-power" data-nickname="${nickname}" data-race="${raceValue}" data-server="${serverId}">${parseInt(row.combat_power || 0).toLocaleString()}</td>
        `;
        const originalCombatPower = parseInt(row.combat_power || 0);
        rowElements.push({
          element: tr,
          nickname: nickname,
          raceValue: raceValue,
          raceName: raceName,
          serverId: serverId,
          serverName: serverName,
          originalCombatPower: originalCombatPower,
          currentCombatPower: originalCombatPower,
          rank: rank,
          jobCell: jobCell,
          nicknameCell: nicknameCell,
          raceCell: raceCell,
          server: row.server || '',
          guild: guild
        });
      });
      
      // 테이블 표시
      displayRankingTable(rowElements, data.pagination, job, server, race);
      return;
    }
  }

  // 로딩 중 메시지 표시
  rankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:2rem; color: var(--text-muted);">로딩 중...</td></tr>';
  if (rankingPagination) {
    rankingPagination.style.display = 'none';
  }

  fetch('/api/rankings?' + params.toString())
    .then(res => res.json())
    .then(data => {
      if (!data.success) {
        rankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">랭킹 데이터를 불러오지 못했습니다.</td></tr>';
        return;
      }

      // 메모리 캐시에 저장
      rankingDataCache[cacheKey] = {
        data: data,
        timestamp: Date.now()
      };

      // [제거됨] 전투력 구간 요약 업데이트 - 필터 제거로 불필요

      const rows = data.data || [];
      if (!rows.length) {
        rankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">아직 랭킹 데이터가 없습니다. 먼저 캐릭터를 검색해보세요.</td></tr>';
        return;
      }

      // rowElements 준비 (테이블은 아직 렌더링하지 않음)
      const rowElements = [];
      
      rows.forEach((row, index) => {
        const tr = document.createElement('tr');
        const jobLabel = row.job || '';
        const jobImageUrl = row.job_image_url || '';
        const guild = row.guild || '-';
        const nickname = row.nickname || '';
        const serverName = row.server || '';
        const raceName = row.race || '';
        
        // race를 숫자로 변환 (천족=1, 마족=2)
        let raceValue = '';
        let serverId = '';
        
        if (raceName === '천족') {
          raceValue = '1';
          // 서버 이름으로 server_id 찾기
          if (servers && servers.elyos) {
            const serverInfo = servers.elyos.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        } else if (raceName === '마족') {
          raceValue = '2';
          // 서버 이름으로 server_id 찾기
          if (servers && servers.asmodian) {
            const serverInfo = servers.asmodian.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        }
        
        // 직업 이미지가 있으면 표시
        let jobCell = '';
        if (jobImageUrl) {
          jobCell = `<img src="${jobImageUrl}" alt="${jobLabel}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">${jobLabel}`;
        } else {
          jobCell = jobLabel;
        }
        
        // 닉네임을 클릭 가능하게 만들기
        const nicknameCell = serverId && raceValue 
          ? `<a href="/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" data-nickname="${nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: var(--accent); text-decoration: none; cursor: pointer; transition: opacity 0.2s;">${nickname}</a>`
          : nickname;
        
        // 순위 계산 (페이지네이션 고려)
        const rank = (page - 1) * 10 + index + 1;
        
        // 종족 색상 설정 (천족: 파란색, 마족: 빨간색)
        let raceCell = row.race || '';
        if (raceName === '천족') {
          raceCell = `<span style="color: #4a90e2;">${raceName}</span>`;
        } else if (raceName === '마족') {
          raceCell = `<span style="color: #e24a4a;">${raceName}</span>`;
        }
        
        tr.innerHTML = `
          <td class="ranking-position col-rank">${rank}</td>
          <td class="col-nickname">${nicknameCell}</td>
          <td class="col-job">${jobCell}</td>
          <td class="col-race">${raceCell}</td>
          <td class="col-server">${row.server || ''}</td>
          <td class="col-guild">${guild}</td>
          <td class="combat-power-cell col-power" data-nickname="${nickname}" data-race="${raceValue}" data-server="${serverId}">${parseInt(row.combat_power || 0).toLocaleString()}</td>
        `;
        // 테이블에 추가하지 않음 (전투력 업데이트 완료 후 추가)
        const originalCombatPower = parseInt(row.combat_power || 0);
        rowElements.push({
          element: tr,
          nickname: nickname,
          raceValue: raceValue,
          raceName: raceName,  // 종족 이름 (천족/마족)
          serverId: serverId,
          serverName: serverName,  // 서버 이름
          originalCombatPower: originalCombatPower,
          currentCombatPower: originalCombatPower, // 초기값은 원래 전투력
          rank: rank,  // 순위 저장
          jobCell: jobCell,  // 직업 셀 HTML 저장
          nicknameCell: nicknameCell,  // 닉네임 셀 HTML 저장
          raceCell: raceCell,  // 종족 셀 HTML 저장
          server: row.server || '',  // 서버 이름 저장
          guild: guild  // 길드 저장
        });
      });
      
      // 테이블 표시 (전투력 업데이트 없이 바로 표시)
      displayRankingTable(rowElements, data.pagination, job, server, race);
    })
    .catch(err => {
      rankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">랭킹 데이터를 불러오는 중 오류가 발생했습니다.</td></tr>';
      if (rankingPagination) {
        rankingPagination.style.display = 'none';
      }
    });
}

// 페이지네이션 UI 렌더링
function renderPagination(pagination, job, server, race) {
  if (!rankingPagination) return;
  
  const { page, total_pages, total_count } = pagination;
  rankingPagination.style.display = 'flex';
  rankingPagination.innerHTML = '';
  
  // 이전 버튼
  const prevBtn = document.createElement('button');
  prevBtn.className = 'pagination-btn';
  prevBtn.textContent = '이전';
  prevBtn.disabled = page === 1;
  prevBtn.addEventListener('click', () => {
    if (page > 1) {
      loadRanking(job, server, race, page - 1);
    }
  });
  rankingPagination.appendChild(prevBtn);
  
  // 페이지 번호 버튼들
  const startPage = Math.max(1, page - 2);
  const endPage = Math.min(total_pages, page + 2);
  
  if (startPage > 1) {
    const firstBtn = document.createElement('button');
    firstBtn.className = 'pagination-btn';
    firstBtn.textContent = '1';
    firstBtn.addEventListener('click', () => loadRanking(job, server, race, 1));
    rankingPagination.appendChild(firstBtn);
    
    if (startPage > 2) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      rankingPagination.appendChild(ellipsis);
    }
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = 'pagination-btn';
    if (i === page) {
      pageBtn.classList.add('active');
    }
    pageBtn.textContent = i;
    pageBtn.addEventListener('click', () => loadRanking(job, server, race, i));
    rankingPagination.appendChild(pageBtn);
  }
  
  if (endPage < total_pages) {
    if (endPage < total_pages - 1) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      rankingPagination.appendChild(ellipsis);
    }
    
    const lastBtn = document.createElement('button');
    lastBtn.className = 'pagination-btn';
    lastBtn.textContent = total_pages;
    lastBtn.addEventListener('click', () => loadRanking(job, server, race, total_pages));
    rankingPagination.appendChild(lastBtn);
  }
  
  // 다음 버튼
  const nextBtn = document.createElement('button');
  nextBtn.className = 'pagination-btn';
  nextBtn.textContent = '다음';
  nextBtn.disabled = page === total_pages;
  nextBtn.addEventListener('click', () => {
    if (page < total_pages) {
      loadRanking(job, server, race, page + 1);
    }
  });
  rankingPagination.appendChild(nextBtn);
  
  // 정보 표시
  const info = document.createElement('span');
  info.className = 'pagination-info';
  info.textContent = `${total_count}명 중 ${(page - 1) * 10 + 1}-${Math.min(page * 10, total_count)}명`;
  rankingPagination.appendChild(info);
}

// 랭킹 업데이트 중 플래그 (무한 루프 방지)
let isUpdatingRanking = false;

// 전투력만 업데이트하는 함수 (배치 처리)
function updateCombatPowers(rowElements, pagination, job, server, race) {
  if (!rowElements || rowElements.length === 0) {
    // 데이터가 없으면 테이블 표시
    displayRankingTable(rowElements, pagination, job, server, race);
    return;
  }

  // 모든 캐릭터 정보를 배열로 준비
  const characters = rowElements
    .map((rowData) => ({
      race: parseInt(rowData.raceValue),
      server_id: parseInt(rowData.serverId),
      keyword: rowData.nickname,
      server_name: rowData.serverName,
      race_name: rowData.raceName,
    }))
    .filter((char) => char.keyword && char.race && char.server_id);

  if (characters.length === 0) {
    displayRankingTable(rowElements, pagination, job, server, race);
    return;
  }

  // 배치 API 호출 (한 번의 요청으로 모든 캐릭터 조회)
  fetch('/api/character/combat-power/batch', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ characters }),
  })
    .then((response) => response.json())
    .then((data) => {
      if (data.success && Array.isArray(data.results)) {
        // 결과를 닉네임 기반으로 매핑
        const resultMap = {};
        data.results.forEach((result) => {
          if (!result || !result.nickname) return;
          resultMap[result.nickname] = result.combat_power;
        });

        // [최적화] 전투력 구간 필터 제거 - 항상 최신 전투력 사용
        
        // rowElements 업데이트
        rowElements.forEach((rowData) => {
          const latestCombatPower = resultMap[rowData.nickname];
          if (latestCombatPower !== undefined && latestCombatPower !== null) {
            rowData.latestCombatPower = parseInt(latestCombatPower);
            rowData.currentCombatPower = latestCombatPower;
          }
        });

      }

      // 테이블 표시
      displayRankingTable(rowElements, pagination, job, server, race);
    })
    .catch((error) => {
      // 에러 발생 시에도 테이블 표시 (기존 값 사용)
      displayRankingTable(rowElements, pagination, job, server, race);
    });
}

// 랭킹 테이블 표시 함수 (전투력 업데이트 완료 후 호출)
function displayRankingTable(rowElements, pagination, job, server, race) {
  // 랭킹 탭이 활성화되어 있는지 확인
  const tabRanking = document.getElementById('tab-ranking');
  if (!tabRanking || !tabRanking.checked) {
    return; // 랭킹 탭이 활성화되어 있지 않으면 함수 종료
  }
  
  if (!rowElements || rowElements.length === 0) {
    rankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">아직 랭킹 데이터가 없습니다. 먼저 캐릭터를 검색해보세요.</td></tr>';
    if (rankingPagination) {
      rankingPagination.style.display = 'none';
    }
    return;
  }
  
  // rowElements를 전투력 내림차순으로 정렬
  const sortedRows = [...rowElements].sort((a, b) => {
    const powerA = a.currentCombatPower !== undefined ? a.currentCombatPower : a.originalCombatPower;
    const powerB = b.currentCombatPower !== undefined ? b.currentCombatPower : b.originalCombatPower;
    return powerB - powerA;
  });
  
  const tbody = document.getElementById('ranking-body');
  if (!tbody) return;
  
  // 테이블 스타일 강제 적용 (모든 화면 크기) - 렌더링 전에 미리 적용
  const rankingTableEl = document.getElementById('ranking-table');
  const rankingContainerEl = document.getElementById('ranking-container');
  const panelRankingEl = document.getElementById('panel-ranking');
  const isMobile = window.innerWidth <= 768;
  
  // 부모 컨테이너들부터 스타일 적용 (하위에서 상위로) - 랭킹 탭만
  if (panelRankingEl) {
    panelRankingEl.style.width = '100%';
    panelRankingEl.style.maxWidth = '100%';
    panelRankingEl.style.overflowX = 'hidden';
    panelRankingEl.style.boxSizing = 'border-box';
    
    const cardGrid = panelRankingEl.querySelector('.card-grid');
    if (cardGrid) {
      cardGrid.style.width = '100%';
      cardGrid.style.maxWidth = '100%';
      cardGrid.style.overflowX = 'hidden';
      cardGrid.style.boxSizing = 'border-box';
    }
    
    const heroCard = panelRankingEl.querySelector('.hero-card');
    if (heroCard) {
      heroCard.style.width = '100%';
      heroCard.style.maxWidth = '100%';
      heroCard.style.overflowX = 'hidden';
      heroCard.style.boxSizing = 'border-box';
    }
  }
  
  if (rankingContainerEl) {
    rankingContainerEl.style.width = '100%';
    rankingContainerEl.style.maxWidth = '100%';
    rankingContainerEl.style.boxSizing = 'border-box';
    
    if (isMobile) {
      rankingContainerEl.style.overflowX = 'hidden';
      rankingContainerEl.style.overflowY = 'visible';
    } else {
      rankingContainerEl.style.overflowX = 'auto';
      rankingContainerEl.style.overflowY = 'visible';
    }
  }
  
  if (rankingTableEl) {
    rankingTableEl.style.width = '100%';
    rankingTableEl.style.maxWidth = '100%';
    rankingTableEl.style.boxSizing = 'border-box';
    rankingTableEl.style.margin = '0';
    rankingTableEl.style.padding = '0';
    
    if (isMobile) {
      rankingTableEl.style.tableLayout = 'fixed';
      rankingTableEl.style.minWidth = '100%';
    } else {
      rankingTableEl.style.tableLayout = 'auto';
    }
  }
  
  // 테이블 렌더링
  tbody.innerHTML = '';
  const page = typeof currentPage !== 'undefined' ? currentPage : 1;
  
  sortedRows.forEach((rowData, newIndex) => {
    const newRank = (page - 1) * 10 + newIndex + 1;
    const displayPower = rowData.currentCombatPower !== undefined ? rowData.currentCombatPower : rowData.originalCombatPower;
    
    // 전투력 셀 HTML 생성
    const combatPowerCellHtml = `<td class="combat-power-cell col-power" data-nickname="${rowData.nickname}" data-race="${rowData.raceValue}" data-server="${rowData.serverId}">${displayPower.toLocaleString()}</td>`;
    
    // 행 HTML 재생성
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="ranking-position col-rank">${newRank}</td>
      <td class="col-nickname">${rowData.nicknameCell}</td>
      <td class="col-job">${rowData.jobCell}</td>
      <td class="col-race">${rowData.raceCell}</td>
      <td class="col-server">${rowData.server}</td>
      <td class="col-guild">${rowData.guild}</td>
      ${combatPowerCellHtml}
    `;
    
    // 모바일에서 행 스타일 강제 적용
    if (isMobile) {
      tr.style.width = '100%';
      tr.style.maxWidth = '100%';
      tr.style.boxSizing = 'border-box';
      
      const cells = tr.querySelectorAll('td');
      cells.forEach(cell => {
        cell.style.boxSizing = 'border-box';
        if (cell.classList.contains('col-rank')) {
          cell.style.width = '15%';
          cell.style.minWidth = '15%';
          cell.style.maxWidth = '15%';
        } else if (cell.classList.contains('col-nickname')) {
          cell.style.width = '50%';
          cell.style.minWidth = '50%';
          cell.style.maxWidth = '50%';
        } else if (cell.classList.contains('col-power')) {
          cell.style.width = '35%';
          cell.style.minWidth = '35%';
          cell.style.maxWidth = '35%';
        }
        // 숨겨진 컬럼들
        if (cell.classList.contains('col-job') || 
            cell.classList.contains('col-race') || 
            cell.classList.contains('col-server') || 
            cell.classList.contains('col-guild')) {
          cell.style.display = 'none';
        }
      });
    }
    
    tbody.appendChild(tr);
    
    // 닉네임 클릭 이벤트 추가
    const nicknameLink = tr.querySelector('.nickname-link');
    if (nicknameLink) {
      nicknameLink.addEventListener('click', function(e) {
        // 마우스 휠 클릭(중간 클릭)이나 Ctrl+클릭, Shift+클릭(새 탭/새 창)은 기본 동작 허용
        if (e.button === 1 || e.ctrlKey || e.metaKey || e.shiftKey) {
          return; // 기본 동작 허용 (새 탭으로 열기)
        }
        
        // 일반 클릭은 preventDefault하고 직접 검색 수행
        e.preventDefault();
        
        const nickname = this.getAttribute('data-nickname');
        const race = this.getAttribute('data-race');
        const serverId = this.getAttribute('data-server');
        
        if (nickname && race && serverId) {
          // 로딩 표시를 먼저 설정
          document.getElementById('character-result').style.display = 'none';
          document.getElementById('character-all-servers-result').style.display = 'none';
          document.getElementById('character-loading').style.display = 'block';
          const rankingLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
          if (rankingLoadingOverlay) {
            rankingLoadingOverlay.style.display = 'flex';
          }
          
          // 캐릭터 검색 탭으로 이동
          const characterTab = document.getElementById('tab-character');
          if (characterTab) {
            characterTab.checked = true;
            characterTab.dispatchEvent(new Event('change'));
            updateSidebarVisibility();
            
            // 종족 버튼 업데이트
            if (race) {
              updateRaceSelection(race, true);
            }
            
            // 검색 폼에 값 설정
            const serverSelect = document.getElementById('server-select');
            const keywordInput = document.getElementById('character-keyword');
            
            // 서버 선택이 활성화될 때까지 대기
            setTimeout(() => {
              if (serverSelect) {
                serverSelect.value = serverId;
                if (keywordInput) keywordInput.value = nickname;
                
                // 로딩 표시 유지 (updateSidebarVisibility가 호출되어도 로딩 상태 확인)
                document.getElementById('character-loading').style.display = 'block';
                const rankingLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
                if (rankingLoadingOverlay2) {
                  rankingLoadingOverlay2.style.display = 'flex';
                }
                
                // 검색 실행 (performSearch가 로딩 표시를 처리함)
                performSearch();
              }
            }, 300);
          }
        }
      });
      
      // 호버 효과
      nicknameLink.addEventListener('mouseenter', function() {
        this.style.opacity = '0.7';
      });
      nicknameLink.addEventListener('mouseleave', function() {
        this.style.opacity = '1';
      });
    }
  });
  
  // 테이블 스타일 다시 강제 적용 (렌더링 후, 모든 화면 크기)
  // requestAnimationFrame을 사용하여 브라우저 렌더링 사이클에 맞춰 적용
  requestAnimationFrame(() => {
    // 랭킹 탭이 활성화되어 있는지 확인
    const tabRanking = document.getElementById('tab-ranking');
    if (!tabRanking || !tabRanking.checked) {
      return; // 랭킹 탭이 활성화되어 있지 않으면 스타일 적용하지 않음
    }
    
    const table = document.getElementById('ranking-table');
    const container = document.getElementById('ranking-container');
    const panel = document.getElementById('panel-ranking');
    const cardGrid = panel ? panel.querySelector('.card-grid') : null;
    const heroCard = panel ? panel.querySelector('.hero-card') : null;
    const isMobile = window.innerWidth <= 768;
    
    // 부모 컨테이너들 스타일 강제 적용 (랭킹 탭만)
    if (panel) {
      panel.style.width = '100%';
      panel.style.maxWidth = '100%';
      panel.style.overflowX = 'hidden';
      panel.style.boxSizing = 'border-box';
    }
    
    if (cardGrid) {
      cardGrid.style.width = '100%';
      cardGrid.style.maxWidth = '100%';
      cardGrid.style.overflowX = 'hidden';
      cardGrid.style.boxSizing = 'border-box';
    }
    
    if (heroCard) {
      heroCard.style.width = '100%';
      heroCard.style.maxWidth = '100%';
      heroCard.style.overflowX = 'hidden';
      heroCard.style.boxSizing = 'border-box';
    }
    
    if (container) {
      container.style.width = '100%';
      container.style.maxWidth = '100%';
      container.style.boxSizing = 'border-box';
      
      if (isMobile) {
        container.style.overflowX = 'hidden';
        container.style.overflowY = 'visible';
      } else {
        container.style.overflowX = 'auto';
        container.style.overflowY = 'visible';
      }
    }
    
    if (table) {
      table.style.width = '100%';
      table.style.maxWidth = '100%';
      table.style.boxSizing = 'border-box';
      table.style.margin = '0';
      table.style.padding = '0';
      
      if (isMobile) {
        table.style.tableLayout = 'fixed';
        table.style.minWidth = '100%';
        
        // 모바일에서 각 컬럼 너비 강제 적용 (thead와 tbody 모두)
        const cols = table.querySelectorAll('th, td');
        cols.forEach(col => {
          col.style.boxSizing = 'border-box';
          col.style.overflow = 'hidden';
          col.style.textOverflow = 'ellipsis';
          col.style.whiteSpace = 'nowrap';
          
          if (col.classList.contains('col-rank')) {
            col.style.width = '15%';
            col.style.minWidth = '15%';
            col.style.maxWidth = '15%';
          } else if (col.classList.contains('col-nickname')) {
            col.style.width = '50%';
            col.style.minWidth = '50%';
            col.style.maxWidth = '50%';
          } else if (col.classList.contains('col-power')) {
            col.style.width = '35%';
            col.style.minWidth = '35%';
            col.style.maxWidth = '35%';
          }
          // 숨겨진 컬럼들도 처리
          if (col.classList.contains('col-job') || 
              col.classList.contains('col-race') || 
              col.classList.contains('col-server') || 
              col.classList.contains('col-guild')) {
            col.style.display = 'none';
            col.style.width = '0';
            col.style.minWidth = '0';
            col.style.maxWidth = '0';
            col.style.padding = '0';
            col.style.margin = '0';
          }
        });
        
        // thead와 tbody에도 스타일 적용
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        if (thead) {
          thead.style.width = '100%';
          thead.style.maxWidth = '100%';
          const theadTr = thead.querySelector('tr');
          if (theadTr) {
            theadTr.style.width = '100%';
            theadTr.style.maxWidth = '100%';
          }
        }
        if (tbody) {
          tbody.style.width = '100%';
          tbody.style.maxWidth = '100%';
        }
      } else {
        table.style.tableLayout = 'auto';
      }
    }
    
    // 한 번 더 확인 (다음 프레임에서)
    requestAnimationFrame(() => {
      // 랭킹 탭이 활성화되어 있는지 다시 확인
      const tabRankingCheck = document.getElementById('tab-ranking');
      if (!tabRankingCheck || !tabRankingCheck.checked) {
        return; // 랭킹 탭이 활성화되어 있지 않으면 스타일 적용하지 않음
      }
      
      if (isMobile && container) {
        container.style.overflowX = 'hidden';
        container.style.width = '100%';
        container.style.maxWidth = '100%';
      }
      if (isMobile && panel) {
        panel.style.overflowX = 'hidden';
        panel.style.width = '100%';
        panel.style.maxWidth = '100%';
      }
    });
  });
  
  // 페이지네이션 UI 렌더링
  if (pagination && pagination.total_pages > 1) {
    renderPagination(pagination, job, server, race);
  } else {
    if (rankingPagination) {
      rankingPagination.style.display = 'none';
    }
  }
}

// 랭킹 캐릭터 정보 백그라운드 업데이트 함수
function updateRankingCharacters(rows) {
  if (!rows || rows.length === 0 || isUpdatingRanking) return;
  
  isUpdatingRanking = true;
  let completedCount = 0;
  const totalCount = rows.length;
  
  // 각 캐릭터에 대해 백그라운드에서 검색하여 DB 업데이트
  rows.forEach((row, index) => {
    const nickname = row.nickname || '';
    const serverName = row.server || '';
    const raceName = row.race || '';
    
    if (!nickname || !serverName || !raceName) {
      completedCount++;
      if (completedCount === totalCount) {
        isUpdatingRanking = false;
        // 업데이트 완료 (랭킹 새로고침하지 않음 - 무한 루프 방지)
      }
      return;
    }
    
    // race를 숫자로 변환 (천족=1, 마족=2)
    let raceValue = '';
    let serverId = '';
    
    if (raceName === '천족') {
      raceValue = '1';
      if (servers && servers.elyos) {
        const serverInfo = servers.elyos.find(s => s.name === serverName);
        if (serverInfo) serverId = serverInfo.id;
      }
    } else if (raceName === '마족') {
      raceValue = '2';
      if (servers && servers.asmodian) {
        const serverInfo = servers.asmodian.find(s => s.name === serverName);
        if (serverInfo) serverId = serverInfo.id;
      }
    }
    
    if (!raceValue || !serverId) {
      completedCount++;
      if (completedCount === totalCount) {
        isUpdatingRanking = false;
        // 업데이트 완료 (랭킹 새로고침하지 않음 - 무한 루프 방지)
      }
      return;
    }
    
    // 백그라운드에서 검색 API 호출 (DB만 업데이트, 화면 표시 안 함)
    // 약간의 딜레이를 두어 서버 부하 방지
    setTimeout(() => {
      fetch('/api/character/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          race: parseInt(raceValue),
          server_id: parseInt(serverId),
          keyword: nickname
        })
      })
      .then(response => response.json())
      .then(data => {
        completedCount++;
        // 모든 업데이트 완료
        if (completedCount === totalCount) {
          isUpdatingRanking = false;
          // 업데이트 완료 (랭킹 새로고침하지 않음 - 무한 루프 방지)
        }
      })
      .catch(error => {
        completedCount++;
        if (completedCount === totalCount) {
          isUpdatingRanking = false;
          // 업데이트 완료 (랭킹 새로고침하지 않음 - 무한 루프 방지)
        }
      });
    }, index * 200); // 각 요청 사이에 200ms 딜레이
  });
}

// Chart.js CDN 추가
if (typeof Chart === 'undefined') {
  const chartScript = document.createElement('script');
  chartScript.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js';
  chartScript.onload = function() {
    // Chart.js 로드 완료
  };
  document.head.appendChild(chartScript);
}

// 성장기록 그래프 변수
// 중복 선언 방지
if (typeof growthChart === 'undefined') {
  var growthChart = null;
}
if (typeof growthChartResizeHandler === 'undefined') {
  var growthChartResizeHandler = null;
}

// 성장기록 로드 함수
function loadGrowthHistory() {
  const contentDiv = document.getElementById('growth-history-content');
  
  if (!contentDiv) {
    return;
  }
  
  // 현재 검색된 캐릭터 정보 가져오기
  const currentNickname = window.currentCharacterNickname;
  const currentServer = window.currentCharacterServer;
  const currentRace = window.currentCharacterRace;
  
  if (!currentNickname || !currentServer || !currentRace) {
    contentDiv.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">캐릭터 정보가 없습니다.</div>';
    return;
  }
  
  contentDiv.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">성장도표를 불러오는 중...</div>';
  
  // API 호출
  const params = new URLSearchParams({
    nickname: currentNickname,
    server: currentServer,
    race: currentRace
  });
  
  fetch('/api/character/history?' + params.toString())
    .then(response => response.json())
    .then(data => {
      if (data.success && data.data && data.data.length > 0) {
        // 그래프 그리기
        drawGrowthChart(data.data);
      } else {
        contentDiv.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">성장도표 데이터가 없습니다.</div>';
      }
    })
    .catch(error => {
      contentDiv.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">성장도표를 불러오는 중 오류가 발생했습니다.</div>';
    });
}

// 성장기록 그래프 그리기 함수
function drawGrowthChart(historyData) {
  const contentDiv = document.getElementById('growth-history-content');
  
  if (!contentDiv) {
    return;
  }
  
  // 기존 차트가 있으면 제거
  if (growthChart) {
    // 기존 resize 이벤트 리스너 제거
    if (growthChartResizeHandler) {
      window.removeEventListener('resize', growthChartResizeHandler);
      growthChartResizeHandler = null;
    }
    growthChart.destroy();
    growthChart = null;
  }
  
  // 데이터 준비
  const labels = historyData.map(item => {
    const date = new Date(item.date);
    return date.toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' });
  });
  const combatPowers = historyData.map(item => item.combat_power);
  
  // Canvas 컨테이너 추가 (모바일 최적화를 위한 래퍼)
  contentDiv.innerHTML = '<div style="position: relative; width: 100%; max-width: 100%; overflow: hidden; height: 400px;"><canvas id="growth-chart"></canvas></div>';
  const newCanvas = document.getElementById('growth-chart');
  
  // 캔버스 크기 설정
  const containerDiv = newCanvas.parentElement;
  newCanvas.style.width = '100%';
  newCanvas.style.height = '100%';
  
  // Chart.js가 로드되었는지 확인
  if (typeof Chart === 'undefined') {
    // Chart.js 로드 대기 (최대 10초 대기)
    let checkCount = 0;
    const maxChecks = 100; // 100ms * 100 = 10초
    const checkChart = setInterval(() => {
      checkCount++;
      if (typeof Chart !== 'undefined') {
        clearInterval(checkChart);
        createChart();
      } else if (checkCount >= maxChecks) {
        // 타임아웃: Chart.js가 로드되지 않으면 interval 정리
        clearInterval(checkChart);
      }
    }, 100);
    return;
  }
  
  createChart();
  
  function createChart() {
    const ctx = newCanvas.getContext('2d');
    
    // 모바일 감지
    const isMobile = window.innerWidth <= 768;
    const baseFontSize = isMobile ? 12 : 14;
    const yAxisFontSize = isMobile ? 13 : 15;
    const legendFontSize = isMobile ? 13 : 15;
    
    growthChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: '전투력',
          data: combatPowers,
          borderColor: 'rgba(157, 140, 255, 1)',
          backgroundColor: 'rgba(157, 140, 255, 0.1)',
          borderWidth: isMobile ? 2.5 : 2,
          fill: true,
          tension: 0.4,
          pointRadius: isMobile ? 5 : 4,
          pointHoverRadius: isMobile ? 7 : 6,
          pointBackgroundColor: 'rgba(157, 140, 255, 1)',
          pointBorderColor: '#fff',
          pointBorderWidth: isMobile ? 2.5 : 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        aspectRatio: isMobile ? 1.2 : 2,
        layout: {
          padding: {
            left: isMobile ? 10 : 15,
            right: isMobile ? 10 : 15,
            top: isMobile ? 15 : 20,
            bottom: isMobile ? 10 : 15
          }
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#f5f7ff',
              font: {
                family: 'Pretendard',
                size: legendFontSize,
                weight: '500'
              },
              padding: isMobile ? 12 : 15,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(9, 16, 37, 0.98)',
            titleColor: '#f5f7ff',
            bodyColor: '#f5f7ff',
            borderColor: 'rgba(157, 140, 255, 0.5)',
            borderWidth: 1.5,
            padding: isMobile ? 10 : 12,
            titleFont: {
              family: 'Pretendard',
              size: isMobile ? 12 : 13,
              weight: '600'
            },
            bodyFont: {
              family: 'Pretendard',
              size: isMobile ? 11 : 12
            },
            displayColors: false,
            callbacks: {
              label: function(context) {
                return '전투력: ' + context.parsed.y.toLocaleString();
              }
            }
          }
        },
        scales: {
          x: {
            ticks: {
              color: '#8b95b5',
              font: {
                family: 'Pretendard',
                size: baseFontSize,
                weight: '500'
              },
              maxRotation: isMobile ? 45 : 0,
              minRotation: isMobile ? 45 : 0,
              padding: isMobile ? 8 : 10
            },
            grid: {
              color: 'rgba(255, 255, 255, 0.08)',
              lineWidth: 1
            }
          },
          y: {
            ticks: {
              color: '#f5f7ff',
              font: {
                family: 'Pretendard',
                size: yAxisFontSize,
                weight: '500'
              },
              padding: isMobile ? 8 : 10,
              callback: function(value) {
                return value.toLocaleString();
              }
            },
            grid: {
              color: 'rgba(255, 255, 255, 0.08)',
              lineWidth: 1
            }
          }
        },
      }
    });
    
    // 리사이즈 이벤트 핸들러 (모바일 회전 대응)
    let resizeTimeout;
    const resizeHandler = function() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(function() {
        if (growthChart && growthChart.canvas && growthChart.canvas.parentElement) {
          try {
            growthChart.resize();
          } catch (e) {
            // 리사이즈 실패 시 무시
          }
        }
      }, 100);
    };
    
    // 기존 리스너가 있으면 제거 후 새로 추가
    if (growthChartResizeHandler) {
      window.removeEventListener('resize', growthChartResizeHandler);
    }
    growthChartResizeHandler = resizeHandler;
    window.addEventListener('resize', resizeHandler);
    
    // 차트가 제거될 때 이벤트 리스너도 제거
    const originalDestroy = growthChart.destroy;
    growthChart.destroy = function() {
      if (growthChartResizeHandler) {
        window.removeEventListener('resize', growthChartResizeHandler);
        growthChartResizeHandler = null;
      }
      originalDestroy.call(this);
    };
  }
}

// 스트리머 방송 섹션 기능 (홈 화면에 항상 표시, 2개 컬럼)
// 중복 선언 방지
if (typeof streamerRefreshInterval === 'undefined') {
  var streamerRefreshInterval = null;
}
if (typeof streamerLastUpdateTime === 'undefined') {
  var streamerLastUpdateTime = null; // 캐싱된 업데이트 시간
}

function initStreamerSection() {
  // 초기 로드만 수행 (자동 새로고침 제거 - 10분 캐싱으로 충분)
  loadAllStreamers();
}

// 스트리머 섹션 정리 함수
function cleanupStreamerSection() {
  if (streamerRefreshInterval) {
    clearInterval(streamerRefreshInterval);
    streamerRefreshInterval = null;
  }
}

// DOMContentLoaded 또는 즉시 실행
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initStreamerSection);
} else {
  initStreamerSection();
}

// 모든 스트리머 데이터 로드 (종족별로 분류)
async function loadAllStreamers() {
  const elyosContainer = document.getElementById('streamer-container-elyos');
  const asmodianContainer = document.getElementById('streamer-container-asmodian');
  
  if (!elyosContainer || !asmodianContainer) return;

  try {
    // 로딩 상태는 첫 로드 시에만 표시 (자동 새로고침 시에는 표시 안 함)
    const isFirstLoad = elyosContainer.innerHTML.includes('로딩 중') || 
                        elyosContainer.innerHTML.includes('방송 중인 스트리머가 없습니다') ||
                        elyosContainer.innerHTML.trim() === '';
    
    // 프론트엔드 캐싱: localStorage에 저장된 데이터 확인 (20분 이내면 재사용)
    const STREAMER_CACHE_KEY = 'streamer_data_cache';
    const STREAMER_CACHE_TIME_KEY = 'streamer_data_cache_time';
    const CACHE_DURATION = 20 * 60 * 1000; // 20분 (서버 스케줄러 주기와 동일)
    
    const cachedData = localStorage.getItem(STREAMER_CACHE_KEY);
    const cachedTime = localStorage.getItem(STREAMER_CACHE_TIME_KEY);
    const now = Date.now();
    
    // 캐시된 데이터가 있고 20분 이내면 재사용
    if (cachedData && cachedTime && (now - parseInt(cachedTime)) < CACHE_DURATION) {
      try {
        const result = JSON.parse(cachedData);
        if (result.success && result.data) {
          // 캐시된 데이터로 렌더링
          await renderStreamerData(result, elyosContainer, asmodianContainer);
          return; // API 호출 없이 종료
        }
      } catch (e) {
        // 캐시 파싱 실패 시 무시하고 API 호출
      }
    }
    
    if (isFirstLoad) {
      elyosContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>';
      asmodianContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">로딩 중...</p>';
    }
    
    const response = await fetch('/api/streamers', {
      cache: 'default', // 브라우저 캐시 활용
      headers: {
        'Cache-Control': 'max-age=1200' // 20분간 브라우저 캐시 (서버 스케줄러 주기와 동일)
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const result = await response.json();
    
    // API 응답을 localStorage에 캐싱 (20분간 유효)
    if (result.success) {
      try {
        localStorage.setItem(STREAMER_CACHE_KEY, JSON.stringify(result));
        localStorage.setItem(STREAMER_CACHE_TIME_KEY, now.toString());
      } catch (e) {
        // localStorage 용량 초과 등 오류 시 무시
      }
    }
    
    // 데이터 렌더링
    await renderStreamerData(result, elyosContainer, asmodianContainer);
  } catch (error) {
    // 에러 발생 시에도 기존 내용 유지 (로딩 상태만 제거)
    if (elyosContainer.innerHTML.includes('로딩 중')) {
      elyosContainer.innerHTML = '<p style="text-align: center; color: var(--text-muted);">스트리머 정보를 불러오는 중 오류가 발생했습니다.</p>';
    }
    if (asmodianContainer.innerHTML.includes('로딩 중')) {
      asmodianContainer.innerHTML = '<p style="text-align: center; color: var(--text-muted);">스트리머 정보를 불러오는 중 오류가 발생했습니다.</p>';
    }
  }
}

// 스트리머 데이터 렌더링 함수 (공통 로직 분리)
async function renderStreamerData(result, elyosContainer, asmodianContainer) {
  if (result.success && result.data) {
    // 서버 목록 가져오기
    const serverDataEl = document.getElementById('server-data');
    const servers = serverDataEl ? JSON.parse(serverDataEl.textContent) : { elyos: [], asmodian: [] };
    
    // 서버 이름 목록 추출
    const elyosServerNames = servers.elyos ? servers.elyos.map(s => s.name) : [];
    const asmodianServerNames = servers.asmodian ? servers.asmodian.map(s => s.name) : [];
    
    // 서버 기반으로 종족 분류 및 방송 중인 스트리머만 필터링
    const elyosStreamers = result.data.filter(s => {
      // 방송 중인 스트리머만 표시
      if (!s.is_live) return false;
      if (s.race === '천족') return true;
      if (s.server && elyosServerNames.includes(s.server)) return true;
      return false;
    });
    
    const asmodianStreamers = result.data.filter(s => {
      // 방송 중인 스트리머만 표시
      if (!s.is_live) return false;
      if (s.race === '마족') return true;
      if (s.server && asmodianServerNames.includes(s.server)) return true;
      return false;
    });
    
    // 최근 업데이트 시간 표시 (서버에서 제공한 캐시 업데이트 시간 사용)
    // 서버 스케줄러가 20분마다 캐시를 업데이트하므로, 서버가 제공한 last_updated 시간을 고정 사용
    if (result.last_updated) {
      // 서버에서 제공한 캐시 업데이트 시간을 저장 (20분 고정)
      streamerLastUpdateTime = result.last_updated;
      
      const updateTimeEl = document.getElementById('streamer-update-time');
      if (updateTimeEl) {
        // 서버에서 제공한 캐시 업데이트 시간 사용 (20분 고정)
        const updateDate = new Date(result.last_updated);
        const now = new Date();
        const diffMs = now - updateDate;
        const diffMins = Math.floor(diffMs / 60000);
        
        let timeText = '';
        if (diffMins < 1) {
          timeText = '방금 전 업데이트';
        } else if (diffMins < 60) {
          timeText = `${diffMins}분 전 업데이트`;
        } else {
          const diffHours = Math.floor(diffMins / 60);
          if (diffHours < 24) {
            timeText = `${diffHours}시간 전 업데이트`;
          } else {
            const diffDays = Math.floor(diffHours / 24);
            timeText = `${diffDays}일 전 업데이트`;
          }
        }
        
        updateTimeEl.textContent = timeText;
      }
    }
    
    renderStreamers(elyosStreamers, elyosContainer, '#3b82f6', servers, '천족');
    renderStreamers(asmodianStreamers, asmodianContainer, '#ef4444', servers, '마족');
  } else {
    if (!result.success) {
      // 스트리머 API 오류
    }
    elyosContainer.innerHTML = '<p style="text-align: center; color: var(--text-muted);">스트리머 정보를 불러올 수 없습니다.</p>';
    asmodianContainer.innerHTML = '<p style="text-align: center; color: var(--text-muted);">스트리머 정보를 불러올 수 없습니다.</p>';
  }
}

// 스트리머 카드 렌더링
function renderStreamers(streamers, container, borderColor, servers, raceName) {
  if (!container) return;

  if (!streamers || streamers.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: var(--text-muted);">방송 중인 스트리머가 없습니다.</p>';
    return;
  }

  // 방송 중인 사람을 먼저 표시
  const liveStreamers = streamers.filter(s => s.is_live);
  const offlineStreamers = streamers.filter(s => !s.is_live);
  const sortedStreamers = [...liveStreamers, ...offlineStreamers];

  container.innerHTML = sortedStreamers.map(streamer => {
    const platformClass = streamer.platform === 'chzzk' ? 'chzzk' : 'soop';
    const platformName = streamer.platform === 'chzzk' ? '치지직' : '숲';
    const thumbnailUrl = streamer.thumbnail_url || streamer.profile_image_url || '';
    const viewers = streamer.viewer_count > 0 ? streamer.viewer_count.toLocaleString() : '0';
    const displayName = streamer.display_name || streamer.name || '';
    const serverName = streamer.server || '';
    
    // display_name에서 괄호 안의 값 추출 (실제 캐릭터 닉네임)
    let characterNickname = '';
    if (displayName) {
      const match = displayName.match(/\(([^)]+)\)/);
      if (match && match[1]) {
        characterNickname = match[1].trim();
      } else {
        // 괄호가 없으면 display_name 전체를 사용
        characterNickname = displayName.trim();
      }
    }
    
    // 플랫폼별 방송 URL 생성
    let streamUrl = '';
    if (streamer.platform === 'chzzk') {
      streamUrl = `https://chzzk.naver.com/live/${streamer.channel_id}`;
    } else if (streamer.platform === 'soop' || streamer.platform === 'afreeca') {
      streamUrl = `https://play.afreecatv.com/${streamer.channel_id}`;
    } else {
      streamUrl = '#';
    }

    // 캐릭터 검색을 위한 정보 추출
    let raceValue = '';
    let serverId = '';
    if (characterNickname && serverName && raceName && servers) {
      if (raceName === '천족') {
        raceValue = '1';
        if (servers.elyos) {
          const serverInfo = servers.elyos.find(s => s.name === serverName);
          if (serverInfo) serverId = serverInfo.id;
        }
      } else if (raceName === '마족') {
        raceValue = '2';
        if (servers.asmodian) {
          const serverInfo = servers.asmodian.find(s => s.name === serverName);
          if (serverInfo) serverId = serverInfo.id;
        }
      }
    }

    // 이미지 로드 실패 시 처리 (한 번만 처리하고 재시도하지 않음)
    const imageErrorHandler = `this.onerror=null; this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, rgba(75, 85, 255, 0.22), rgba(236, 72, 153, 0.2))';`;

    // data 속성에 검색 정보 저장 (이스케이프 처리)
    const dataAttributes = characterNickname && raceValue && serverId 
      ? `data-streamer-nickname="${characterNickname.replace(/"/g, '&quot;')}" data-streamer-race="${raceValue}" data-streamer-server="${serverId}"`
      : '';

    return `
      <div class="streamer-card ${platformClass}" style="border-left: 3px solid ${borderColor};">
        <div class="streamer-card-thumbnail-wrapper" onclick="window.open('${streamUrl}', '_blank')">
          ${thumbnailUrl ? `<img src="${thumbnailUrl}" loading="lazy" referrerpolicy="no-referrer" alt="${streamer.name}" class="streamer-thumbnail" onerror="${imageErrorHandler}">` : '<div class="streamer-thumbnail" style="background: linear-gradient(135deg, rgba(75, 85, 255, 0.22), rgba(236, 72, 153, 0.2));"></div>'}
          <div class="streamer-card-overlay">
            <div class="streamer-platform-badge ${platformClass}">${platformName}</div>
            ${streamer.is_live ? `
              <div class="streamer-viewers-badge">
                <span class="streamer-viewers-dot"></span>
                <span>${viewers}</span>
              </div>
            ` : ''}
          </div>
        </div>
        ${characterNickname && raceValue && serverId ? `
          <a href="#" class="streamer-info-section streamer-search-link" style="text-decoration: none; color: inherit; display: block; cursor: pointer;" ${dataAttributes}>
            <div class="streamer-name">${displayName}</div>
            ${serverName ? `<div class="streamer-server">${serverName}</div>` : ''}
          </a>
        ` : `
          <div class="streamer-info-section">
            <div class="streamer-name">${displayName}</div>
            ${serverName ? `<div class="streamer-server">${serverName}</div>` : ''}
          </div>
        `}
      </div>
    `;
  }).join('');
  
  // 스트리머 검색 링크에 이벤트 리스너 추가
  container.querySelectorAll('.streamer-search-link').forEach(link => {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      const nickname = this.getAttribute('data-streamer-nickname');
      const race = this.getAttribute('data-streamer-race');
      const server = this.getAttribute('data-streamer-server');
      
      if (nickname && race && server) {
        // 로딩 표시를 먼저 설정
        document.getElementById('character-result').style.display = 'none';
        document.getElementById('character-all-servers-result').style.display = 'none';
        document.getElementById('character-loading').style.display = 'block';
        const streamerLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
        if (streamerLoadingOverlay) {
          streamerLoadingOverlay.style.display = 'flex';
        }
        
        // 캐릭터 검색 탭으로 이동
        const characterTab = document.getElementById('tab-character');
        if (characterTab) {
          characterTab.checked = true;
          characterTab.dispatchEvent(new Event('change'));
          updateSidebarVisibility();
          
          // 종족 필터 변경 (localStorage에 저장하지 않음 - skipSave = true)
          updateRaceSelection(race, true);
          
          // 검색 폼에 값 설정
          const serverSelect = document.getElementById('server-select');
          const keywordInput = document.getElementById('character-keyword');
          
          // 서버 선택이 활성화될 때까지 대기
          setTimeout(() => {
            if (serverSelect) {
              serverSelect.value = server;
              if (keywordInput) keywordInput.value = nickname;
              
              // 로딩 표시 유지
              document.getElementById('character-loading').style.display = 'block';
              const streamerLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
              if (streamerLoadingOverlay2) {
                streamerLoadingOverlay2.style.display = 'flex';
              }
              
              // 검색 실행
              performSearch();
            }
          }, 300);
        }
      }
      return false;
    });
  });
}

// ====== 메모리 누수 방지: 페이지 언로드 시 모든 타이머 정리 ======
function cleanupAllTimers() {
  // 카운트다운 타이머 정리
  cleanupEventCountdowns();
  
  // 스트리머 새로고침 타이머 정리
  cleanupStreamerSection();
  
  // 성장 차트 리사이즈 핸들러 정리
  if (growthChartResizeHandler) {
    window.removeEventListener('resize', growthChartResizeHandler);
    growthChartResizeHandler = null;
  }
  
  // 성장 차트 정리
  if (growthChart) {
    try {
      growthChart.destroy();
    } catch (e) {
      // 무시
    }
    growthChart = null;
  }
  
  // 모든 랭킹 애니메이션 인터벌 정리
  const rankingContainers = document.querySelectorAll('.daily-ranking-container');
  rankingContainers.forEach(container => {
    if (container._animationInterval) {
      clearInterval(container._animationInterval);
      container._animationInterval = null;
    }
  });
}

// 페이지 언로드 시 정리
window.addEventListener('beforeunload', cleanupAllTimers);

// 페이지가 숨겨질 때도 정리 (탭 전환 시)
document.addEventListener('visibilitychange', function() {
  if (document.hidden) {
    // 페이지가 숨겨질 때는 타이머만 일시 중지 (필요시)
    // 실제로는 beforeunload에서 정리하므로 여기서는 추가 작업 불필요
  }
});

</script>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "아툴",
  "alternateName": "AION2 TOOLS",
  "url": "https://aion2tool.com/",
  "description": "아이온2 캐릭터 검색, 전투력 랭킹, 통계, 티어 분석, 스펙 비교 등 아이온2 게임 정보를 한눈에 확인하는 사이트",
  "potentialAction": {
    "@type": "SearchAction",
    "target": {
      "@type": "EntryPoint",
      "urlTemplate": "https://aion2tool.com/?keyword={search_term_string}"
    },
    "query-input": "required name=search_term_string"
  }
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "아툴 - 아이온2 정보 검색·랭킹 사이트",
  "applicationCategory": "GameApplication",
  "operatingSystem": "Web",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "KRW"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": "1"
  }
}
</script>

<script>
// 내실 랭킹 관련 변수 (전역 스코프)
// 중복 선언 방지: 이미 선언되었는지 확인
if (typeof currentInternalRankingType === 'undefined') {
  var currentInternalRankingType = 'title'; // 'title', 'stigma', 'total_stat'
}
if (typeof currentInternalJobFilter === 'undefined') {
  var currentInternalJobFilter = 'all';
}
if (typeof currentInternalServerFilter === 'undefined') {
  var currentInternalServerFilter = 'all';
}
if (typeof currentInternalServerRaceFilter === 'undefined') {
  var currentInternalServerRaceFilter = 'all';
}
if (typeof currentInternalPage === 'undefined') {
  var currentInternalPage = 1;
}
// 내실 랭킹 필터 초기화
function initializeInternalRankingFilters() {
  // 중복 호출 방지
  if (window.internalRankingFiltersInitializing) {
    return;
  }
  window.internalRankingFiltersInitializing = true;
  
  // active_farming_type이 설정되어 있으면 그 값을 사용, 없으면 'title' 기본값
  
  currentInternalRankingType = 'title';
  
  currentInternalJobFilter = 'all';
  currentInternalServerFilter = 'all';
  currentInternalServerRaceFilter = 'all';
  currentInternalPage = 1;

  // 내실 랭킹 서브 탭 초기화 (현재 타입에 맞게 활성화)
  const internalSubTabs = document.querySelectorAll('.internal-sub-tab');
  internalSubTabs.forEach(tab => {
    tab.classList.remove('active');
    if (tab.dataset.internalType === currentInternalRankingType) {
      tab.classList.add('active');
    }
  });
  
  window.internalRankingFiltersInitializing = false;

  // 직업 필터 초기화
  const jobFilterButtons = document.querySelectorAll('#internal-ranking-job-filters .ranking-filter-btn');
  jobFilterButtons.forEach(btn => {
    btn.classList.remove('active');
    if (btn.getAttribute('data-value') === 'all') {
      btn.classList.add('active');
    }
  });

  // 서버 필터 탭 초기화
  const serverTabButtons = document.querySelectorAll('.internal-server-tab');
  serverTabButtons.forEach(btn => {
    btn.classList.remove('active');
    btn.style.background = 'rgba(255, 255, 255, 0.05)';
    btn.style.borderColor = 'var(--card-border)';
    btn.style.color = 'var(--text-primary)';
    if (btn.getAttribute('data-race') === 'all') {
      btn.classList.add('active');
      btn.style.background = 'rgba(157, 140, 255, 0.16)';
      btn.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      btn.style.color = 'var(--accent)';
    }
  });

  // 서버 필터 초기화
  if (typeof updateInternalServerFilters === 'function') {
    updateInternalServerFilters('all');
  }
}

// 내실 랭킹 서버 필터 업데이트
function updateInternalServerFilters(race) {
  const serverFilterContainer = document.getElementById('internal-ranking-server-filters');
  if (!serverFilterContainer || !servers) return;
  
  const existingButtons = serverFilterContainer.querySelectorAll('.ranking-filter-btn:not([data-value="all"])');
  existingButtons.forEach(btn => btn.remove());
  
  if (race === 'all') {
    serverFilterContainer.style.display = 'none';
    return;
  }
  
  serverFilterContainer.style.display = 'flex';
  
  let serversToShow = [];
  if (race === 'elyos' && servers.elyos) {
    servers.elyos.forEach(s => {
      serversToShow.push(s.name);
    });
  } else if (race === 'asmodian' && servers.asmodian) {
    servers.asmodian.forEach(s => {
      serversToShow.push(s.name);
    });
  }
  
  serversToShow.forEach(serverName => {
    const btn = document.createElement('button');
    btn.className = 'ranking-filter-btn';
    btn.setAttribute('data-filter-type', 'server');
    btn.setAttribute('data-value', serverName);
    btn.textContent = serverName;
    btn.addEventListener('click', () => {
      currentInternalServerFilter = serverName;
      serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // URL 업데이트 (replace로 변경하여 히스토리 스택 쌓이지 않도록)
      const internalRankingURL = buildInternalRankingURL(
        currentInternalRankingType,
        currentInternalJobFilter,
        currentInternalServerRaceFilter,
        currentInternalServerFilter
      );
      updateURL(internalRankingURL, true); // replace=true로 변경
      
      // 데이터 다시 로드 (중복 호출 방지)
      if (!window.internalRankingLoading) {
        window.internalRankingLoading = true;
        loadInternalRanking(1);
        setTimeout(() => {
          window.internalRankingLoading = false;
        }, 1000);
      }
    });
    serverFilterContainer.appendChild(btn);
  });
}

// 내실 랭킹 로드
function loadInternalRanking(page = 1) {
  currentInternalPage = page;
  const params = new URLSearchParams();
  params.append('type', currentInternalRankingType);
  
  if (currentInternalJobFilter && currentInternalJobFilter !== 'all') {
    params.append('job', currentInternalJobFilter);
  } else {
    params.append('job', 'all');
  }
  
  if (currentInternalServerFilter && currentInternalServerFilter !== 'all') {
    params.append('server', currentInternalServerFilter);
  } else {
    params.append('server', 'all');
  }
  
  if (currentInternalServerRaceFilter && currentInternalServerRaceFilter !== 'all') {
    params.append('race', currentInternalServerRaceFilter);
  } else {
    params.append('race', 'all');
  }
  
  params.append('page', page);
  params.append('per_page', 10);
  
  const internalRankingBody = document.getElementById('internal-ranking-body');
  const internalRankingPagination = document.getElementById('internal-ranking-pagination');
  
  if (!internalRankingBody) return;
  
  internalRankingBody.innerHTML = '<tr><td colspan="8" style="text-align:center; padding:1rem;">내실 랭킹 데이터를 불러오는 중...</td></tr>';
  
  const apiUrl = `/api/farming-rankings?${params.toString()}`;
  
  fetch(apiUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data.success) {
        internalRankingBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding:1rem;">${data.error || '내실 랭킹 데이터를 불러오지 못했습니다.'}</td></tr>`;
        if (internalRankingPagination) {
          internalRankingPagination.style.display = 'none';
        }
        return;
      }

      // 마지막 업데이트 시간 표시 (데이터 받은 직후)
      const lastUpdateEl = document.getElementById('internal-ranking-last-update');
      if (lastUpdateEl) {
        if (data.last_update) {
          lastUpdateEl.textContent = `마지막 업데이트: ${data.last_update}`;
        } else {
          lastUpdateEl.textContent = '마지막 업데이트: -';
        }
      } else {
      }
      
      const rows = data.data || [];
      if (!rows.length) {
        internalRankingBody.innerHTML = '<tr><td colspan="8" style="text-align:center; padding:1rem;">내실 랭킹 데이터가 없습니다.</td></tr>';
        if (internalRankingPagination) {
          internalRankingPagination.style.display = 'none';
        }
        return;
      }
      
      // 테이블 헤더 업데이트
      const headerCell = document.getElementById('internal-ranking-value-header');
      if (headerCell) {
        if (currentInternalRankingType === 'title') {
          headerCell.textContent = '타이틀';
        } else if (currentInternalRankingType === 'stigma') {
          headerCell.textContent = '스티그마 샤드';
        } else if (currentInternalRankingType === 'total_stat') {
          headerCell.textContent = '주신스탯합';
        }
      }
      
      // 테이블 행 생성
      let html = '';
      rows.forEach((row, index) => {
        const rank = (page - 1) * 10 + index + 1;
        const jobLabel = row.job || '';
        const jobImageUrl = row.job_image_url || '';
        const guild = row.guild || '-';
        const nickname = row.nickname || '';
        const serverName = row.server || '';
        const raceName = row.race || '';
        
        let raceValue = '';
        let serverId = '';
        
        if (raceName === '천족') {
          raceValue = '1';
          if (servers && servers.elyos) {
            const serverInfo = servers.elyos.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        } else if (raceName === '마족') {
          raceValue = '2';
          if (servers && servers.asmodian) {
            const serverInfo = servers.asmodian.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        }
        
        let jobCell = '';
        if (jobImageUrl) {
          jobCell = `<img src="${jobImageUrl}" alt="${jobLabel}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">${jobLabel}`;
        } else {
          jobCell = jobLabel;
        }
        
        const nicknameCell = serverId && raceValue 
          ? `<a href="/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" style="color: var(--accent); text-decoration: none; cursor: pointer;">${nickname}</a>`
          : nickname;
        
        let raceCell = raceName;
        if (raceName === '천족') {
          raceCell = `<span style="color: #4a90e2;">${raceName}</span>`;
        } else if (raceName === '마족') {
          raceCell = `<span style="color: #e24a4a;">${raceName}</span>`;
        }
        
        const rankingValue = row.ranking_value || 0;
        const combatPower = row.combat_power || 0;
        
        html += `
          <tr>
            <td class="ranking-position col-rank">${rank}</td>
            <td class="col-nickname">${nicknameCell}</td>
            <td class="col-job">${jobCell}</td>
            <td class="col-race">${raceCell}</td>
            <td class="col-server">${serverName}</td>
            <td class="col-guild">${guild}</td>
            <td class="col-power">${parseInt(combatPower).toLocaleString()}</td>
            <td class="col-power">${parseInt(rankingValue).toLocaleString()}</td>
          </tr>
        `;
      });
      
      internalRankingBody.innerHTML = html;
      
      // 닉네임 클릭 이벤트 추가
      internalRankingBody.querySelectorAll('.nickname-link').forEach(link => {
        link.addEventListener('click', function(e) {
          // 마우스 휠 클릭(중간 클릭)이나 Ctrl+클릭, Shift+클릭(새 탭/새 창)은 기본 동작 허용
          if (e.button === 1 || e.ctrlKey || e.metaKey || e.shiftKey) {
            return; // 기본 동작 허용 (새 탭으로 열기)
          }
          
          // 일반 클릭은 preventDefault하고 직접 검색 수행
          e.preventDefault();
          
          const href = this.getAttribute('href');
          if (href && href.startsWith('/?nickname=')) {
            const urlParams = new URLSearchParams(href.substring(2));
            const nickname = urlParams.get('nickname');
            const race = urlParams.get('race');
            const serverId = urlParams.get('server');
            
            if (nickname && race && serverId) {
              // 로딩 표시를 먼저 설정
              document.getElementById('character-result').style.display = 'none';
              document.getElementById('character-all-servers-result').style.display = 'none';
              document.getElementById('character-loading').style.display = 'block';
              const internalLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
              if (internalLoadingOverlay) {
                internalLoadingOverlay.style.display = 'flex';
              }
              
              // 캐릭터 검색 탭으로 이동
              const characterTab = document.getElementById('tab-character');
              if (characterTab) {
                characterTab.checked = true;
                characterTab.dispatchEvent(new Event('change'));
                updateSidebarVisibility();
                
                // 종족 버튼 업데이트
                if (race) {
                  updateRaceSelection(race, true);
                }
                
                // 검색 폼에 값 설정
                const serverSelect = document.getElementById('server-select');
                const keywordInput = document.getElementById('character-keyword');
                
                // 서버 선택이 활성화될 때까지 대기
                setTimeout(() => {
                  if (serverSelect) {
                    serverSelect.value = serverId;
                    if (keywordInput) keywordInput.value = nickname;
                    
                    // 로딩 표시 유지
                    document.getElementById('character-loading').style.display = 'block';
                    const internalLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
                    if (internalLoadingOverlay2) {
                      internalLoadingOverlay2.style.display = 'flex';
                    }
                    
                    // 검색 실행
                    performSearch();
                  }
                }, 300);
              }
            }
          }
        });
      });
      
      // 페이지네이션 표시
      if (internalRankingPagination && data.pagination) {
        renderInternalRankingPagination(data.pagination);
      }
    })
    .catch(err => {
      internalRankingBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding:1rem;">내실 랭킹 데이터를 불러오는 중 오류가 발생했습니다: ${err.message}</td></tr>`;
      if (internalRankingPagination) {
        internalRankingPagination.style.display = 'none';
      }
    });
}

// 내실 랭킹 페이지네이션 렌더링
function renderInternalRankingPagination(pagination) {
  const internalRankingPagination = document.getElementById('internal-ranking-pagination');
  if (!internalRankingPagination) return;
  
  const { page, total_pages, total_count } = pagination;
  internalRankingPagination.style.display = 'flex';
  internalRankingPagination.innerHTML = '';
  
  const prevBtn = document.createElement('button');
  prevBtn.className = 'pagination-btn';
  prevBtn.textContent = '이전';
  prevBtn.disabled = page === 1;
  prevBtn.addEventListener('click', () => {
    if (page > 1) {
      loadInternalRanking(page - 1);
    }
  });
  internalRankingPagination.appendChild(prevBtn);
  
  const startPage = Math.max(1, page - 2);
  const endPage = Math.min(total_pages, page + 2);
  
  if (startPage > 1) {
    const firstBtn = document.createElement('button');
    firstBtn.className = 'pagination-btn';
    firstBtn.textContent = '1';
    firstBtn.addEventListener('click', () => loadInternalRanking(1));
    internalRankingPagination.appendChild(firstBtn);
    
    if (startPage > 2) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      internalRankingPagination.appendChild(ellipsis);
    }
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = 'pagination-btn';
    if (i === page) {
      pageBtn.classList.add('active');
    }
    pageBtn.textContent = i;
    pageBtn.addEventListener('click', () => loadInternalRanking(i));
    internalRankingPagination.appendChild(pageBtn);
  }
  
  if (endPage < total_pages) {
    if (endPage < total_pages - 1) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      internalRankingPagination.appendChild(ellipsis);
    }
    
    const lastBtn = document.createElement('button');
    lastBtn.className = 'pagination-btn';
    lastBtn.textContent = total_pages;
    lastBtn.addEventListener('click', () => loadInternalRanking(total_pages));
    internalRankingPagination.appendChild(lastBtn);
  }
  
  const nextBtn = document.createElement('button');
  nextBtn.className = 'pagination-btn';
  nextBtn.textContent = '다음';
  nextBtn.disabled = page === total_pages;
  nextBtn.addEventListener('click', () => {
    if (page < total_pages) {
      loadInternalRanking(page + 1);
    }
  });
  internalRankingPagination.appendChild(nextBtn);
  
  const info = document.createElement('span');
  info.className = 'pagination-info';
  info.textContent = `${total_count}명 중 ${(page - 1) * 10 + 1}-${Math.min(page * 10, total_count)}명`;
  internalRankingPagination.appendChild(info);
}

// 레기온 랭킹 로드
// 레기온 랭킹 로딩 중 요청 취소를 위한 AbortController
// 중복 선언 방지
if (typeof regionRankingsAbortController === 'undefined') {
  var regionRankingsAbortController = null;
}

function loadRegionRankings(page = 1) {
  
  // 이전 요청이 있으면 취소
  if (regionRankingsAbortController) {
    regionRankingsAbortController.abort();
  }
  
  // 새로운 AbortController 생성
  regionRankingsAbortController = new AbortController();
  const signal = regionRankingsAbortController.signal;
  
  currentRegionPage = page;
  
  // 뷰 전환: 리스트 뷰 표시, 상세 뷰 숨김
  const listView = document.getElementById('region-ranking-list-view');
  const detailView = document.getElementById('region-ranking-detail-view');
  if (listView) listView.style.display = 'block';
  if (detailView) detailView.style.display = 'none';
  
  const params = new URLSearchParams();
  
  if (currentRegionRaceFilter && currentRegionRaceFilter !== 'all') {
    params.append('race', currentRegionRaceFilter);
  }
  if (currentRegionServerFilter && currentRegionServerFilter !== 'all') {
    params.append('server', currentRegionServerFilter);
  }
  if (regionSearchQuery) {
    params.append('search', regionSearchQuery);
  }
  params.append('page', page);
  params.append('per_page', 10);

  const regionBody = document.getElementById('region-ranking-body');
  const regionPagination = document.getElementById('region-ranking-pagination');
  
  if (regionBody) {
    regionBody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding:2rem; color: var(--text-muted);">레기온 랭킹을 불러오는 중...</td></tr>';
  }
  if (regionPagination) {
    regionPagination.style.display = 'none';
  }

  const apiUrl = '/api/region-rankings?' + params.toString();
  
  fetch(apiUrl, { signal })
    .then(res => {
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      return res.json();
    })
    .then(data => {
      // 요청이 취소되었으면 처리하지 않음
      if (signal.aborted) {
        return;
      }
      
      if (!data.success) {
        if (regionBody) {
          regionBody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding:1rem;">레기온 랭킹 데이터를 불러오지 못했습니다. ' + (data.error || '') + '</td></tr>';
        }
        return;
      }

      // 마지막 업데이트 시간 표시
      const updateTimeEl = document.getElementById('region-ranking-update-time');
      if (updateTimeEl && data.last_update) {
        updateTimeEl.textContent = `마지막 업데이트 시간: ${data.last_update}`;
      } else if (updateTimeEl) {
        updateTimeEl.textContent = '';
      }

      if (!data.data || data.data.length === 0) {
        if (regionBody) {
          regionBody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding:1rem;">레기온 랭킹 데이터가 없습니다.</td></tr>';
        }
        if (regionPagination) {
          regionPagination.style.display = 'none';
        }
        return;
      }

      // 테이블 렌더링
      if (regionBody) {
        regionBody.innerHTML = '';
        data.data.forEach((item, index) => {
          const rank = (page - 1) * 10 + index + 1;
          const tr = document.createElement('tr');
          tr.style.cursor = 'pointer';
          tr.addEventListener('click', () => {
            const server = encodeURIComponent(item.server);
            const guild = encodeURIComponent(item.guild);
            // 현재 필터 상태를 URL에 포함
            const params = new URLSearchParams();
            if (currentRegionRaceFilter && currentRegionRaceFilter !== 'all') {
              params.append('race', currentRegionRaceFilter);
            }
            if (currentRegionServerFilter && currentRegionServerFilter !== 'all') {
              params.append('server', currentRegionServerFilter);
            }
            if (regionSearchQuery) {
              params.append('search', regionSearchQuery);
            }
            const queryString = params.toString();
            const url = queryString ? `region/${server}/${guild}?${queryString}` : `region/${server}/${guild}`;
            updateURL(url);
            loadRegionDetail(item.server, item.guild);
          });
          const guildName = item.guild && item.guild.trim() ? item.guild.trim() : '-';
          const serverName = item.server && item.server.trim() ? item.server.trim() : '-';
          const memberCount = item.member_count ? parseInt(item.member_count) : 0;
          const totalPower = item.total_combat_power ? parseInt(item.total_combat_power) : 0;
          
          tr.innerHTML = `
            <td class="ranking-position col-rank">${rank}</td>
            <td class="col-nickname">${guildName}</td>
            <td class="col-server">${serverName}</td>
            <td class="col-power">${memberCount.toLocaleString()}</td>
            <td class="col-power">${totalPower.toLocaleString()}</td>
          `;
          regionBody.appendChild(tr);
        });
      }

      // 마지막 업데이트 시간 표시
      const lastUpdateEl = document.getElementById('region-ranking-update-time');
      if (lastUpdateEl) {
        if (data.last_update) {
          lastUpdateEl.textContent = `마지막 업데이트: ${data.last_update}`;
        } else {
          lastUpdateEl.textContent = '마지막 업데이트: -';
        }
      }

      // 페이지네이션
      if (regionPagination && data.pagination) {
        renderRegionPagination(data.pagination);
      }
    })
    .catch(err => {
      // AbortError는 정상적인 취소이므로 무시
      if (err.name === 'AbortError') {
        return;
      }
      if (regionBody && !signal.aborted) {
        regionBody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding:1rem;">레기온 랭킹 데이터를 불러오는 중 오류가 발생했습니다: ' + err.message + '</td></tr>';
      }
    });
}

// 레기온 랭킹 페이지네이션
function renderRegionPagination(pagination) {
  const regionPagination = document.getElementById('region-ranking-pagination');
  if (!regionPagination) return;
  
  const { page, total_pages, total_count } = pagination;
  regionPagination.style.display = 'flex';
  regionPagination.innerHTML = '';
  
  // 이전 버튼
  const prevBtn = document.createElement('button');
  prevBtn.className = 'pagination-btn';
  prevBtn.textContent = '이전';
  prevBtn.disabled = page === 1;
  prevBtn.addEventListener('click', () => {
    if (page > 1) {
      loadRegionRankings(page - 1);
    }
  });
  regionPagination.appendChild(prevBtn);
  
  // 페이지 번호 버튼들
  const startPage = Math.max(1, page - 2);
  const endPage = Math.min(total_pages, page + 2);
  
  if (startPage > 1) {
    const firstBtn = document.createElement('button');
    firstBtn.className = 'pagination-btn';
    firstBtn.textContent = '1';
    firstBtn.addEventListener('click', () => loadRegionRankings(1));
    regionPagination.appendChild(firstBtn);
    
    if (startPage > 2) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      regionPagination.appendChild(ellipsis);
    }
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = 'pagination-btn';
    if (i === page) {
      pageBtn.classList.add('active');
    }
    pageBtn.textContent = i;
    pageBtn.addEventListener('click', () => loadRegionRankings(i));
    regionPagination.appendChild(pageBtn);
  }
  
  if (endPage < total_pages) {
    if (endPage < total_pages - 1) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      regionPagination.appendChild(ellipsis);
    }
    
    const lastBtn = document.createElement('button');
    lastBtn.className = 'pagination-btn';
    lastBtn.textContent = total_pages;
    lastBtn.addEventListener('click', () => loadRegionRankings(total_pages));
    regionPagination.appendChild(lastBtn);
  }
  
  // 다음 버튼
  const nextBtn = document.createElement('button');
  nextBtn.className = 'pagination-btn';
  nextBtn.textContent = '다음';
  nextBtn.disabled = page === total_pages;
  nextBtn.addEventListener('click', () => {
    if (page < total_pages) {
      loadRegionRankings(page + 1);
    }
  });
  regionPagination.appendChild(nextBtn);
  
  // 정보 표시
  const info = document.createElement('span');
  info.className = 'pagination-info';
  info.textContent = `${total_count}개 중 ${(page - 1) * 10 + 1}-${Math.min(page * 10, total_count)}개`;
  regionPagination.appendChild(info);
}

// 레기온 상세 화면
function loadRegionDetail(server, guild) {
  // 뷰 전환: 리스트 뷰 숨김, 상세 뷰 표시
  const listView = document.getElementById('region-ranking-list-view');
  const detailView = document.getElementById('region-ranking-detail-view');
  if (!listView || !detailView) return;
  
  if (listView) listView.style.display = 'none';
  if (detailView) detailView.style.display = 'block';
  
  // 상세 화면 HTML 생성
  const detailHTML = `
    <div style="margin-bottom: 1.5rem;">
      <button id="region-back-btn" style="padding: 0.5rem 1rem; background: rgba(255, 255, 255, 0.05); border: 1px solid var(--card-border); border-radius: 8px; color: var(--text-primary); cursor: pointer; font-size: 0.95rem; margin-bottom: 1rem;">← 뒤로가기</button>
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
        <div class="hero-card" style="padding: 1rem; background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">길드명</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary);" id="region-detail-guild">${guild}</div>
        </div>
        <div class="hero-card" style="padding: 1rem; background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: var(--text-primary);" id="region-detail-server">${server}</div>
        </div>
        <div class="hero-card" style="padding: 1rem; background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">총 등록 인원 수</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: var(--accent);" id="region-total-members">-</div>
        </div>
        <div class="hero-card" style="padding: 1rem; background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">평균 전투력</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: var(--accent-strong);" id="region-avg-power">-</div>
        </div>
        <div class="hero-card" style="padding: 1rem; background: rgba(15, 23, 42, 0.9); border: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">서버 내 랭킹</div>
          <div style="font-size: 1.25rem; font-weight: 600; color: var(--accent);" id="region-server-rank">-</div>
        </div>
      </div>
    </div>
    <div>
      <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--text-primary);">길드원 목록</h3>
      <table class="ranking-list" id="region-members-table">
        <thead>
          <tr>
            <th class="col-nickname">닉네임</th>
            <th class="col-server">서버</th>
            <th class="col-job">직업</th>
            <th class="col-power">전투력</th>
          </tr>
        </thead>
        <tbody id="region-members-body">
          <tr>
            <td colspan="4" style="text-align:center; padding:1rem;">로딩 중...</td>
          </tr>
        </tbody>
      </table>
      <div id="region-members-pagination" class="pagination-container" style="display: none; margin-top: 1.5rem; justify-content: center; align-items: center; gap: 0.5rem; flex-wrap: wrap;"></div>
    </div>
  `;
  
  detailView.innerHTML = detailHTML;
  
  // 뒤로가기 버튼 이벤트 - 필터 상태 복원
  const backBtn = document.getElementById('region-back-btn');
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      // 현재 URL 해시에서 필터 파라미터 읽기
      const hash = window.location.hash.substring(1); // # 제거
      let savedRace = 'all';
      let savedServer = 'all';
      let savedSearch = '';
      
      // 해시에서 쿼리 파라미터 추출 (예: region/서버/길드?race=elyos&server=시엘)
      if (hash.includes('?')) {
        const [hashPath, queryString] = hash.split('?');
        const urlParams = new URLSearchParams(queryString);
        savedRace = urlParams.get('race') || 'all';
        savedServer = urlParams.get('server') || 'all';
        savedSearch = urlParams.get('search') || '';
      }
      
      // 필터 상태 복원
      currentRegionRaceFilter = savedRace;
      currentRegionServerFilter = savedServer;
      regionSearchQuery = savedSearch;
      
      // URL 업데이트 (필터 파라미터 포함)
      const params = new URLSearchParams();
      if (currentRegionRaceFilter && currentRegionRaceFilter !== 'all') {
        params.append('race', currentRegionRaceFilter);
      }
      if (currentRegionServerFilter && currentRegionServerFilter !== 'all') {
        params.append('server', currentRegionServerFilter);
      }
      if (regionSearchQuery) {
        params.append('search', regionSearchQuery);
      }
      const queryString = params.toString();
      const url = queryString ? `ranking/region?${queryString}` : 'ranking/region';
      updateURL(url);
      
      // 필터 UI 복원
      restoreRegionFilters();
      
      // 랭킹 목록 다시 로드 (뷰 전환은 loadRegionRankings에서 처리됨)
      loadRegionRankings(1);
    });
  }
  
  // API 호출
  const serverEncoded = encodeURIComponent(server);
  const guildEncoded = encodeURIComponent(guild);
  fetch(`/api/region/${serverEncoded}/${guildEncoded}`)
    .then(res => res.json())
    .then(data => {
      if (!data.success) {
        const membersBody = document.getElementById('region-members-body');
        if (membersBody) {
          membersBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:1rem;">레기온 정보를 불러오지 못했습니다.</td></tr>';
        }
        return;
      }
      
      // 통계 업데이트
      const totalMembersEl = document.getElementById('region-total-members');
      const avgPowerEl = document.getElementById('region-avg-power');
      const serverRankEl = document.getElementById('region-server-rank');
      if (totalMembersEl) totalMembersEl.textContent = `${data.total_members}명`;
      if (avgPowerEl) avgPowerEl.textContent = `${data.avg_combat_power.toLocaleString()}`;
      if (serverRankEl) {
        if (data.server_rank !== null && data.server_rank !== undefined && data.server_rank_percent !== null && data.server_rank_percent !== undefined) {
          serverRankEl.textContent = `${data.server_rank}위 (상위 ${data.server_rank_percent}%)`;
        } else {
          serverRankEl.textContent = '-';
        }
      }
      
      // 멤버 목록 렌더링
      const membersBody = document.getElementById('region-members-body');
      if (membersBody) {
        membersBody.innerHTML = '';
        if (!data.members || data.members.length === 0) {
          membersBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:1rem;">등록된 멤버가 없습니다.</td></tr>';
        } else {
          data.members.forEach((member, index) => {
            const tr = document.createElement('tr');
            const raceColor = member.race === '천족' ? '#3b82f6' : '#ef4444';
            
            // 서버 정보 찾기
            const serverDataEl = document.getElementById('server-data');
            let servers = { elyos: [], asmodian: [] };
            
            if (serverDataEl && serverDataEl.textContent) {
              try {
                servers = JSON.parse(serverDataEl.textContent);
              } catch (e) {
              }
            }
            
            let serverId = null;
            let raceValue = null;
            
            // 서버 ID 찾기
            for (const s of servers.elyos) {
              if (s.name === member.server) {
                serverId = s.id;
                raceValue = '1';
                break;
              }
            }
            if (!serverId) {
              for (const s of servers.asmodian) {
                if (s.name === member.server) {
                  serverId = s.id;
                  raceValue = '2';
                  break;
                }
              }
            }
            
            // 닉네임을 클릭 가능한 링크로 만들기 (전투력 랭킹과 동일한 방식)
            const nicknameCell = serverId && raceValue
              ? `<a href="/?nickname=${encodeURIComponent(member.nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" data-nickname="${member.nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: var(--accent); text-decoration: none; cursor: pointer; transition: opacity 0.2s;">${member.nickname}</a>`
              : member.nickname;
            
            tr.innerHTML = `
              <td class="col-nickname">${nicknameCell}</td>
              <td class="col-server" style="color: ${raceColor};">${member.server}</td>
              <td class="col-job">${member.job}</td>
              <td class="col-power">${member.combat_power.toLocaleString()}</td>
            `;
            
            // 닉네임 클릭 이벤트 추가 (전투력 랭킹과 동일한 방식)
            const nicknameLink = tr.querySelector('.nickname-link');
            if (nicknameLink) {
              nicknameLink.addEventListener('click', function(e) {
                // 새 탭에서 열 때는 기본 동작 허용
                if (e.ctrlKey || e.metaKey || e.button === 1 || (e.button === 0 && e.shiftKey)) {
                  return;
                }
                
                // 같은 탭에서 클릭할 때만 preventDefault
                e.preventDefault();
                const nickname = this.getAttribute('data-nickname');
                const race = this.getAttribute('data-race');
                const serverId = this.getAttribute('data-server');
                
                if (nickname && race && serverId) {
                  // 로딩 표시를 먼저 설정
                  document.getElementById('character-result').style.display = 'none';
                  document.getElementById('character-all-servers-result').style.display = 'none';
                  document.getElementById('character-loading').style.display = 'block';
                  const legionLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
                  if (legionLoadingOverlay) {
                    legionLoadingOverlay.style.display = 'flex';
                  }
                  
                  // 캐릭터 검색 탭으로 이동
                  const characterTab = document.getElementById('tab-character');
                  if (characterTab) {
                    characterTab.checked = true;
                    characterTab.dispatchEvent(new Event('change'));
                    updateSidebarVisibility();
                    
                    // 종족 버튼 업데이트
                    if (race) {
                      updateRaceSelection(race, true);
                    }
                    
                    // 검색 폼에 값 설정
                    const serverSelect = document.getElementById('server-select');
                    const keywordInput = document.getElementById('character-keyword');
                    
                    // 서버 선택이 활성화될 때까지 대기
                    setTimeout(() => {
                      if (serverSelect) {
                        serverSelect.value = serverId;
                        if (keywordInput) keywordInput.value = nickname;
                        
                        // 로딩 표시 유지
                        document.getElementById('character-loading').style.display = 'block';
                        const legionLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
                        if (legionLoadingOverlay2) {
                          legionLoadingOverlay2.style.display = 'flex';
                        }
                        
                        // 검색 실행
                        performSearch();
                      }
                    }, 300);
                  }
                }
              });
              
              // 호버 효과
              nicknameLink.addEventListener('mouseenter', function() {
                this.style.opacity = '0.7';
              });
              nicknameLink.addEventListener('mouseleave', function() {
                this.style.opacity = '1';
              });
            }
            
            membersBody.appendChild(tr);
          });
        }
      }
      
      // 페이지네이션
      if (data.pagination && data.pagination.total_pages > 1) {
        renderRegionMembersPagination(data.pagination, server, guild);
      }
    })
    .catch(err => {
      const membersBody = document.getElementById('region-members-body');
      if (membersBody) {
        membersBody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:1rem;">레기온 정보를 불러오는 중 오류가 발생했습니다.</td></tr>';
      }
    });
}

// 레기온 멤버 페이지네이션
function renderRegionMembersPagination(pagination, server, guild) {
  const paginationEl = document.getElementById('region-members-pagination');
  if (!paginationEl) return;
  
  const { page, total_pages } = pagination;
  paginationEl.style.display = 'flex';
  paginationEl.innerHTML = '';
  
  // 이전 버튼
  const prevBtn = document.createElement('button');
  prevBtn.className = 'pagination-btn';
  prevBtn.textContent = '이전';
  prevBtn.disabled = page === 1;
  prevBtn.addEventListener('click', () => {
    if (page > 1) {
      loadRegionDetailPage(server, guild, page - 1);
    }
  });
  paginationEl.appendChild(prevBtn);
  
  // 페이지 번호
  const startPage = Math.max(1, page - 2);
  const endPage = Math.min(total_pages, page + 2);
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = 'pagination-btn';
    if (i === page) {
      pageBtn.classList.add('active');
    }
    pageBtn.textContent = i;
    pageBtn.addEventListener('click', () => loadRegionDetailPage(server, guild, i));
    paginationEl.appendChild(pageBtn);
  }
  
  // 다음 버튼
  const nextBtn = document.createElement('button');
  nextBtn.className = 'pagination-btn';
  nextBtn.textContent = '다음';
  nextBtn.disabled = page === total_pages;
  nextBtn.addEventListener('click', () => {
    if (page < total_pages) {
      loadRegionDetailPage(server, guild, page + 1);
    }
  });
  paginationEl.appendChild(nextBtn);
}

// 레기온 상세 페이지 로드 (페이지네이션용)
function loadRegionDetailPage(server, guild, page) {
  const serverEncoded = encodeURIComponent(server);
  const guildEncoded = encodeURIComponent(guild);
  fetch(`/api/region/${serverEncoded}/${guildEncoded}?page=${page}`)
    .then(res => res.json())
    .then(data => {
      if (!data.success) return;
      
      const membersBody = document.getElementById('region-members-body');
      if (membersBody) {
        membersBody.innerHTML = '';
        data.members.forEach(member => {
          const tr = document.createElement('tr');
          const raceColor = member.race === '천족' ? '#3b82f6' : '#ef4444';
          
          // 서버 정보 찾기
          const serverDataEl = document.getElementById('server-data');
          let servers = { elyos: [], asmodian: [] };
          
          if (serverDataEl && serverDataEl.textContent) {
            try {
              servers = JSON.parse(serverDataEl.textContent);
            } catch (e) {
            }
          }
          
          let serverId = null;
          let raceValue = null;
          
          // 서버 ID 찾기
          for (const s of servers.elyos) {
            if (s.name === member.server) {
              serverId = s.id;
              raceValue = '1';
              break;
            }
          }
          if (!serverId) {
            for (const s of servers.asmodian) {
              if (s.name === member.server) {
                serverId = s.id;
                raceValue = '2';
                break;
              }
            }
          }
          
          // 닉네임을 클릭 가능한 링크로 만들기 (전투력 랭킹과 동일한 방식)
          const nicknameCell = serverId && raceValue
            ? `<a href="/?nickname=${encodeURIComponent(member.nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" data-nickname="${member.nickname}" data-race="${raceValue}" data-server="${serverId}" style="color: var(--accent); text-decoration: none; cursor: pointer; transition: opacity 0.2s;">${member.nickname}</a>`
            : member.nickname;
          
          tr.innerHTML = `
            <td class="col-nickname">${nicknameCell}</td>
            <td class="col-server" style="color: ${raceColor};">${member.server}</td>
            <td class="col-job">${member.job}</td>
            <td class="col-power">${member.combat_power.toLocaleString()}</td>
          `;
          
          // 닉네임 클릭 이벤트 추가 (전투력 랭킹과 동일한 방식)
          const nicknameLink = tr.querySelector('.nickname-link');
          if (nicknameLink) {
            nicknameLink.addEventListener('click', function(e) {
              // 새 탭에서 열 때는 기본 동작 허용
              if (e.ctrlKey || e.metaKey || e.button === 1 || (e.button === 0 && e.shiftKey)) {
                return;
              }
              
              // 같은 탭에서 클릭할 때만 preventDefault
              e.preventDefault();
              const nickname = this.getAttribute('data-nickname');
              const race = this.getAttribute('data-race');
              const serverId = this.getAttribute('data-server');
              
              if (nickname && race && serverId) {
                // 로딩 표시를 먼저 설정
                document.getElementById('character-result').style.display = 'none';
                document.getElementById('character-all-servers-result').style.display = 'none';
                document.getElementById('character-loading').style.display = 'block';
                const memberLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
                if (memberLoadingOverlay) {
                  memberLoadingOverlay.style.display = 'flex';
                }
                
                // 캐릭터 검색 탭으로 이동
                const characterTab = document.getElementById('tab-character');
                if (characterTab) {
                  characterTab.checked = true;
                  characterTab.dispatchEvent(new Event('change'));
                  updateSidebarVisibility();
                  
                  // 종족 버튼 업데이트
                  if (race) {
                    updateRaceSelection(race, true);
                  }
                  
                  // 검색 폼에 값 설정
                  const serverSelect = document.getElementById('server-select');
                  const keywordInput = document.getElementById('character-keyword');
                  
                  setTimeout(() => {
                    if (serverSelect) {
                      serverSelect.value = serverId;
                      if (keywordInput) keywordInput.value = nickname;
                      
                      // 로딩 표시 유지
                      document.getElementById('character-loading').style.display = 'block';
                      const memberLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
                      if (memberLoadingOverlay2) {
                        memberLoadingOverlay2.style.display = 'flex';
                      }
                      
                      // 검색 실행
                      performSearch();
                    }
                  }, 300);
                }
              }
            });
            
            // 호버 효과
            nicknameLink.addEventListener('mouseenter', function() {
              this.style.opacity = '0.7';
            });
            nicknameLink.addEventListener('mouseleave', function() {
              this.style.opacity = '1';
            });
          }
          
          membersBody.appendChild(tr);
        });
      }
      
      if (data.pagination && data.pagination.total_pages > 1) {
        renderRegionMembersPagination(data.pagination, server, guild);
      }
    });
}

// 레기온 랭킹 필터 복원
function restoreRegionFilters() {
  // 종족 필터 복원
  const raceBtns = document.querySelectorAll('#region-race-all, #region-race-elyos, #region-race-asmodian');
  raceBtns.forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.race === currentRegionRaceFilter) {
      btn.classList.add('active');
    }
  });
  
  // 서버 필터 복원
  if (currentRegionRaceFilter && currentRegionRaceFilter !== 'all') {
    updateRegionServerFilters(currentRegionRaceFilter);
    // 서버 필터 버튼 활성화
    setTimeout(() => {
      const serverBtns = document.querySelectorAll('#region-server-filters .ranking-filter-btn');
      serverBtns.forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.value === currentRegionServerFilter) {
          btn.classList.add('active');
        }
      });
    }, 100);
  } else {
    // "전체"를 선택한 경우 서버 필터 숨김 및 리셋
    updateRegionServerFilters('all');
    currentRegionServerFilter = 'all';
  }
  
  // 검색어 복원
  const searchInput = document.getElementById('region-search-input');
  if (searchInput) {
    searchInput.value = regionSearchQuery;
  }
}

// 레기온 랭킹 필터 초기화
function initializeRegionRankingFilters() {
  // 이미 초기화되었는지 확인
  if (window.regionRankingFiltersInitialized) {
    // 이미 초기화되었으면 서버 필터만 업데이트
    const activeRaceBtn = document.querySelector('#region-race-all.active, #region-race-elyos.active, #region-race-asmodian.active') || document.querySelector('#region-race-all');
    if (activeRaceBtn) {
      currentRegionRaceFilter = activeRaceBtn.dataset.race || 'all';
      updateRegionServerFilters(currentRegionRaceFilter);
    }
    return;
  }
  window.regionRankingFiltersInitialized = true;
  
  // 서버 필터 (종족별) - 이벤트 위임 사용
  const raceFilterContainer = document.querySelector('#region-ranking-content');
  if (raceFilterContainer) {
    raceFilterContainer.addEventListener('click', (e) => {
      const btn = e.target.closest('#region-race-all, #region-race-elyos, #region-race-asmodian');
      if (btn) {
        const raceBtns = document.querySelectorAll('#region-race-all, #region-race-elyos, #region-race-asmodian');
        raceBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const newRaceFilter = btn.dataset.race || 'all';
        
        // 종족 필터가 변경되면 서버 필터도 "전체"로 리셋
        if (currentRegionRaceFilter !== newRaceFilter) {
          currentRegionServerFilter = 'all';
        }
        currentRegionRaceFilter = newRaceFilter;
        
        // "전체" 버튼을 클릭한 경우 서버 필터도 "전체"로 리셋
        if (currentRegionRaceFilter === 'all') {
          currentRegionServerFilter = 'all';
          const serverFiltersContainer = document.getElementById('region-server-filters');
          if (serverFiltersContainer) {
            serverFiltersContainer.style.display = 'none';
          }
        } else {
          // "천족" 또는 "마족"을 선택한 경우 서버 필터 표시
          const serverFiltersContainer = document.getElementById('region-server-filters');
          if (serverFiltersContainer) {
            serverFiltersContainer.style.display = 'flex';
          }
        }
        
        // 서버 목록 업데이트
        updateRegionServerFilters(currentRegionRaceFilter);
        loadRegionRankings(1);
      }
    });
  }
  
  // 레기온 검색
  const searchInput = document.getElementById('region-search-input');
  const searchButton = document.getElementById('region-search-button');
  if (searchInput && searchButton) {
    const performSearch = () => {
      regionSearchQuery = searchInput.value.trim();
      loadRegionRankings(1);
    };
    searchButton.addEventListener('click', performSearch);
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        performSearch();
      }
    });
  }
  
  // URL 파라미터에서 필터 상태 읽기
  const urlParams = new URLSearchParams(window.location.search);
  const urlRace = urlParams.get('race');
  const urlServer = urlParams.get('server');
  const urlSearch = urlParams.get('search');
  
  if (urlRace) {
    currentRegionRaceFilter = urlRace;
  }
  if (urlServer) {
    currentRegionServerFilter = urlServer;
  }
  if (urlSearch) {
    regionSearchQuery = urlSearch;
    if (searchInput) {
      searchInput.value = urlSearch;
    }
  }
  
  // 초기 서버 필터 설정
  const activeRaceBtn = document.querySelector('#region-race-all.active, #region-race-elyos.active, #region-race-asmodian.active') || document.querySelector('#region-race-all');
  
  // URL 파라미터가 있으면 그것을 우선 사용
  if (urlRace) {
    const raceBtns = document.querySelectorAll('#region-race-all, #region-race-elyos, #region-race-asmodian');
    raceBtns.forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.race === urlRace) {
        btn.classList.add('active');
      }
    });
    updateRegionServerFilters(urlRace);
  } else if (activeRaceBtn) {
    currentRegionRaceFilter = activeRaceBtn.dataset.race || 'all';
    updateRegionServerFilters(currentRegionRaceFilter);
  } else {
    updateRegionServerFilters('all');
  }
  
  // 서버 필터 버튼 활성화 (약간의 지연 필요)
  if (urlServer) {
    setTimeout(() => {
      const serverBtns = document.querySelectorAll('#region-server-filters .ranking-filter-btn');
      serverBtns.forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.value === urlServer) {
          btn.classList.add('active');
        }
      });
    }, 200);
  }
  
}

// 레기온 랭킹 서버 필터 업데이트
function updateRegionServerFilters(race) {
  const serverFiltersContainer = document.getElementById('region-server-filters');
  if (!serverFiltersContainer) {
    return;
  }
  
  // "전체"를 선택한 경우 서버 필터를 숨김
  if (race === 'all') {
    serverFiltersContainer.style.display = 'none';
    // 서버 필터도 "전체"로 리셋
    currentRegionServerFilter = 'all';
    return;
  }
  
  // "천족" 또는 "마족"을 선택한 경우 서버 필터 표시
  serverFiltersContainer.style.display = 'flex';
  
  const serverDataEl = document.getElementById('server-data');
  if (!serverDataEl) {
    return;
  }
  
  try {
    const servers = JSON.parse(serverDataEl.textContent);
    serverFiltersContainer.innerHTML = '<button class="ranking-filter-btn active" data-filter-type="server" data-value="all">전체</button>';
    
    // 전체 버튼 클릭 이벤트
    const allBtn = serverFiltersContainer.querySelector('.ranking-filter-btn[data-value="all"]');
    if (allBtn) {
      allBtn.addEventListener('click', () => {
        serverFiltersContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
        allBtn.classList.add('active');
        currentRegionServerFilter = 'all';
        loadRegionRankings(1);
      });
    }
    
    let serverList = [];
    if (race === 'elyos') {
      serverList = servers.elyos || [];
    } else if (race === 'asmodian') {
      serverList = servers.asmodian || [];
    } else {
      serverList = [...(servers.elyos || []), ...(servers.asmodian || [])];
    }
    
    serverList.forEach(server => {
      const btn = document.createElement('button');
      btn.className = 'ranking-filter-btn';
      btn.dataset.filterType = 'server';
      btn.dataset.value = server.name;
      btn.textContent = server.name;
      btn.addEventListener('click', () => {
        serverFiltersContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentRegionServerFilter = server.name;
        loadRegionRankings(1);
      });
      serverFiltersContainer.appendChild(btn);
    });
  } catch (error) {
  }
}

// 내실 랭킹 이벤트 리스너 초기화 함수 (전역 함수)
function setupInternalRankingEventListeners() {
  // 이미 설정되었으면 중복 실행 방지
  if (window.internalRankingListenersSetup) {
    return;
  }
  
  // 이벤트 위임을 사용하여 내실 랭킹 컨텐츠 영역에서 서브탭 클릭 처리
  const internalRankingContent = document.getElementById('internal-ranking-content');
  if (!internalRankingContent) {
    return;
  }
  
  // 내실 랭킹 서브탭은 이제 <a> 태그로 페이지 이동 처리
  // 클릭 이벤트 등록 불필요
  
  // 내실 랭킹 직업 필터 버튼 클릭 이벤트 (중복 등록 방지)
  const internalJobFilterButtons = document.querySelectorAll('#internal-ranking-job-filters .ranking-filter-btn');
  internalJobFilterButtons.forEach(btn => {
    if (btn.dataset.listenerAttached === 'true') {
      return;
    }
    btn.dataset.listenerAttached = 'true';
    btn.addEventListener('click', function() {
      const job = this.getAttribute('data-value') || 'all';
      currentInternalJobFilter = job;
      
      // active 클래스 토글
      internalJobFilterButtons.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      // URL 업데이트 (replace로 변경하여 히스토리 스택 쌓이지 않도록)
      const internalRankingURL = buildInternalRankingURL(
        currentInternalRankingType,
        currentInternalJobFilter,
        currentInternalServerRaceFilter,
        currentInternalServerFilter
      );
      updateURL(internalRankingURL, true); // replace=true로 변경
      
      // 데이터 다시 로드 (중복 호출 방지)
      if (!window.internalRankingLoading) {
        window.internalRankingLoading = true;
        loadInternalRanking(1);
        setTimeout(() => {
          window.internalRankingLoading = false;
        }, 1000);
      }
    });
  });
  
  // 내실 랭킹 서버 필터 탭 버튼 (전체/천족/마족) - 중복 등록 방지
  const internalServerTabButtons = document.querySelectorAll('.internal-server-tab');
  internalServerTabButtons.forEach(tabBtn => {
    if (tabBtn.dataset.listenerAttached === 'true') {
      return;
    }
    tabBtn.dataset.listenerAttached = 'true';
    tabBtn.addEventListener('click', function() {
      const race = this.getAttribute('data-race');
      currentInternalServerRaceFilter = race;
      currentInternalServerFilter = 'all';
      
      // 탭 버튼 active 토글
      internalServerTabButtons.forEach(b => {
        b.classList.remove('active');
        b.style.background = 'rgba(255, 255, 255, 0.05)';
        b.style.borderColor = 'var(--card-border)';
        b.style.color = 'var(--text-primary)';
      });
      this.classList.add('active');
      this.style.background = 'rgba(157, 140, 255, 0.16)';
      this.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      this.style.color = 'var(--accent)';
      
      // 서버 버튼 업데이트
      updateInternalServerFilters(race);
      
      // 전체 탭이면 전체 서버 버튼 활성화
      if (race === 'all') {
        const serverFilterContainer = document.getElementById('internal-ranking-server-filters');
        if (serverFilterContainer) {
          const allServerBtn = serverFilterContainer.querySelector('[data-value="all"]');
          if (allServerBtn) {
            serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
            allServerBtn.classList.add('active');
          }
        }
      }
      
      // URL 업데이트 (replace로 변경하여 히스토리 스택 쌓이지 않도록)
      const internalRankingURL = buildInternalRankingURL(
        currentInternalRankingType,
        currentInternalJobFilter,
        currentInternalServerRaceFilter,
        currentInternalServerFilter
      );
      updateURL(internalRankingURL, true); // replace=true로 변경
      
      // 데이터 다시 로드 (중복 호출 방지)
      if (!window.internalRankingLoading) {
        window.internalRankingLoading = true;
        loadInternalRanking(1);
        setTimeout(() => {
          window.internalRankingLoading = false;
        }, 1000);
      }
    });
  });
  
  // 플래그 설정 (이벤트 리스너 등록 완료)
  window.internalRankingListenersSetup = true;
}

// 아툴 전투 점수 랭킹 관련 변수 (전역 스코프)
// 중복 선언 방지
if (typeof currentCombatScoreJobFilter === 'undefined') {
  var currentCombatScoreJobFilter = 'all';
}
if (typeof currentCombatScoreServerFilter === 'undefined') {
  var currentCombatScoreServerFilter = 'all';
}
if (typeof currentCombatScoreServerRaceFilter === 'undefined') {
  var currentCombatScoreServerRaceFilter = 'all';
}
if (typeof currentCombatScorePage === 'undefined') {
  var currentCombatScorePage = 1;
}

// 아툴 전투 점수 랭킹 로드 함수
function loadCombatScoreRanking(page = 1) {
  currentCombatScorePage = page;
  const params = new URLSearchParams();
  
  if (currentCombatScoreJobFilter && currentCombatScoreJobFilter !== 'all') {
    params.append('job', currentCombatScoreJobFilter);
  } else {
    params.append('job', 'all');
  }
  
  if (currentCombatScoreServerFilter && currentCombatScoreServerFilter !== 'all') {
    params.append('server', currentCombatScoreServerFilter);
  } else {
    params.append('server', 'all');
  }
  
  if (currentCombatScoreServerRaceFilter && currentCombatScoreServerRaceFilter !== 'all') {
    params.append('race', currentCombatScoreServerRaceFilter);
  } else {
    params.append('race', 'all');
  }
  
  params.append('page', page);
  params.append('per_page', 10);
  
  const combatScoreRankingBody = document.getElementById('combat-score-ranking-body');
  const combatScoreRankingPagination = document.getElementById('combat-score-ranking-pagination');
  
  if (!combatScoreRankingBody) return;
  
  combatScoreRankingBody.innerHTML = '<tr><td colspan="8" style="text-align:center; padding:1rem;">아툴 전투 점수 랭킹 데이터를 불러오는 중...</td></tr>';
  
  const apiUrl = `/api/combat-score-rankings?${params.toString()}`;
  
  fetch(apiUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data.success) {
        combatScoreRankingBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding:1rem;">${data.error || '아툴 전투 점수 랭킹 데이터를 불러오지 못했습니다.'}</td></tr>`;
        if (combatScoreRankingPagination) {
          combatScoreRankingPagination.style.display = 'none';
        }
        return;
      }

      // 마지막 업데이트 시간 표시
      const lastUpdateEl = document.getElementById('combat-score-ranking-last-update');
      if (lastUpdateEl) {
        if (data.last_update) {
          lastUpdateEl.textContent = `마지막 업데이트: ${data.last_update}`;
        } else {
          lastUpdateEl.textContent = '마지막 업데이트: -';
        }
      }
      
      const rows = data.data || [];
      if (!rows.length) {
        combatScoreRankingBody.innerHTML = '<tr><td colspan="8" style="text-align:center; padding:1rem;">아툴 전투 점수 랭킹 데이터가 없습니다.</td></tr>';
        if (combatScoreRankingPagination) {
          combatScoreRankingPagination.style.display = 'none';
        }
        return;
      }
      
      // 테이블 행 생성
      let html = '';
      rows.forEach((row, index) => {
        const rank = (page - 1) * 10 + index + 1;
        const jobLabel = row.job || '';
        const jobImageUrl = row.job_image_url || '';
        const guild = row.guild || '-';
        const nickname = row.nickname || '';
        const serverName = row.server || '';
        const raceName = row.race || '';
        
        let raceValue = '';
        let serverId = '';
        
        if (raceName === '천족') {
          raceValue = '1';
          if (servers && servers.elyos) {
            const serverInfo = servers.elyos.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        } else if (raceName === '마족') {
          raceValue = '2';
          if (servers && servers.asmodian) {
            const serverInfo = servers.asmodian.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        }
        
        let jobCell = '';
        if (jobImageUrl) {
          jobCell = `<img src="${jobImageUrl}" alt="${jobLabel}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">${jobLabel}`;
        } else {
          jobCell = jobLabel;
        }
        
        const nicknameCell = serverId && raceValue 
          ? `<a href="/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" style="color: var(--accent); text-decoration: none; cursor: pointer;">${nickname}</a>`
          : nickname;
        
        let raceCell = raceName;
        if (raceName === '천족') {
          raceCell = `<span style="color: #4a90e2;">${raceName}</span>`;
        } else if (raceName === '마족') {
          raceCell = `<span style="color: #e24a4a;">${raceName}</span>`;
        }
        
        const rankingValue = row.ranking_value || 0;
        const combatPower = row.combat_power || 0;
        
        html += `
          <tr>
            <td class="ranking-position col-rank">${rank}</td>
            <td class="col-nickname">${nicknameCell}</td>
            <td class="col-job">${jobCell}</td>
            <td class="col-race">${raceCell}</td>
            <td class="col-server">${serverName}</td>
            <td class="col-guild">${guild}</td>
            <td class="col-power">${parseInt(combatPower).toLocaleString()}</td>
            <td class="col-power">${Math.round(rankingValue).toLocaleString()}</td>
          </tr>
        `;
      });
      
      combatScoreRankingBody.innerHTML = html;
      
      // 닉네임 클릭 이벤트 추가
      combatScoreRankingBody.querySelectorAll('.nickname-link').forEach(link => {
        link.addEventListener('click', function(e) {
          // 마우스 휠 클릭(중간 클릭)이나 Ctrl+클릭, Shift+클릭(새 탭/새 창)은 기본 동작 허용
          if (e.button === 1 || e.ctrlKey || e.metaKey || e.shiftKey) {
            return; // 기본 동작 허용 (새 탭으로 열기)
          }
          
          // 일반 클릭은 preventDefault하고 직접 검색 수행
          e.preventDefault();
          
          const href = this.getAttribute('href');
          if (href && href.startsWith('/?nickname=')) {
            const urlParams = new URLSearchParams(href.substring(2));
            const nickname = urlParams.get('nickname');
            const race = urlParams.get('race');
            const serverId = urlParams.get('server');
            
            if (nickname && race && serverId) {
              // 로딩 표시를 먼저 설정
              document.getElementById('character-result').style.display = 'none';
              document.getElementById('character-all-servers-result').style.display = 'none';
              document.getElementById('character-loading').style.display = 'block';
              const combatScoreLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
              if (combatScoreLoadingOverlay) {
                combatScoreLoadingOverlay.style.display = 'flex';
              }
              
              // 캐릭터 검색 탭으로 이동
              const characterTab = document.getElementById('tab-character');
              if (characterTab) {
                characterTab.checked = true;
                characterTab.dispatchEvent(new Event('change'));
                updateSidebarVisibility();
                
                // 종족 버튼 업데이트
                if (race) {
                  updateRaceSelection(race, true);
                }
                
                // 검색 폼에 값 설정
                const serverSelect = document.getElementById('server-select');
                const keywordInput = document.getElementById('character-keyword');
                
                // 서버 선택이 활성화될 때까지 대기
                setTimeout(() => {
                  if (serverSelect) {
                    serverSelect.value = serverId;
                    if (keywordInput) keywordInput.value = nickname;
                    
                    // 로딩 표시 유지
                    document.getElementById('character-loading').style.display = 'block';
                    const combatScoreLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
                    if (combatScoreLoadingOverlay2) {
                      combatScoreLoadingOverlay2.style.display = 'flex';
                    }
                    
                    // 검색 실행
                    performSearch();
                  }
                }, 300);
              }
            }
          }
        });
      });
      
      // 페이지네이션 표시
      if (combatScoreRankingPagination && data.pagination) {
        renderCombatScoreRankingPagination(data.pagination);
      }
    })
    .catch(err => {
      combatScoreRankingBody.innerHTML = `<tr><td colspan="8" style="text-align:center; padding:1rem;">아툴 전투 점수 랭킹 데이터를 불러오는 중 오류가 발생했습니다: ${err.message}</td></tr>`;
      if (combatScoreRankingPagination) {
        combatScoreRankingPagination.style.display = 'none';
      }
    });
}

// 아툴 전투 점수 랭킹 페이지네이션 렌더링
function renderCombatScoreRankingPagination(pagination) {
  const combatScoreRankingPagination = document.getElementById('combat-score-ranking-pagination');
  if (!combatScoreRankingPagination) return;
  
  const { page, total_pages, total_count } = pagination;
  combatScoreRankingPagination.style.display = 'flex';
  combatScoreRankingPagination.innerHTML = '';
  
  const prevBtn = document.createElement('button');
  prevBtn.className = 'pagination-btn';
  prevBtn.textContent = '이전';
  prevBtn.disabled = page === 1;
  prevBtn.addEventListener('click', () => {
    if (page > 1) {
      loadCombatScoreRanking(page - 1);
    }
  });
  combatScoreRankingPagination.appendChild(prevBtn);
  
  const startPage = Math.max(1, page - 2);
  const endPage = Math.min(total_pages, page + 2);
  
  if (startPage > 1) {
    const firstBtn = document.createElement('button');
    firstBtn.className = 'pagination-btn';
    firstBtn.textContent = '1';
    firstBtn.addEventListener('click', () => loadCombatScoreRanking(1));
    combatScoreRankingPagination.appendChild(firstBtn);
    
    if (startPage > 2) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      combatScoreRankingPagination.appendChild(ellipsis);
    }
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.className = 'pagination-btn';
    pageBtn.textContent = i.toString();
    if (i === page) {
      pageBtn.classList.add('active');
    }
    pageBtn.addEventListener('click', () => loadCombatScoreRanking(i));
    combatScoreRankingPagination.appendChild(pageBtn);
  }
  
  if (endPage < total_pages) {
    if (endPage < total_pages - 1) {
      const ellipsis = document.createElement('span');
      ellipsis.className = 'pagination-info';
      ellipsis.textContent = '...';
      combatScoreRankingPagination.appendChild(ellipsis);
    }
    
    const lastBtn = document.createElement('button');
    lastBtn.className = 'pagination-btn';
    lastBtn.textContent = total_pages.toString();
    lastBtn.addEventListener('click', () => loadCombatScoreRanking(total_pages));
    combatScoreRankingPagination.appendChild(lastBtn);
  }
  
  const nextBtn = document.createElement('button');
  nextBtn.className = 'pagination-btn';
  nextBtn.textContent = '다음';
  nextBtn.disabled = page === total_pages;
  nextBtn.addEventListener('click', () => {
    if (page < total_pages) {
      loadCombatScoreRanking(page + 1);
    }
  });
  combatScoreRankingPagination.appendChild(nextBtn);
  
  const infoSpan = document.createElement('span');
  infoSpan.className = 'pagination-info';
  infoSpan.textContent = `${total_count.toLocaleString()}명 중 ${((page - 1) * 10 + 1).toLocaleString()}-${Math.min(page * 10, total_count).toLocaleString()}명`;
  combatScoreRankingPagination.appendChild(infoSpan);
}

// 아툴 전투 점수 랭킹 서버 필터 업데이트
function updateCombatScoreServerFilters(race) {
  const serverFilterContainer = document.getElementById('combat-score-ranking-server-filters');
  if (!serverFilterContainer || !servers) return;
  
  const existingButtons = serverFilterContainer.querySelectorAll('.ranking-filter-btn:not([data-value="all"])');
  existingButtons.forEach(btn => btn.remove());
  
  if (race === 'all') {
    serverFilterContainer.style.display = 'none';
    return;
  }
  
  serverFilterContainer.style.display = 'flex';
  
  let serversToShow = [];
  if (race === 'elyos' && servers.elyos) {
    servers.elyos.forEach(s => {
      serversToShow.push(s.name);
    });
  } else if (race === 'asmodian' && servers.asmodian) {
    servers.asmodian.forEach(s => {
      serversToShow.push(s.name);
    });
  }
  
  serversToShow.forEach(serverName => {
    const btn = document.createElement('button');
    btn.className = 'ranking-filter-btn';
    btn.setAttribute('data-filter-type', 'server');
    btn.setAttribute('data-value', serverName);
    btn.textContent = serverName;
    btn.addEventListener('click', function() {
      const server = this.getAttribute('data-value') || 'all';
      currentCombatScoreServerFilter = server;
      
      serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      loadCombatScoreRanking(1);
    });
    serverFilterContainer.appendChild(btn);
  });
}

// 아툴 전투 점수 랭킹 이벤트 리스너 설정
function setupCombatScoreRankingEventListeners() {
  const combatScoreRankingContent = document.getElementById('combat-score-ranking-content');
  if (!combatScoreRankingContent) {
    return;
  }
  
  // 직업 필터 버튼 클릭 이벤트
  const combatScoreJobFilterButtons = document.querySelectorAll('#combat-score-ranking-job-filters .ranking-filter-btn');
  combatScoreJobFilterButtons.forEach(btn => {
    btn.addEventListener('click', function() {
      const job = this.getAttribute('data-value') || 'all';
      currentCombatScoreJobFilter = job;
      
      combatScoreJobFilterButtons.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      loadCombatScoreRanking(1);
    });
  });
  
  // 서버 필터 탭 버튼 (전체/천족/마족)
  const combatScoreServerTabButtons = document.querySelectorAll('.combat-score-server-tab');
  combatScoreServerTabButtons.forEach(tabBtn => {
    tabBtn.addEventListener('click', function() {
      const race = this.getAttribute('data-race');
      currentCombatScoreServerRaceFilter = race;
      currentCombatScoreServerFilter = 'all';
      
      combatScoreServerTabButtons.forEach(b => {
        b.classList.remove('active');
        b.style.background = 'rgba(255, 255, 255, 0.05)';
        b.style.borderColor = 'var(--card-border)';
        b.style.color = 'var(--text-primary)';
      });
      this.classList.add('active');
      this.style.background = 'rgba(157, 140, 255, 0.16)';
      this.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      this.style.color = 'var(--accent)';
      
      updateCombatScoreServerFilters(race);
      
      if (race === 'all') {
        const serverFilterContainer = document.getElementById('combat-score-ranking-server-filters');
        if (serverFilterContainer) {
          const allServerBtn = serverFilterContainer.querySelector('[data-value="all"]');
          if (allServerBtn) {
            serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
            allServerBtn.classList.add('active');
          }
        }
      }
      
      loadCombatScoreRanking(1);
    });
  });
}

// 컨텐츠 랭킹 관련 변수 (전역 스코프)
// 중복 선언 방지
if (typeof currentContentsRankingType === 'undefined') {
  var currentContentsRankingType = 'abyss'; // 'abyss', 'solo_arena', 'coop_arena', 'nightmare', 'transcendence', 'awakening', 'subjugation'
}
if (typeof currentContentsJobFilter === 'undefined') {
  var currentContentsJobFilter = 'all';
}
if (typeof currentContentsServerFilter === 'undefined') {
  var currentContentsServerFilter = 'all';
}
if (typeof currentContentsServerRaceFilter === 'undefined') {
  var currentContentsServerRaceFilter = 'all';
}
if (typeof currentContentsPage === 'undefined') {
  var currentContentsPage = 1;
}

// 컨텐츠 랭킹 필터 초기화
function initializeContentsRankingFilters() {
  // 중복 호출 방지
  if (window.contentsRankingFiltersInitializing) {
    return;
  }
  window.contentsRankingFiltersInitializing = true;
  
  // active_contents_type이 설정되어 있으면 그 값을 사용, 없으면 'abyss' 기본값
  
  currentContentsRankingType = 'abyss';
  
  currentContentsJobFilter = 'all';
  currentContentsServerFilter = 'all';
  currentContentsServerRaceFilter = 'all';
  currentContentsPage = 1;

  // 컨텐츠 랭킹 서브 탭 초기화 (현재 타입에 맞게 활성화)
  const contentsSubTabs = document.querySelectorAll('.contents-sub-tab');
  contentsSubTabs.forEach(tab => {
    tab.classList.remove('active');
    if (tab.dataset.contentType === currentContentsRankingType) {
      tab.classList.add('active');
    }
  });
  
  window.contentsRankingFiltersInitializing = false;

  // 직업 필터 초기화
  const jobFilterButtons = document.querySelectorAll('#contents-ranking-job-filters .ranking-filter-btn');
  jobFilterButtons.forEach(btn => {
    btn.classList.remove('active');
    if (btn.getAttribute('data-value') === 'all') {
      btn.classList.add('active');
    }
  });

  // 서버 필터 탭 초기화
  const serverTabButtons = document.querySelectorAll('.contents-server-tab');
  serverTabButtons.forEach(btn => {
    btn.classList.remove('active');
    btn.style.background = 'rgba(255, 255, 255, 0.05)';
    btn.style.borderColor = 'var(--card-border)';
    btn.style.color = 'var(--text-primary)';
    if (btn.getAttribute('data-race') === 'all') {
      btn.classList.add('active');
      btn.style.background = 'rgba(157, 140, 255, 0.16)';
      btn.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      btn.style.color = 'var(--accent)';
    }
  });

  // 서버 필터 초기화
  if (typeof updateContentsServerFilters === 'function') {
    updateContentsServerFilters('all');
  }
}

// 컨텐츠 랭킹 서버 필터 업데이트
function updateContentsServerFilters(race) {
  const serverFilterContainer = document.getElementById('contents-ranking-server-filters');
  if (!serverFilterContainer || !servers) return;
  
  const existingButtons = serverFilterContainer.querySelectorAll('.ranking-filter-btn:not([data-value="all"])');
  existingButtons.forEach(btn => btn.remove());
  
  if (race === 'all') {
    serverFilterContainer.style.display = 'none';
    return;
  }
  
  serverFilterContainer.style.display = 'flex';
  
  let serversToShow = [];
  if (race === 'elyos' && servers.elyos) {
    servers.elyos.forEach(s => {
      serversToShow.push(s.name);
    });
  } else if (race === 'asmodian' && servers.asmodian) {
    servers.asmodian.forEach(s => {
      serversToShow.push(s.name);
    });
  }
  
  serversToShow.forEach(serverName => {
    const btn = document.createElement('button');
    btn.className = 'ranking-filter-btn';
    btn.setAttribute('data-filter-type', 'server');
    btn.setAttribute('data-value', serverName);
    btn.textContent = serverName;
    btn.addEventListener('click', () => {
      currentContentsServerFilter = serverName;
      serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      
      // URL 업데이트
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter
      );
      updateURL(contentsRankingURL);
      
      loadContentsRanking();
    });
    serverFilterContainer.appendChild(btn);
  });
}

// 컨텐츠 랭킹 로드
function loadContentsRanking(page = 1) {
  currentContentsPage = page;
  const params = new URLSearchParams();
  params.append('type', currentContentsRankingType);
  
  if (currentContentsJobFilter && currentContentsJobFilter !== 'all') {
    params.append('job', currentContentsJobFilter);
  } else {
    params.append('job', 'all');
  }
  
  if (currentContentsServerFilter && currentContentsServerFilter !== 'all') {
    params.append('server', currentContentsServerFilter);
  } else {
    params.append('server', 'all');
  }
  
  if (currentContentsServerRaceFilter && currentContentsServerRaceFilter !== 'all') {
    params.append('race', currentContentsServerRaceFilter);
  } else {
    params.append('race', 'all');
  }
  
  params.append('page', page);
  params.append('per_page', 10);
  
  const contentsRankingBody = document.getElementById('contents-ranking-body');
  const contentsRankingPagination = document.getElementById('contents-ranking-pagination');
  
  if (!contentsRankingBody) return;
  
      contentsRankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">컨텐츠 랭킹 데이터를 불러오는 중...</td></tr>';
  
  const apiUrl = `/api/contents-rankings?${params.toString()}`;
  
  fetch(apiUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data.success) {
        contentsRankingBody.innerHTML = `<tr><td colspan="7" style="text-align:center; padding:1rem;">${data.error || '컨텐츠 랭킹 데이터를 불러오지 못했습니다.'}</td></tr>`;
        if (contentsRankingPagination) {
          contentsRankingPagination.style.display = 'none';
        }
        return;
      }

      // 마지막 업데이트 시간 표시
      const lastUpdateEl = document.getElementById('contents-ranking-last-update');
      if (lastUpdateEl) {
        if (data.last_update) {
          lastUpdateEl.textContent = `마지막 업데이트: ${data.last_update}`;
        } else {
          lastUpdateEl.textContent = '마지막 업데이트: -';
        }
      }
      
      const rows = data.data || [];
      if (!rows.length) {
        contentsRankingBody.innerHTML = '<tr><td colspan="7" style="text-align:center; padding:1rem;">컨텐츠 랭킹 데이터가 없습니다.</td></tr>';
        if (contentsRankingPagination) {
          contentsRankingPagination.style.display = 'none';
        }
        return;
      }
      
      // 테이블 헤더는 항상 "점수"로 고정 (HTML에서 이미 설정됨)
      
      // 모바일 여부 확인
      const isMobile = window.innerWidth <= 768;
      
      // 테이블 행 생성
      contentsRankingBody.innerHTML = '';
      
      // 모바일에서 테이블 헤더 스타일 적용
      if (isMobile) {
        const contentsRankingTable = document.getElementById('contents-ranking-table');
        if (contentsRankingTable) {
          contentsRankingTable.style.tableLayout = 'fixed';
          contentsRankingTable.style.width = '100%';
          contentsRankingTable.style.maxWidth = '100%';
          
          const headerCells = contentsRankingTable.querySelectorAll('thead th');
          headerCells.forEach(headerCell => {
            if (headerCell.classList.contains('col-rank')) {
              headerCell.style.width = '15%';
              headerCell.style.minWidth = '15%';
              headerCell.style.maxWidth = '15%';
              headerCell.style.display = 'table-cell';
            } else if (headerCell.classList.contains('col-nickname')) {
              headerCell.style.width = '40%';
              headerCell.style.minWidth = '40%';
              headerCell.style.maxWidth = '40%';
              headerCell.style.display = 'table-cell';
            } else if (headerCell.classList.contains('col-server')) {
              headerCell.style.width = '25%';
              headerCell.style.minWidth = '25%';
              headerCell.style.maxWidth = '25%';
              headerCell.style.display = 'table-cell';
            } else if (headerCell.classList.contains('col-power')) {
              headerCell.style.width = '20%';
              headerCell.style.minWidth = '20%';
              headerCell.style.maxWidth = '20%';
              headerCell.style.display = 'table-cell';
            } else {
              // 직업, 종족, 레기온 헤더는 숨김
              headerCell.style.display = 'none';
            }
          });
        }
      }
      
      rows.forEach((row, index) => {
        const rank = (page - 1) * 10 + index + 1;
        const jobLabel = row.job || '';
        const jobImageUrl = row.job_image_url || '';
        const guild = row.guild || '-';
        const nickname = row.nickname || '';
        const serverName = row.server || '';
        const raceName = row.race || '';
        const rankingValue = row.ranking_value || 0;
        
        let raceValue = '';
        let serverId = '';
        
        if (raceName === '천족') {
          raceValue = '1';
          if (servers && servers.elyos) {
            const serverInfo = servers.elyos.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        } else if (raceName === '마족') {
          raceValue = '2';
          if (servers && servers.asmodian) {
            const serverInfo = servers.asmodian.find(s => s.name === serverName);
            if (serverInfo) serverId = serverInfo.id;
          }
        }
        
        let jobCell = '';
        if (jobImageUrl) {
          jobCell = `<img src="${jobImageUrl}" alt="${jobLabel}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">${jobLabel}`;
        } else {
          jobCell = jobLabel;
        }
        
        const nicknameCell = serverId && raceValue 
          ? `<a href="/?nickname=${encodeURIComponent(nickname)}&race=${raceValue}&server=${serverId}" class="nickname-link" style="color: var(--accent); text-decoration: none; cursor: pointer;">${nickname}</a>`
          : nickname;
        
        let raceCell = raceName;
        if (raceName === '천족') {
          raceCell = `<span style="color: #4a90e2;">${raceName}</span>`;
        } else if (raceName === '마족') {
          raceCell = `<span style="color: #e24a4a;">${raceName}</span>`;
        }
        
        // DOM 요소로 행 생성
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="col-rank">${rank}</td>
          <td class="col-nickname">${nicknameCell}</td>
          <td class="col-job">${jobCell}</td>
          <td class="col-race">${raceCell}</td>
          <td class="col-server">${serverName}</td>
          <td class="col-guild">${guild}</td>
          <td class="col-power" style="text-align: right;">${rankingValue ? rankingValue.toLocaleString() : '-'}</td>
        `;
        
        // 모바일에서 각 셀에 스타일 직접 적용 (내실 랭킹과 동일한 방식)
        if (isMobile) {
          tr.style.width = '100%';
          tr.style.maxWidth = '100%';
          tr.style.boxSizing = 'border-box';
          
          const cells = tr.querySelectorAll('td');
          cells.forEach(cell => {
            cell.style.boxSizing = 'border-box';
            
            if (cell.classList.contains('col-rank')) {
              cell.style.width = '15%';
              cell.style.minWidth = '15%';
              cell.style.maxWidth = '15%';
              cell.style.display = 'table-cell';
            } else if (cell.classList.contains('col-nickname')) {
              cell.style.width = '40%';
              cell.style.minWidth = '40%';
              cell.style.maxWidth = '40%';
              cell.style.display = 'table-cell';
            } else if (cell.classList.contains('col-server')) {
              cell.style.width = '25%';
              cell.style.minWidth = '25%';
              cell.style.maxWidth = '25%';
              cell.style.display = 'table-cell';
            } else if (cell.classList.contains('col-power')) {
              cell.style.width = '20%';
              cell.style.minWidth = '20%';
              cell.style.maxWidth = '20%';
              cell.style.display = 'table-cell';
              cell.style.textAlign = 'right';
              cell.style.fontWeight = '600';
              cell.style.color = 'var(--accent)';
            } else {
              // 직업, 종족, 레기온은 숨김
              cell.style.display = 'none';
            }
          });
        }
        
        contentsRankingBody.appendChild(tr);
      });
      
      // 닉네임 클릭 이벤트 추가
      contentsRankingBody.querySelectorAll('.nickname-link').forEach(link => {
        link.addEventListener('click', function(e) {
          // 마우스 휠 클릭(중간 클릭)이나 Ctrl+클릭, Shift+클릭(새 탭/새 창)은 기본 동작 허용
          if (e.button === 1 || e.ctrlKey || e.metaKey || e.shiftKey) {
            return; // 기본 동작 허용 (새 탭으로 열기)
          }
          
          // 일반 클릭은 preventDefault하고 직접 검색 수행
          e.preventDefault();
          
          const href = this.getAttribute('href');
          if (href && href.startsWith('/?nickname=')) {
            const urlParams = new URLSearchParams(href.substring(2));
            const nickname = urlParams.get('nickname');
            const race = urlParams.get('race');
            const serverId = urlParams.get('server');
            
            if (nickname && race && serverId) {
              // 로딩 표시를 먼저 설정
              document.getElementById('character-result').style.display = 'none';
              document.getElementById('character-all-servers-result').style.display = 'none';
              document.getElementById('character-loading').style.display = 'block';
              const contentsLoadingOverlay = document.getElementById('fullscreen-loading-overlay');
              if (contentsLoadingOverlay) {
                contentsLoadingOverlay.style.display = 'flex';
              }
              
              // 캐릭터 검색 탭으로 이동
              const characterTab = document.getElementById('tab-character');
              if (characterTab) {
                characterTab.checked = true;
                characterTab.dispatchEvent(new Event('change'));
                updateSidebarVisibility();
                
                // 종족 버튼 업데이트
                if (race) {
                  updateRaceSelection(race, true);
                }
                
                // 검색 폼에 값 설정
                const serverSelect = document.getElementById('server-select');
                const keywordInput = document.getElementById('character-keyword');
                
                // 서버 선택이 활성화될 때까지 대기
                setTimeout(() => {
                  if (serverSelect) {
                    serverSelect.value = serverId;
                    if (keywordInput) keywordInput.value = nickname;
                    
                    // 로딩 표시 유지
                    document.getElementById('character-loading').style.display = 'block';
                    const contentsLoadingOverlay2 = document.getElementById('fullscreen-loading-overlay');
                    if (contentsLoadingOverlay2) {
                      contentsLoadingOverlay2.style.display = 'flex';
                    }
                    
                    // 검색 실행
                    performSearch();
                  }
                }, 300);
              }
            }
          }
        });
      });
      
      // 페이지네이션 렌더링
      if (data.pagination && data.pagination.total_pages > 1) {
        renderContentsRankingPagination(data.pagination);
      } else {
        if (contentsRankingPagination) {
          contentsRankingPagination.style.display = 'none';
        }
      }
    })
    .catch(err => {
      contentsRankingBody.innerHTML = `<tr><td colspan="7" style="text-align:center; padding:1rem;">컨텐츠 랭킹 데이터를 불러오는 중 오류가 발생했습니다: ${err.message}</td></tr>`;
      if (contentsRankingPagination) {
        contentsRankingPagination.style.display = 'none';
      }
    });
}

// 컨텐츠 랭킹 페이지네이션 렌더링
function renderContentsRankingPagination(pagination) {
  const paginationEl = document.getElementById('contents-ranking-pagination');
  if (!paginationEl) return;
  
  const { page, total_pages, total_count } = pagination;
  
  paginationEl.style.display = 'flex';
  paginationEl.innerHTML = '';
  
  // 이전 버튼
  const prevBtn = document.createElement('button');
  prevBtn.textContent = '이전';
  prevBtn.disabled = page <= 1;
  prevBtn.style.padding = '0.5rem 1rem';
  prevBtn.style.border = '1px solid var(--card-border)';
  prevBtn.style.borderRadius = '8px';
  prevBtn.style.background = page <= 1 ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.1)';
  prevBtn.style.color = page <= 1 ? 'var(--text-muted)' : 'var(--text-primary)';
  prevBtn.style.cursor = page <= 1 ? 'not-allowed' : 'pointer';
  if (page > 1) {
    prevBtn.addEventListener('click', () => {
      loadContentsRanking(page - 1);
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter,
        page - 1
      );
      updateURL(contentsRankingURL);
    });
  }
  paginationEl.appendChild(prevBtn);
  
  // 페이지 번호
  const maxVisible = 5;
  let startPage = Math.max(1, page - Math.floor(maxVisible / 2));
  let endPage = Math.min(total_pages, startPage + maxVisible - 1);
  
  if (endPage - startPage < maxVisible - 1) {
    startPage = Math.max(1, endPage - maxVisible + 1);
  }
  
  if (startPage > 1) {
    const firstBtn = document.createElement('button');
    firstBtn.textContent = '1';
    firstBtn.style.padding = '0.5rem 1rem';
    firstBtn.style.border = '1px solid var(--card-border)';
    firstBtn.style.borderRadius = '8px';
    firstBtn.style.background = 'rgba(255, 255, 255, 0.1)';
    firstBtn.style.color = 'var(--text-primary)';
    firstBtn.addEventListener('click', () => {
      loadContentsRanking(1);
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter,
        1
      );
      updateURL(contentsRankingURL);
    });
    paginationEl.appendChild(firstBtn);
    
    if (startPage > 2) {
      const ellipsis = document.createElement('span');
      ellipsis.textContent = '...';
      ellipsis.style.padding = '0.5rem';
      ellipsis.style.color = 'var(--text-muted)';
      paginationEl.appendChild(ellipsis);
    }
  }
  
  for (let i = startPage; i <= endPage; i++) {
    const pageBtn = document.createElement('button');
    pageBtn.textContent = i;
    pageBtn.style.padding = '0.5rem 1rem';
    pageBtn.style.border = '1px solid var(--card-border)';
    pageBtn.style.borderRadius = '8px';
    if (i === page) {
      pageBtn.style.background = 'rgba(157, 140, 255, 0.16)';
      pageBtn.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      pageBtn.style.color = 'var(--accent)';
    } else {
      pageBtn.style.background = 'rgba(255, 255, 255, 0.1)';
      pageBtn.style.color = 'var(--text-primary)';
    }
    pageBtn.addEventListener('click', () => {
      loadContentsRanking(i);
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter,
        i
      );
      updateURL(contentsRankingURL);
    });
    paginationEl.appendChild(pageBtn);
  }
  
  if (endPage < total_pages) {
    if (endPage < total_pages - 1) {
      const ellipsis = document.createElement('span');
      ellipsis.textContent = '...';
      ellipsis.style.padding = '0.5rem';
      ellipsis.style.color = 'var(--text-muted)';
      paginationEl.appendChild(ellipsis);
    }
    
    const lastBtn = document.createElement('button');
    lastBtn.textContent = total_pages;
    lastBtn.style.padding = '0.5rem 1rem';
    lastBtn.style.border = '1px solid var(--card-border)';
    lastBtn.style.borderRadius = '8px';
    lastBtn.style.background = 'rgba(255, 255, 255, 0.1)';
    lastBtn.style.color = 'var(--text-primary)';
    lastBtn.addEventListener('click', () => {
      loadContentsRanking(total_pages);
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter,
        total_pages
      );
      updateURL(contentsRankingURL);
    });
    paginationEl.appendChild(lastBtn);
  }
  
  // 다음 버튼
  const nextBtn = document.createElement('button');
  nextBtn.textContent = '다음';
  nextBtn.disabled = page >= total_pages;
  nextBtn.style.padding = '0.5rem 1rem';
  nextBtn.style.border = '1px solid var(--card-border)';
  nextBtn.style.borderRadius = '8px';
  nextBtn.style.background = page >= total_pages ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.1)';
  nextBtn.style.color = page >= total_pages ? 'var(--text-muted)' : 'var(--text-primary)';
  nextBtn.style.cursor = page >= total_pages ? 'not-allowed' : 'pointer';
  if (page < total_pages) {
    nextBtn.addEventListener('click', () => {
      loadContentsRanking(page + 1);
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter,
        page + 1
      );
      updateURL(contentsRankingURL);
    });
  }
  paginationEl.appendChild(nextBtn);
  
  // 페이지 정보 표시
  const infoText = document.createElement('span');
  infoText.textContent = `${total_count}명 중 ${(page - 1) * 10 + 1}-${Math.min(page * 10, total_count)}명`;
  infoText.style.marginLeft = '1rem';
  infoText.style.color = 'var(--text-muted)';
  infoText.style.fontSize = '0.9rem';
  paginationEl.appendChild(infoText);
}

// 컨텐츠 랭킹 URL 생성
function buildContentsRankingURL(type, job, race, server, page = 1) {
  const parts = ['ranking', 'contents'];
  
  // 컨텐츠 타입 매핑
  const typeMap = {
    'abyss': 'abyss',
    'solo_arena': 'solo_arena',
    'coop_arena': 'coop_arena',
    'nightmare': 'nightmare',
    'transcendence': 'transcendence',
    'awakening': 'awakening',
    'subjugation': 'subjugation'
  };
  const typeValue = typeMap[type] || 'abyss';
  parts.push(typeValue);
  
  if (job && job !== 'all') parts.push(job);
  if (race && race !== 'all') {
    parts.push(race === 'elyos' ? '천족' : race === 'asmodian' ? '마족' : race);
  }
  if (server && server !== 'all') parts.push(server);
  
  return parts.join('/');
}

// 컨텐츠 랭킹 이벤트 리스너 초기화 함수 (전역 함수)
function setupContentsRankingEventListeners() {
  
  // 이벤트 위임을 사용하여 컨텐츠 랭킹 컨텐츠 영역에서 서브탭 클릭 처리
  const contentsRankingContent = document.getElementById('contents-ranking-content');
  if (!contentsRankingContent) {
    return;
  }
  
  // 컨텐츠 랭킹 서브탭은 이제 <a> 태그로 페이지 이동 처리
  // 클릭 이벤트 등록 불필요
  
  // 컨텐츠 랭킹 직업 필터 버튼 클릭 이벤트
  const contentsJobFilterButtons = document.querySelectorAll('#contents-ranking-job-filters .ranking-filter-btn');
  contentsJobFilterButtons.forEach(btn => {
    btn.addEventListener('click', function() {
      const job = this.getAttribute('data-value') || 'all';
      currentContentsJobFilter = job;
      
      // active 클래스 토글
      contentsJobFilterButtons.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      // URL 업데이트
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter
      );
      updateURL(contentsRankingURL);
      
      // 데이터 다시 로드
      loadContentsRanking(1);
    });
  });
  
  // 컨텐츠 랭킹 서버 필터 탭 버튼 (전체/천족/마족)
  const contentsServerTabButtons = document.querySelectorAll('.contents-server-tab');
  contentsServerTabButtons.forEach(tabBtn => {
    tabBtn.addEventListener('click', function() {
      const race = this.getAttribute('data-race');
      currentContentsServerRaceFilter = race;
      currentContentsServerFilter = 'all';
      
      // 탭 버튼 active 토글
      contentsServerTabButtons.forEach(b => {
        b.classList.remove('active');
        b.style.background = 'rgba(255, 255, 255, 0.05)';
        b.style.borderColor = 'var(--card-border)';
        b.style.color = 'var(--text-primary)';
      });
      this.classList.add('active');
      this.style.background = 'rgba(157, 140, 255, 0.16)';
      this.style.borderColor = 'rgba(157, 140, 255, 0.9)';
      this.style.color = 'var(--accent)';
      
      // 서버 버튼 업데이트
      updateContentsServerFilters(race);
      
      // 전체 탭이면 전체 서버 버튼 활성화
      if (race === 'all') {
        const serverFilterContainer = document.getElementById('contents-ranking-server-filters');
        if (serverFilterContainer) {
          const allServerBtn = serverFilterContainer.querySelector('[data-value="all"]');
          if (allServerBtn) {
            serverFilterContainer.querySelectorAll('.ranking-filter-btn').forEach(b => b.classList.remove('active'));
            allServerBtn.classList.add('active');
          }
        }
      }
      
      // URL 업데이트
      const contentsRankingURL = buildContentsRankingURL(
        currentContentsRankingType,
        currentContentsJobFilter,
        currentContentsServerRaceFilter,
        currentContentsServerFilter
      );
      updateURL(contentsRankingURL);
      
      // 데이터 다시 로드
      loadContentsRanking(1);
    });
  });
  
}

// 스탯 정보 모달 관련 함수들
let currentStatModal = null;

function openStatModal(statType, statValue, breakdownData, description) {
  const modal = document.getElementById('stat-info-modal');
  if (!modal) return;
  
  const modalContent = modal.querySelector('.stat-info-modal-content');
  const modalTitle = modal.querySelector('.stat-info-modal-title');
  const breakdownSection = modal.querySelector('.stat-info-breakdown-section');
  const descriptionSection = modal.querySelector('.stat-info-description-section');
  const conclusionDiv = modal.querySelector('.stat-info-conclusion');
  const damageIncreaseDiv = modal.querySelector('.stat-info-damage-increase');
  
  // 제목 설정
  const statNames = {
    'attack-power': '공격력',
    'attack-power-cap': '공격력 % 캡',
    'combat-speed': '전투 속도',
    'weapon-damage-amplification': '무기 피해 증폭',
    'pve-damage-amplification': 'PVE/보스 피해 증폭',
    'damage-amplification': '피해 증폭',
    'critical-damage-amplification': '치명타 피해 증폭',
    'skill-damage': '스킬',
    'cooldown-reduction': '재사용 대기 시간 감소',
    'critical-hit': '치명타',
    'stun-hit': '강타',
    'perfect': '완벽',
    'multi-hit': '다단 히트 적중'
  };
  
  modalTitle.textContent = statNames[statType] || statType;
  
  // Breakdown 표시
  let breakdownHTML = '<div class="stat-info-breakdown-title">Breakdown</div><div style="display: flex; flex-direction: column; gap: 0.4rem;">';
  let totalInteger = 0;
  let totalPercent = 0;
  let hasInteger = false;
  let hasPercent = false;
  
  if (breakdownData && breakdownData.length > 0) {
    breakdownData.forEach(item => {
      breakdownHTML += `
        <div class="stat-info-breakdown-item">
          <span>${item.label}</span>
          <span class="stat-info-breakdown-value">${item.value}</span>
        </div>
      `;
      
      // 값에서 숫자 추출
      const valueStr = item.value;
      const hasPercentSign = valueStr.includes('%');
      
      // 괄호 안의 숫자도 추출 (예: +200 (2.0%))
      const parenMatch = valueStr.match(/\(([0-9.]+)%?\)/);
      
      // 메인 값 추출 (괄호 전까지)
      const mainValueStr = valueStr.split('(')[0].trim();
      const mainNumericValue = parseFloat(mainValueStr.replace(/[^0-9.-]/g, '')) || 0;
      
      if (parenMatch) {
        // "+200 (2.0%)" 형식: 정수와 퍼센티지 둘 다
        const percentInParen = parseFloat(parenMatch[1]) || 0;
        totalInteger += mainNumericValue;
        totalPercent += percentInParen;
        hasInteger = true;
        hasPercent = true;
      } else if (hasPercentSign) {
        // "+11.1%" 형식: 퍼센티지만
        totalPercent += mainNumericValue;
        hasPercent = true;
      } else {
        // "+200" 형식: 정수만
        totalInteger += mainNumericValue;
        hasInteger = true;
      }
    });
    
    // 합계 표시 (breakdown 항목이 있을 때만)
    if (breakdownData.length > 0) {
      let totalDisplay = '';
      
      // 공격력: 실제 표시된 공격력 값 사용 (statValue에 전달된 값)
      if (statType === 'attack-power') {
        if (statValue && statValue > 0) {
          // 실제 표시된 공격력 값 사용
          totalDisplay = `+${Math.round(statValue).toLocaleString()}`;
        } else if (hasInteger && hasPercent) {
          // fallback: 정수 합계에 퍼센트 증가량을 적용한 최종 공격력
          const finalAttackPower = Math.round(totalInteger * (1 + totalPercent / 100));
          totalDisplay = `+${finalAttackPower.toLocaleString()}`;
        } else if (hasInteger) {
          totalDisplay = `+${Math.round(totalInteger).toLocaleString()}`;
        } else if (hasPercent) {
          totalDisplay = `+${totalPercent.toFixed(1)}%`;
        }
      }
      // 치명타: statValue를 우선 사용 (이미 계산된 값)
      else if (statType === 'critical-hit') {
        if (statValue && statValue > 0) {
          // 이미 계산된 최종 치명타 스탯 사용
          totalDisplay = `+${Math.round(statValue).toLocaleString()}`;
        } else if (hasInteger && hasPercent) {
          // fallback: breakdown의 정수 합계에 퍼센트 합계를 적용 (합연산)
          const finalCriticalHit = Math.round(totalInteger * (1 + totalPercent / 100));
          totalDisplay = `+${finalCriticalHit.toLocaleString()}`;
        } else if (hasInteger) {
          totalDisplay = `+${Math.round(totalInteger).toLocaleString()}`;
        }
      }
      // 무기 피해 증폭, 피해 증폭, 치명타 피해 증폭: 퍼센트만 표시
      else if (statType === 'weapon-damage-amplification' || statType === 'damage-amplification' || statType === 'critical-damage-amplification') {
        if (hasPercent) {
          totalDisplay = `+${totalPercent.toFixed(1)}%`;
        }
      }
      // 기타: 정수와 퍼센티지 둘 다 있는 경우 둘 다 표시
      else if (hasInteger && hasPercent) {
        totalDisplay = `+${Math.round(totalInteger).toLocaleString()} (+${totalPercent.toFixed(1)}%)`;
      } else if (hasInteger) {
        totalDisplay = `+${Math.round(totalInteger).toLocaleString()}`;
      } else if (hasPercent) {
        totalDisplay = `+${totalPercent.toFixed(1)}%`;
      }
      
      if (totalDisplay) {
        breakdownHTML += `
          <div class="stat-info-breakdown-item" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255, 255, 255, 0.1);">
            <span style="font-weight: 600;">합계</span>
            <span style="color: #4ade80; font-weight: 600; font-size: 0.95rem;">${totalDisplay}</span>
          </div>
        `;
      }
    }
  }
  breakdownHTML += '</div>';
  
  // 공격력 breakdown 밑에 메시지 추가
  if (statType === 'attack-power') {
    breakdownHTML += `
      <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 6px; font-size: 0.8rem; color: #ffc107; line-height: 1.5;">
        일부 클래스의 패시브 스킬로 인한 공격력 증가는 표기에 포함되지 않으며, 패시브 스킬로 인한 전투 점수 향상은 '스킬'에 포함됩니다. 날개의 장착/보유 효과, 타이틀 보유 효과 등 일부 내실로 인한 추가 공격력 증가는 계산이 불가합니다, 이에 따라 실제 인게임 공격력/치명타보다 낮을 수 있습니다.
      </div>
      <div style="margin-top: 0.75rem; font-size: 0.75rem; color: var(--text-muted); line-height: 1.4;">
        전투 점수 계산에 베이스가 되는 공격력입니다.
      </div>
    `;
  }
  
  breakdownSection.innerHTML = breakdownHTML;
  
  // 설명 및 딜증 계산
  if (description) {
    let descriptionHTML = `<div class="stat-info-description-title">${statNames[statType]}</div>`;
    // 수학 공식이 포함된 텍스트를 처리
    let descriptionText = description.text;
    // LaTeX 스타일 수식을 HTML로 변환
    descriptionText = descriptionText.replace(/\$\$([^$]+)\$\$/g, '<div style="margin: 0.75rem 0; padding: 0.75rem; background: rgba(157, 140, 255, 0.1); border-left: 3px solid rgba(157, 140, 255, 0.5); font-family: monospace; font-size: 0.9rem; line-height: 1.6;">$1</div>');
    descriptionText = descriptionText.replace(/\$([^$]+)\$/g, '<span style="font-family: monospace; background: rgba(157, 140, 255, 0.15); padding: 0.1rem 0.3rem; border-radius: 3px;">$1</span>');
    descriptionHTML += '<div class="stat-info-description-text">' + descriptionText + '</div>';
    
    if (description.damageIncrease) {
      // 공격력과 치명타는 damageIncrease 표시 안함 (null이 아닐 경우만)
      if (statType !== 'attack-power' && statType !== 'critical-hit') {
        descriptionHTML += `<div class="stat-info-damage-increase">전투 점수 +${description.damageIncrease}</div>`;
      }
    }
    
    descriptionSection.innerHTML = descriptionHTML;
  } else {
    descriptionSection.innerHTML = '';
  }
  
  // 모달을 body에 직접 append하여 viewport 중앙에 표시되도록 함
  if (modal.parentElement !== document.body) {
    document.body.appendChild(modal);
  }
  
  modal.classList.add('active');
  currentStatModal = statType;
  document.body.style.overflow = 'hidden';
  
  // 스크롤 위치를 viewport 최상단으로 이동
  modal.scrollTop = 0;
}

// 영혼각인 등급 설명 모달 열기 함수 (openStatModal과 동일한 방식)
function openSoulEngravingGradeModal() {
  const modal = document.getElementById('soul-engraving-grade-modal');
  if (!modal) return;
  
  // 모달을 body에 직접 append하여 viewport 중앙에 표시되도록 함
  if (modal.parentElement !== document.body) {
    document.body.appendChild(modal);
  }
  
  modal.classList.add('active');
  currentStatModal = 'soul-engraving-grade';
  document.body.style.overflow = 'hidden';
  
  // 스크롤 위치를 viewport 최상단으로 이동
  modal.scrollTop = 0;
}

// 영혼각인 등급 설명 모달 닫기 함수 (closeStatModal과 동일한 방식)
function closeEquipmentSummaryModal() {
  const modal = document.getElementById('equipment-summary-modal');
  if (modal) {
    modal.classList.remove('active');
    document.body.style.overflow = '';
  }
}

function openEquipmentSummaryModal() {
  const modal = document.getElementById('equipment-summary-modal');
  if (modal) {
    // 모달을 body로 이동 (position: fixed가 제대로 작동하도록)
    if (modal.parentElement !== document.body) {
      document.body.appendChild(modal);
    }
    
    // 장비/장신구 요약 데이터 채우기
    populateEquipmentSummary();
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';
    
    // 스크롤 위치를 viewport 최상단으로 이동
    modal.scrollTop = 0;
  }
}

function populateEquipmentSummary() {
  const equipmentList = document.getElementById('equipment-summary-list');
  const accessoriesList = document.getElementById('accessories-summary-list');
  
  if (!equipmentList || !accessoriesList) return;
  
  // 기존 내용 초기화
  equipmentList.innerHTML = '';
  accessoriesList.innerHTML = '';
  
  // 전역 변수에서 장비/장신구 데이터 가져오기
  const equipment = window.currentEquipment || [];
  const accessories = window.currentAccessories || [];
  
  // 아르카나 제외한 일반 장비/장신구만 표시
  const regularEquipment = equipment.filter(item => !isArcanaItem(item));
  const regularAccessories = accessories.filter(item => !isArcanaItem(item));
  
  // 장비 추가
  regularEquipment.forEach(item => {
    const summaryItem = createEquipmentSummaryItem(item);
    if (summaryItem) {
      equipmentList.appendChild(summaryItem);
    }
  });
  
  // 장신구 추가
  regularAccessories.forEach(item => {
    const summaryItem = createEquipmentSummaryItem(item);
    if (summaryItem) {
      accessoriesList.appendChild(summaryItem);
    }
  });
  
  // 빈 상태 메시지
  if (equipmentList.children.length === 0) {
    equipmentList.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 1rem;">장비 정보 없음</div>';
  }
  if (accessoriesList.children.length === 0) {
    accessoriesList.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 1rem;">장신구 정보 없음</div>';
  }
}

function createEquipmentSummaryItem(item) {
  if (!item || !item.name) {
    return null;
  }
  
  // 요약 아이템 생성
  const summaryItem = document.createElement('div');
  summaryItem.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; background: rgba(255, 255, 255, 0.05); border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1);';
  
  // 아이콘
  if (item.icon_url) {
    const icon = document.createElement('img');
    icon.src = item.icon_url;
    icon.alt = item.name;
    icon.style.cssText = 'width: 40px; height: 40px; border-radius: 6px; object-fit: contain; flex-shrink: 0;';
    icon.onerror = function() {
      this.style.display = 'none';
    };
    summaryItem.appendChild(icon);
  }
  
  // 정보 컨테이너
  const infoContainer = document.createElement('div');
  infoContainer.style.cssText = 'flex: 1; min-width: 0;';
  
  // 이름 + 강화 수치
  const nameRow = document.createElement('div');
  nameRow.style.cssText = 'font-size: 0.85rem; font-weight: 600; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem; flex-wrap: wrap;';
  
  // 초월 레벨 배지
  const exceedLevel = item.exceed_level || 0;
  if (exceedLevel > 0) {
    const exceedBadge = document.createElement('span');
    exceedBadge.style.cssText = `
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, #87ceeb 0%, #5ba3f5 100%);
      border: 1px solid rgba(255, 255, 255, 0.4);
      transform: rotate(45deg);
      font-size: 0.7rem;
      font-weight: 700;
      color: #ffffff;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      line-height: 1;
    `;
    const badgeText = document.createElement('span');
    badgeText.style.cssText = 'display: inline-block; transform: rotate(-45deg); line-height: 1;';
    badgeText.textContent = exceedLevel;
    exceedBadge.appendChild(badgeText);
    nameRow.appendChild(exceedBadge);
  }
  
  // 강화 수치와 이름
  const enhanceLevel = item.enhance_level || 0;
  const nameSpan = document.createElement('span');
  if (enhanceLevel > 0) {
    nameSpan.innerHTML = `<span style="color: #4ade80; font-weight: 700;">+${enhanceLevel}</span> ${item.name}`;
  } else {
    nameSpan.textContent = item.name;
  }
  
  // 등급 색상 적용
  const grade = item.grade || '';
  if (grade) {
    const gradeColor = getGradeColor(grade);
    if (gradeColor) {
      nameSpan.style.color = gradeColor;
    }
  } else {
    nameSpan.style.color = 'var(--text-primary)';
  }
  
  nameRow.appendChild(nameSpan);
  infoContainer.appendChild(nameRow);
  
  // 아이템 레벨
  const itemLevel = parseInt(item.level, 10);
  if (!isNaN(itemLevel) && itemLevel > 0) {
    const levelRow = document.createElement('div');
    levelRow.style.cssText = 'font-size: 0.75rem; color: #5b9cff; margin-bottom: 0.15rem;';
    let levelText = `아이템 레벨 +${itemLevel}`;
    
    // level_value가 있으면 추가
    const levelBonus = parseInt(item.level_value, 10);
    if (!isNaN(levelBonus) && levelBonus > 0) {
      levelText += ` (+${levelBonus})`;
    }
    
    levelRow.textContent = levelText;
    infoContainer.appendChild(levelRow);
  }
  
  // 초월 정보
  if (item.transcend_info && item.transcend_info.length > 0) {
    const transcendRow = document.createElement('div');
    transcendRow.style.cssText = 'font-size: 0.7rem; color: #a855f7; font-weight: 600;';
    const transcendTexts = item.transcend_info.map(t => `${t.stat_name}: ${t.value}`);
    transcendRow.textContent = `초월: ${transcendTexts.join(', ')}`;
    infoContainer.appendChild(transcendRow);
  }
  
  summaryItem.appendChild(infoContainer);
  
  return summaryItem;
}

function closeSoulEngravingGradeModal() {
  const modal = document.getElementById('soul-engraving-grade-modal');
  if (modal) {
    modal.classList.remove('active');
    currentStatModal = null;
    document.body.style.overflow = '';
  }
}

function closeStatModal() {
  const modal = document.getElementById('stat-info-modal');
  if (modal) {
    modal.classList.remove('active');
    currentStatModal = null;
    document.body.style.overflow = '';
  }
}

// 모달 외부 클릭 시 닫기
document.addEventListener('DOMContentLoaded', function() {
  const modal = document.getElementById('stat-info-modal');
  if (modal) {
    modal.addEventListener('click', function(e) {
      if (e.target === modal) {
        closeStatModal();
      }
    });
    
    const closeBtn = modal.querySelector('.stat-info-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeStatModal);
    }
  }
  
  // ESC 키로 모달 닫기
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      if (currentStatModal === 'soul-engraving-grade') {
        closeSoulEngravingGradeModal();
      } else if (currentStatModal) {
        closeStatModal();
      }
    }
  });
  
  // 각 i 버튼에 클릭 이벤트 추가
  setupStatInfoButtons();
  
  // 영혼각인 등급 설명 모달 닫기 버튼 이벤트
  const soulEngravingGradeModal = document.getElementById('soul-engraving-grade-modal');
  if (soulEngravingGradeModal) {
    const closeBtn = soulEngravingGradeModal.querySelector('.stat-info-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeSoulEngravingGradeModal);
    }
    
    // 모달 배경 클릭 시 닫기
    soulEngravingGradeModal.addEventListener('click', function(e) {
      if (e.target === soulEngravingGradeModal) {
        closeSoulEngravingGradeModal();
      }
    });
  }
  
  // "장비" 제목 옆 "?" 버튼 이벤트 리스너
  function setupSoulEngravingGradeHelpButton() {
    const helpBtn = document.querySelector('.soul-engraving-grade-help-btn');
    if (helpBtn) {
      helpBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        openSoulEngravingGradeModal();
      });
    }
  }
  
  // "장비" 제목 옆 "장비 한눈에 보기" 버튼 이벤트 리스너
  function setupEquipmentSummaryButton() {
    const summaryBtn = document.querySelector('.equipment-summary-btn');
    if (summaryBtn) {
      summaryBtn.removeEventListener('click', handleEquipmentSummaryClick);
      summaryBtn.addEventListener('click', handleEquipmentSummaryClick);
    }
  }
  
  function handleEquipmentSummaryClick(e) {
    e.stopPropagation();
    openEquipmentSummaryModal();
  }
  
  // 초기 설정 및 장비 정보 표시 시마다 설정
  setupSoulEngravingGradeHelpButton();
  setupEquipmentSummaryButton();
  
  // 장비 정보가 동적으로 추가될 때를 대비해 MutationObserver 사용
  const equipmentInfo = document.getElementById('equipment-info');
  if (equipmentInfo) {
    const observer = new MutationObserver(function(mutations) {
      setupSoulEngravingGradeHelpButton();
      setupEquipmentSummaryButton();
    });
    observer.observe(equipmentInfo, { childList: true, subtree: true });
  }
  
  // 장비/장신구 요약 모달 닫기 이벤트
  const equipmentSummaryModal = document.getElementById('equipment-summary-modal');
  if (equipmentSummaryModal) {
    const closeBtn = equipmentSummaryModal.querySelector('.stat-info-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', closeEquipmentSummaryModal);
    }
    
    // 모달 배경 클릭 시 닫기
    equipmentSummaryModal.addEventListener('click', function(e) {
      if (e.target === equipmentSummaryModal) {
        closeEquipmentSummaryModal();
      }
    });
  }
  
  // ESC 키로 모달 닫기
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      const equipmentSummaryModal = document.getElementById('equipment-summary-modal');
      if (equipmentSummaryModal && equipmentSummaryModal.classList.contains('active')) {
        closeEquipmentSummaryModal();
        return;
      }
      
      const soulEngravingGradeModal = document.getElementById('soul-engraving-grade-modal');
      if (soulEngravingGradeModal && soulEngravingGradeModal.classList.contains('active')) {
        closeSoulEngravingGradeModal();
      }
    }
  });
});

function setupStatInfoButtons() {
  // 전투 속도
  const combatSpeedBtn = document.querySelector('.combat-speed-info-icon');
  if (combatSpeedBtn) {
    combatSpeedBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const combatSpeedValue = parseFloat(document.getElementById('combat-speed-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      const breakdownData = [
        { label: '장비 영혼 각인', value: document.getElementById('tooltip-soul-combat-speed')?.textContent || '+0%' },
        { label: '장신구 기본 옵션', value: document.getElementById('tooltip-accessory-combat-speed')?.textContent || '+0%' },
        { label: '주신 스탯 (시간)', value: document.getElementById('tooltip-time-combat-speed')?.textContent || '+0%' },
        { label: '데바니온 (네자칸)', value: document.getElementById('tooltip-daevanion-combat-speed')?.textContent || '+0%' },
        { label: '타이틀', value: document.getElementById('tooltip-title-combat-speed')?.textContent || '+0%' }
      ];
      const description = {
        conclusion: `${combatSpeedValue}% 전투 속도 향상은 ${combatSpeedValue}% 이상의 전투 점수 증가`,
        text: `스펙업 체감이 가장 크고, 딜 상승에 직접적인 영향을 주는 스탯. 캐릭터의 평타, 스킬 시전 속도, 스킬 사용 후의 모션/경직(후딜레이) 등 공격에 관련된 모든 동작의 재생 속도를 가속함.<br><br>즉, 공격력이 그대로여도 시간당 쏟아붓는 총 대미지(DPS)가 획기적으로 늘어나는 구조임. 캐스팅 시간과 모션 단축이 생명인 마법 계열 클래스는 물론, 아이온2 전투 특성상 기본적인 연속기 템포가 빨라지기 떄문에 모두에게 필수적.<br><br> 이론 상 ${combatSpeedValue}% 전투 속도 향상은 ${combatSpeedValue}% 이상의 DPS 증가로 이어질 수도 있지만, 쿨감/정신력 등 기타 스탯이 부족하면 그만큼 쿨이 밀리는 현상이 오히려 발생할 수도 있어 동일 % 딜증으로 계산.`,
        damageIncrease: `${combatSpeedValue}%`
      };
      openStatModal('combat-speed', combatSpeedValue, breakdownData, description);
    });
  }
  
  // 공격력
  const attackPowerBtn = document.querySelector('.attack-power-info-icon');
  if (attackPowerBtn) {
    attackPowerBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      // 실제 공격력 값 가져오기 (전역 변수에서 직접 - 캡 적용 전 원래 값)
      const actualAttackPower = window.attackPowerResult?.finalAttack || 0;
      const breakdownData = [
        { label: '데바니온', value: document.getElementById('tooltip-daevanion')?.textContent || '+0' },
        { label: '장비/장신구', value: document.getElementById('tooltip-equipment-base')?.textContent || '+0' },
        { label: '장비/장신구 (초월 정수)', value: document.getElementById('tooltip-equipment-transcend-integer')?.textContent || '+0' },
        { label: '장비/장신구 (초월 퍼센트)', value: document.getElementById('tooltip-equipment-transcend-percent')?.textContent || '+0%' },
        { label: '주신 스탯 (파괴)', value: document.getElementById('tooltip-destruction')?.textContent || '+0%' },
        { label: '일반스탯 (위력)', value: document.getElementById('tooltip-power')?.textContent || '+0%' },
        { label: '데바니온 - 아리엘 (PVE)', value: document.getElementById('tooltip-daevanion-ariel')?.textContent || '+0' }
      ];
      openStatModal('attack-power', actualAttackPower, breakdownData, null);
    });
  }
  
  // 공격력 % 캡 배지
  const attackPowerCapBadge = document.getElementById('attack-power-cap-badge');
  if (attackPowerCapBadge) {
    attackPowerCapBadge.addEventListener('click', function(e) {
      e.stopPropagation();
      
      const capData = calculateAttackPowerCap();
      const { totalCapPercent, transcendPercent, destructionPercent, powerPercent, passiveAttackPercent, passiveSkillName, passiveSkillLevel, percentPerLevel } = capData;
      
      // 팝업에 표시할 breakdown 데이터 (% 관련만)
      const breakdownData = [
        { label: '장비/장신구 (초월 퍼센트)', value: `+${transcendPercent.toFixed(1)}%` },
        { label: '주신 스탯 (파괴)', value: `+${destructionPercent.toFixed(1)}%` },
        { label: '일반스탯 (위력)', value: `+${powerPercent.toFixed(1)}%` }
      ];
      
      // 패시브 스킬이 있는 경우 추가
      if (passiveAttackPercent > 0) {
        breakdownData.push({ 
          label: `패시브 스킬 (${passiveSkillName} Lv.${passiveSkillLevel})`, 
          value: `+${passiveAttackPercent.toFixed(1)}%` 
        });
      }
      
      // 경고 메시지 생성
      let warningMessage = '';
      if (totalCapPercent >= 100) {
        warningMessage = '<div style="margin-top: 1rem; padding: 0.75rem; background: rgba(248, 113, 113, 0.2); border: 1px solid rgba(248, 113, 113, 0.4); border-radius: 6px; color: #f87171; font-size: 0.85rem; line-height: 1.5;"><strong>⚠️ 공격력 % 캡 초과</strong><br>게임 내 공격력 % 상승치는 최대 100%까지만 적용됩니다. 초과된 수치는 무시될 수 있으므로, 스탯 조정을 권장합니다.</div>';
      } else {
        warningMessage = '<div style="margin-top: 1rem; padding: 0.75rem; background: rgba(251, 191, 36, 0.2); border: 1px solid rgba(251, 191, 36, 0.4); border-radius: 6px; color: #fbbf24; font-size: 0.85rem; line-height: 1.5;"><strong>✓ 정상 범위</strong><br>공격력 % 캡이 100% 미만으로 적용되고 있습니다. ' + (100 - totalCapPercent).toFixed(1) + '%의 여유가 있습니다.</div>';
      }
      
      // 패시브 스킬 설명 추가
      let passiveSkillInfo = '';
      if (passiveSkillName) {
        passiveSkillInfo = `<div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.85rem; color: var(--text-muted); line-height: 1.5;"><strong>${passiveSkillName}</strong> 패시브 스킬은 레벨당 ${percentPerLevel}%씩 공격력을 증가시킵니다.<br>현재 레벨: ${passiveSkillLevel} (총 +${passiveAttackPercent.toFixed(1)}%)</div>`;
      } else {
        passiveSkillInfo = '<div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.85rem; color: var(--text-muted); line-height: 1.5;">현재 직업에는 공격력 % 상승 패시브 스킬이 없거나 습득하지 않았습니다.</div>';
      }
      
      const description = {
        conclusion: `총 공격력 % 캡: ${totalCapPercent.toFixed(1)}%`,
        text: `게임 내 공격력 % 상승치는 초월 퍼센트, 파괴, 위력, 패시브 스킬 등으로 증가하며, <strong>최대 100%까지만 적용</strong>됩니다.<br><br><strong>공격력 % 증가 효과:</strong><br>• 초월 퍼센트: 일부 부위 초월 +1당 공격력 +1%<br>• 파괴[지켈]: 파괴 스탯 1당 공격력 +0.2%<br>• 위력: 위력 스탯 1당 공격력 +0.1%<br>• 패시브 스킬: 직업별 패시브 스킬로 공격력 % 증가${passiveSkillInfo}${warningMessage}`,
        damageIncrease: null
      };
      
      openStatModal('attack-power-cap', totalCapPercent, breakdownData, description);
    });
  }
  
  // 무기 피해 증폭
  const weaponDamageAmpBtn = document.querySelector('.weapon-damage-amplification-info-icon');
  if (weaponDamageAmpBtn) {
    weaponDamageAmpBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const weaponDamageAmpValue = parseFloat(document.getElementById('weapon-damage-amplification-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      const breakdownData = [
        { label: '장비 영혼 각인', value: document.getElementById('tooltip-soul-weapon-damage-amp')?.textContent || '+0%' },
        { label: '장비 기본 옵션', value: document.getElementById('tooltip-equipment-base-weapon-damage-amp')?.textContent || '+0%' },
        { label: '마석 각인', value: document.getElementById('tooltip-stone-weapon-damage-amp')?.textContent || '+0' },
        { label: '데바니온 (지켈/바이젤)', value: document.getElementById('tooltip-daevanion-weapon-damage-amp')?.textContent || '+0%' },
        { label: '타이틀 장착 효과', value: document.getElementById('tooltip-title-weapon-damage-amp')?.textContent || '+0%' }
      ];
      const damageIncreasePercent = (weaponDamageAmpValue * 0.66).toFixed(2);
      const description = {
        conclusion: `${weaponDamageAmpValue}% 무기 피해 증폭 향상은 ${damageIncreasePercent}%의 전투 점수 증가`,
        text: `실험 결과, 기타 피해 증폭류와 달리 독자적인 곱연산 구간을 가진 것으로 추정. <br><br>$$실질 딜 상승량(%) ≈ 무기 피해 증폭 수치(%) × 0.66$$`,
        damageIncrease: `${damageIncreasePercent}%`
      };
      openStatModal('weapon-damage-amplification', weaponDamageAmpValue, breakdownData, description);
    });
  }
  
  // 피해 증폭 (PVE/보스 피해 증폭 + 일반 피해 증폭 통합)
  const damageAmpBtn = document.querySelector('.damage-amplification-info-icon');
  if (damageAmpBtn) {
    damageAmpBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const totalDamageAmpValue = parseFloat(document.getElementById('damage-amplification-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      
      const breakdownData = [
        { label: '장비 영혼 각인', value: document.getElementById('tooltip-soul-damage-amp')?.textContent || '+0%' },
        { label: '장비 기본 옵션', value: document.getElementById('tooltip-equipment-base-damage-amp')?.textContent || '+0%' },
        { label: '마석 각인', value: document.getElementById('tooltip-stone-damage-amp')?.textContent || '+0' },
        { label: '데바니온 (지켈)', value: document.getElementById('tooltip-daevanion-damage-amp')?.textContent || '+0%' },
        { label: '데바니온 - 아리엘', value: document.getElementById('tooltip-daevanion-ariel-damage-amp')?.textContent || '+0%' },
        { label: '타이틀 장착 효과', value: document.getElementById('tooltip-title-damage-amp')?.textContent || '+0%' }
      ];
      
      const description = {
        conclusion: '위 세 옵션은 합연산으로 가정하여 합산',
        text: 'PVE 피해 증폭, 보스 피해 증폭, 피해 증폭 모두 같은 카테고리로 묶여서 합연산 처리된다는 가정.<br><br>\'조건부 효율\'만 다를 것으로 추정 되고 있음.<br><br>- <strong>일반 피해 증폭:</strong> PVP, 일반 몹, 보스 가리지 않고 무조건 적용<br>- <strong>PVE 피해 증폭:</strong> 사람(PVP) 때릴 땐 0% 처리, 몬스터한테만 합산<br>- <strong>보스 피해 증폭:</strong> 일반 쫄몹이나 사람 때릴 땐 0% 처리, 보스한테만 합산<br><br>$$최종 증폭 계수 = 1 + (피해 증폭 + PVE 피증 + 보스 피증*) / 100$$<br><br>(단, 보스 피증*은 타겟이 보스일 때만 활성화)',
        damageIncrease: totalDamageAmpValue.toFixed(1) + '%'
      };
      
      openStatModal('damage-amplification', totalDamageAmpValue, breakdownData, description);
    });
  }
  
  // 치명타 피해 증폭
  const criticalDamageAmpBtn = document.querySelector('.critical-damage-amplification-info-icon');
  if (criticalDamageAmpBtn) {
    criticalDamageAmpBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const criticalDamageAmpValue = parseFloat(document.getElementById('critical-damage-amplification-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      // 치명타 확률 (이미 % 형태로 표시됨)
      const criticalChance = parseFloat(document.getElementById('critical-hit-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      
      // 기본 치명타 피해: 150% (1.5배)
      const BASE_CRITICAL_DAMAGE = 1.5;
      // 증폭 후 치명타 피해: 150% + 증폭%
      const amplifiedCriticalDamage = BASE_CRITICAL_DAMAGE + (criticalDamageAmpValue / 100);
      
      // 기존 기대 딜 (증폭 없음)
      // = (1 - 치명타 확률) × 1 + 치명타 확률 × 1.5
      const p = criticalChance / 100;
      const baseExpectedDamage = (1 - p) * 1 + p * BASE_CRITICAL_DAMAGE;
      
      // 증폭 후 기대 딜
      const amplifiedExpectedDamage = (1 - p) * 1 + p * amplifiedCriticalDamage;
      
      // 딜 상승률 = (증폭 후 기대 딜) / (기존 기대 딜) - 1
      const damageIncreaseFromCrit = ((amplifiedExpectedDamage / baseExpectedDamage) - 1) * 100;
      
      const breakdownData = [
        { label: '장비 영혼 각인', value: document.getElementById('tooltip-soul-critical-damage-amp')?.textContent || '+0%' },
        { label: '장비 기본 옵션', value: document.getElementById('tooltip-equipment-base-critical-damage-amp')?.textContent || '+0%' },
        { label: '마석 각인', value: document.getElementById('tooltip-stone-critical-damage-amp')?.textContent || '+0' },
        { label: '데바니온 (바이젤)', value: document.getElementById('tooltip-daevanion-critical-damage-amp')?.textContent || '+0%' },
        { label: '타이틀 장착 효과', value: document.getElementById('tooltip-title-critical-damage-amp')?.textContent || '+0%' }
      ];
      
      const description = {
        conclusion: '[조건부 곱연산] 치명타가 터졌을 때만 적용되는 보너스 계수',
        text: '실험 결과, 아이온2는 치명타 대미지가 <strong>1.5배(150%)</strong> 정도 들어가게 설계된 것으로 추정. \'치명타 피해 증폭\'은 이 배율에 합연산(+)으로 더해 계산.<br><br>현재 치명타 확률: <strong style="color:#60a5fa;">' + criticalChance.toFixed(1) + '%</strong><br>기본 치명타 피해: <strong>150% (×1.5)</strong><br>증폭 후 치명타 피해: <strong style="color:#a78bfa;">' + (amplifiedCriticalDamage * 100).toFixed(1) + '% (×' + amplifiedCriticalDamage.toFixed(3) + ')</strong><br><br><strong>딜 상승률 계산:</strong><br><br>기존 기대 딜 = (1 - ' + p.toFixed(3) + ') × 1 + ' + p.toFixed(3) + ' × 1.5 = <span style="color:#60a5fa;">×' + baseExpectedDamage.toFixed(4) + '</span><br>증폭 후 기대 딜 = (1 - ' + p.toFixed(3) + ') × 1 + ' + p.toFixed(3) + ' × ' + amplifiedCriticalDamage.toFixed(3) + ' = <span style="color:#a78bfa;">×' + amplifiedExpectedDamage.toFixed(4) + '</span><br><br>딜 상승률 = ' + amplifiedExpectedDamage.toFixed(4) + ' / ' + baseExpectedDamage.toFixed(4) + ' - 1 = <strong style="color:#4ade80;">' + damageIncreaseFromCrit.toFixed(2) + '%</strong>',
        damageIncrease: damageIncreaseFromCrit.toFixed(2) + '%'
      };
      
      openStatModal('critical-damage-amplification', criticalDamageAmpValue, breakdownData, description);
    });
  }
  
  // 스킬 딜증
  const skillDamageBtn = document.querySelector('.skill-damage-info-icon');
  if (skillDamageBtn) {
    skillDamageBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      
      // ★ 수정: 이미 계산된 결과를 window.skillDamageResult에서 가져오기
      const skillDamageResult = window.skillDamageResult;
      
      if (!skillDamageResult) {
        console.warn('[스킬 모달] skillDamageResult가 없습니다.');
        return;
      }
      
      // 계산된 결과에서 값 추출
      const activeDamage = skillDamageResult.breakdown?.activeSkillDamage || 0;
      const passiveDamage = skillDamageResult.breakdown?.passiveSkillDamage || 0;
      const stigmaDamage = skillDamageResult.breakdown?.stigmaSkillDamage || 0;
      const totalDamage = skillDamageResult.totalSkillDamage || 0;
      
      // 스킬 정보 가져오기
      const skills = window.currentSkills || [];
      const stigmas = window.currentStigmas || [];
      const skillPriorities = window.currentSkillPriorities || null;
      
      // 액티브/패시브 스킬 분류
      const activeSkills = skills.filter(skill => {
        const group = skill.group || '';
        return group.toLowerCase().includes('active') || group === '액티브';
      });
      const passiveSkills = skills.filter(skill => {
        const group = skill.group || '';
        return group.toLowerCase().includes('passive') || group === '패시브';
      });
      
      // 스킬 목록 HTML 생성 (우선순위 기반 새 UI)
      let skillListHtml = '';
      
      // 설명 메시지
      skillListHtml += `
        <div style="background: rgba(96, 165, 250, 0.15); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #60a5fa; line-height: 1.6;">
          📊 해당 지표는 <strong>각 직업 초월 1~100위 랭커</strong>의 스킬과 <strong>채용 스킬 평균 레벨</strong>을 기반으로 각 스킬의 중요도를 산정하여, 그에 맞게 스킬 레벨로 인한 스펙 점수를 계산합니다.
        </div>
      `;
      
      // 우선순위 기반 스킬 목록 생성
      if (skillPriorities) {
        // 캐릭터 스킬 맵 생성
        const characterSkillMap = {};
        [...activeSkills, ...passiveSkills, ...stigmas].forEach(skill => {
          const skillName = skill.name || '';
          const skillLevel = skill.level_int || parseInt(skill.level || '0', 10) || 0;
          const iconUrl = skill.icon || skill.icon_url || '';
          if (skillName) {
            characterSkillMap[skillName] = { level: skillLevel, icon: iconUrl };
          }
        });
        
        // 액티브 스킬 표시
        if (skillPriorities.active && skillPriorities.active.length > 0) {
          skillListHtml += `
            <div style="margin-bottom: 1.5rem;">
              <div style="background: rgba(147, 51, 234, 0.15); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.75rem;">
                <div style="font-weight: 600; color: #a78bfa; margin-bottom: 0.5rem; font-size: 1rem;">액티브</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">
                  레벨당 +1.5%, 8/12/16/20 레벨 달성 시 +5/10/15/10%<br>중요도 계수: 1순위 스킬 200%기준, 이하 스킬 순차 감소
                </div>
                <div style="font-size: 0.65rem; color: #667eea; margin-top: 0.25rem;">
                  ※ 초월 랭킹 1~100위 랭커 기준 스킬 중요도 순 정렬
                </div>
              </div>
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
          `;
          
          // 실제 계산 결과에서 스킬 정보 가져오기
          const activeDetails = window.skillDamageResult?.details?.active || [];
          // DB의 priorityList와 매칭하여 순서대로 표시 (채용률 10% 이상만, 최대 12개)
          const activeDetailsMap = {};
          activeDetails.forEach(detail => {
            activeDetailsMap[detail.skillName] = detail;
          });
          
          // 채용률 10% 이상인 스킬만 필터링
          const filteredActiveSkills = skillPriorities.active.filter(p => (p.adoption_rate || 0) >= 10);
          
          filteredActiveSkills.slice(0, 12).forEach((priority, index) => {
            const characterSkill = characterSkillMap[priority.skill_name] || { level: 0, icon: '' };
            const number = index + 1;
            const characterLevel = characterSkill.level;
            // DB의 아이콘을 fallback으로 사용
            const iconUrl = characterSkill.icon || priority.skill_icon || '';
            
            // 실제 계산 결과에서 점수 가져오기 (없으면 0)
            const detail = activeDetailsMap[priority.skill_name];
            const skillScore = detail ? detail.finalScore : 0;
            
            skillListHtml += `
              <div style="display: flex; flex-direction: column; align-items: center; width: 60px; text-align: center; background: rgba(147, 51, 234, 0.05); border-radius: 6px; padding: 0.5rem 0.25rem; border: 1px solid rgba(147, 51, 234, 0.2);">
                <div style="position: relative; width: 40px; height: 40px; margin-bottom: 4px;">
                  ${iconUrl ? `<img src="${iconUrl}" alt="${priority.skill_name}" style="width: 100%; height: 100%; border-radius: 4px;">` : `<div style="width: 100%; height: 100%; background: rgba(147, 51, 234, 0.2); border-radius: 4px;"></div>`}
                  <div style="position: absolute; top: -4px; left: -4px; background: #9333ea; color: white; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: bold;">${number}</div>
                </div>
                <div style="font-size: 0.55rem; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 60px; margin-bottom: 2px;">${priority.skill_name}</div>
                <div style="font-size: 0.65rem; color: ${characterSkill.level > 0 ? '#60a5fa' : '#666'}; font-weight: 600;">Lv.${characterSkill.level}</div>
                <div style="font-size: 0.6rem; color: #a78bfa; margin-top: 2px;">${skillScore > 0 ? skillScore.toFixed(1) + '%' : '0%'}</div>
              </div>
            `;
          });
          
          skillListHtml += '</div><div style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">전투 점수: <strong style="color: #a78bfa;">+' + activeDamage.toFixed(1) + '%</strong></div>';
          
          // 액티브 스킬 캡션 추가 (예시 4개, 전체 스킬이 계산에 포함)
          const activeSkillCount = filteredActiveSkills.filter(s => characterSkillMap[s.skill_name]?.level > 0).length;
          skillListHtml += '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed rgba(147, 51, 234, 0.3);">';
          skillListHtml += `<div style="font-size: 0.6rem; color: var(--text-muted); margin-bottom: 0.25rem;">📊 스킬 중요도 예시</div>`;
          skillListHtml += '<div style="display: flex; flex-wrap: wrap; gap: 0.35rem; font-size: 0.55rem;">';
          
          // 중요도 계수 기준으로 정렬 (순위 기반: 1순위 150% ~ 마지막 순위 10%)
          const activeTotalSlots = filteredActiveSkills.length;
          const sortedActiveSkills = filteredActiveSkills
            .slice(0, 12)
            .map((skill, index) => {
              const avgLvl = skill.average_level || 0;
              // 순위 기반 중요도: 1순위 = 150%, 순차 감소
              const maxMult = 2.0, minMult = 0.2;
              const totalSlots = Math.min(12, activeTotalSlots);
              let coef = maxMult;
              if (totalSlots > 1) {
                const step = (maxMult - minMult) / (totalSlots - 1);
                coef = maxMult - (index * step);
              }
              coef = Math.max(minMult, Math.min(maxMult, coef));
              return { ...skill, avgLvl, coef };
            })
            .slice(0, 4);
          
          sortedActiveSkills.forEach((skill) => {
            skillListHtml += `
              <div style="background: rgba(147, 51, 234, 0.1); border-radius: 4px; padding: 0.2rem 0.4rem; border: 1px solid rgba(147, 51, 234, 0.2);">
                <span style="color: #a78bfa;">${skill.skill_name}</span>
                <span style="color: var(--text-muted); margin-left: 0.2rem;">랭커평균Lv:${skill.avgLvl.toFixed(1)}</span>
                <span style="color: #60a5fa; margin-left: 0.2rem;">${(skill.coef * 100).toFixed(0)}%</span>
              </div>
            `;
          });
          
          skillListHtml += '</div></div></div>';
        }
        
        // 패시브 스킬 표시
        if (skillPriorities.passive && skillPriorities.passive.length > 0) {
          skillListHtml += `
            <div style="margin-bottom: 1.5rem;">
              <div style="background: rgba(34, 197, 94, 0.15); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.75rem;">
                <div style="font-weight: 600; color: #4ade80; margin-bottom: 0.5rem; font-size: 1rem;">패시브</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">
                  레벨당 +1.5%<br>중요도 계수: 1순위 스킬 200%기준, 이하 스킬 순차 감소
                </div>
                <div style="font-size: 0.65rem; color: #667eea; margin-top: 0.25rem;">
                  ※ 초월 랭킹 1~100위 랭커 기준 스킬 중요도 순 정렬
                </div>
              </div>
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
          `;
          
          // 실제 계산 결과에서 스킬 정보 가져오기
          const passiveDetails = window.skillDamageResult?.details?.passive || [];
          // DB의 priorityList와 매칭하여 순서대로 표시 (채용률 10% 이상만, 최대 10개)
          const passiveDetailsMap = {};
          passiveDetails.forEach(detail => {
            passiveDetailsMap[detail.skillName] = detail;
          });
          
          // 채용률 10% 이상인 스킬만 필터링
          const filteredPassiveSkills = skillPriorities.passive.filter(p => (p.adoption_rate || 0) >= 10);
          
          filteredPassiveSkills.slice(0, 10).forEach((priority, index) => {
            const characterSkill = characterSkillMap[priority.skill_name] || { level: 0, icon: '' };
            const number = index + 1;
            const characterLevel = characterSkill.level;
            // DB의 아이콘을 fallback으로 사용
            const iconUrl = characterSkill.icon || priority.skill_icon || '';
            
            // 실제 계산 결과에서 점수 가져오기 (없으면 0)
            const detail = passiveDetailsMap[priority.skill_name];
            const skillScore = detail ? detail.finalScore : 0;
            
            skillListHtml += `
              <div style="display: flex; flex-direction: column; align-items: center; width: 60px; text-align: center; background: rgba(34, 197, 94, 0.05); border-radius: 6px; padding: 0.5rem 0.25rem; border: 1px solid rgba(34, 197, 94, 0.2);">
                <div style="position: relative; width: 40px; height: 40px; margin-bottom: 4px;">
                  ${iconUrl ? `<img src="${iconUrl}" alt="${priority.skill_name}" style="width: 100%; height: 100%; border-radius: 4px;">` : `<div style="width: 100%; height: 100%; background: rgba(34, 197, 94, 0.2); border-radius: 4px;"></div>`}
                  <div style="position: absolute; top: -4px; left: -4px; background: #22c55e; color: white; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: bold;">${number}</div>
                </div>
                <div style="font-size: 0.55rem; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 60px; margin-bottom: 2px;">${priority.skill_name}</div>
                <div style="font-size: 0.65rem; color: ${characterSkill.level > 0 ? '#60a5fa' : '#666'}; font-weight: 600;">Lv.${characterSkill.level}</div>
                <div style="font-size: 0.6rem; color: #4ade80; margin-top: 2px;">${skillScore > 0 ? skillScore.toFixed(1) + '%' : '0%'}</div>
              </div>
            `;
          });
          
          skillListHtml += '</div><div style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">전투 점수: <strong style="color: #4ade80;">+' + passiveDamage.toFixed(1) + '%</strong></div>';
          
          // 패시브 스킬 캡션 추가 (예시 4개, 전체 스킬이 계산에 포함)
          const passiveSkillCount = filteredPassiveSkills.filter(s => characterSkillMap[s.skill_name]?.level > 0).length;
          skillListHtml += '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px dashed rgba(34, 197, 94, 0.3);">';
          skillListHtml += `<div style="font-size: 0.6rem; color: var(--text-muted); margin-bottom: 0.25rem;">📊 스킬 중요도 예시</div>`;
          skillListHtml += '<div style="display: flex; flex-wrap: wrap; gap: 0.35rem; font-size: 0.55rem;">';
          
          // 중요도 계수 기준으로 정렬 (순위 기반: 1순위 150% ~ 마지막 순위 10%)
          const passiveTotalSlots = filteredPassiveSkills.length;
          const sortedPassiveSkills = filteredPassiveSkills
            .slice(0, 10)
            .map((skill, index) => {
              const avgLvl = skill.average_level || 0;
              // 순위 기반 중요도: 1순위 = 150%, 순차 감소
              const maxMult = 2.0, minMult = 0.2;
              const totalSlots = Math.min(10, passiveTotalSlots);
              let coef = maxMult;
              if (totalSlots > 1) {
                const step = (maxMult - minMult) / (totalSlots - 1);
                coef = maxMult - (index * step);
              }
              coef = Math.max(minMult, Math.min(maxMult, coef));
              return { ...skill, avgLvl, coef };
            })
            .slice(0, 4);
          
          sortedPassiveSkills.forEach((skill) => {
            skillListHtml += `
              <div style="background: rgba(34, 197, 94, 0.1); border-radius: 4px; padding: 0.2rem 0.4rem; border: 1px solid rgba(34, 197, 94, 0.2);">
                <span style="color: #4ade80;">${skill.skill_name}</span>
                <span style="color: var(--text-muted); margin-left: 0.2rem;">랭커평균Lv:${skill.avgLvl.toFixed(1)}</span>
                <span style="color: #60a5fa; margin-left: 0.2rem;">${(skill.coef * 100).toFixed(0)}%</span>
              </div>
            `;
          });
          
          skillListHtml += '</div></div></div>';
        }
        
        // 스티그마 표시
        if (skillPriorities.stigma && skillPriorities.stigma.length > 0) {
          skillListHtml += `
            <div style="margin-bottom: 1.5rem;">
              <div style="background: rgba(251, 191, 36, 0.15); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.75rem;">
                <div style="font-weight: 600; color: #fbbf24; margin-bottom: 0.5rem; font-size: 1rem;">스티그마 (레벨 높은 상위 4개만)</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">
                  레벨당 +1.5%, 5/10/15/20 레벨 달성 시 +5/10/20/40%<br>중요도 계수: 랭커의 스킬 평균 레벨 대비 비율 (최고 150%)
                </div>
                <div style="font-size: 0.65rem; color: #667eea; margin-top: 0.25rem;">
                  ※ 초월 랭킹 1~100위 랭커 기준 스킬 중요도 순 정렬
                </div>
              </div>
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
          `;
          
          // 스티그마는 실제 계산에 사용된 것과 동일하게 표시
          // 캐릭터가 찍은 레벨 높은 상위 4개 선택 (계산 로직과 동일)
          
          // 스티그마 우선순위 목록 표시 (11개까지)
          // 실제 계산 결과에서 스킬 정보 가져오기
          const stigmaDetails = window.skillDamageResult?.details?.stigma || [];
          // DB의 priorityList와 매칭하여 순서대로 표시 (채용률 10% 이상만, 최대 11개)
          const stigmaDetailsMap = {};
          stigmaDetails.forEach(detail => {
            stigmaDetailsMap[detail.skillName] = detail;
          });
          
          // 채용률 10% 이상인 스킬만 필터링
          const filteredStigmaSkills = skillPriorities.stigma.filter(p => (p.adoption_rate || 0) >= 10);
          
          filteredStigmaSkills.slice(0, 11).forEach((priority, index) => {
            const characterSkill = characterSkillMap[priority.skill_name] || { level: 0, icon: '' };
            const characterLevel = characterSkill.level;
            const number = index + 1;
            // DB의 아이콘을 fallback으로 사용
            const iconUrl = characterSkill.icon || priority.skill_icon || '';
            
            // 실제 계산 결과에서 점수 가져오기 (없으면 0)
            const detail = stigmaDetailsMap[priority.skill_name];
            const skillScore = detail ? detail.finalScore : 0;
            
            skillListHtml += `
              <div style="display: flex; flex-direction: column; align-items: center; width: 60px; text-align: center; background: rgba(251, 191, 36, 0.05); border-radius: 6px; padding: 0.5rem 0.25rem; border: 1px solid rgba(251, 191, 36, 0.2);">
                <div style="position: relative; width: 40px; height: 40px; margin-bottom: 4px;">
                  ${iconUrl ? `<img src="${iconUrl}" alt="${priority.skill_name}" style="width: 100%; height: 100%; border-radius: 4px;">` : `<div style="width: 100%; height: 100%; background: rgba(251, 191, 36, 0.2); border-radius: 4px;"></div>`}
                  <div style="position: absolute; top: -4px; left: -4px; background: #f59e0b; color: white; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; font-size: 0.65rem; font-weight: bold;">${number}</div>
                </div>
                <div style="font-size: 0.55rem; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 60px; margin-bottom: 2px;">${priority.skill_name}</div>
                <div style="font-size: 0.65rem; color: ${characterLevel > 0 ? '#60a5fa' : '#666'}; font-weight: 600;">Lv.${characterLevel}</div>
                <div style="font-size: 0.6rem; color: #fbbf24; margin-top: 2px;">${skillScore > 0 ? skillScore.toFixed(1) + '%' : '0%'}</div>
              </div>
            `;
          });
          
          skillListHtml += '</div><div style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted);">전투 점수: <strong style="color: #fbbf24;">+' + stigmaDamage.toFixed(1) + '%</strong></div>';
          
          // 레벨 높은 상위 4개 스킬의 계산 과정 캡션 추가 (실제 계산된 details 사용)
          const stigmaDetailsFromCalc = window.skillDamageResult?.details?.stigma || [];
          // 캐릭터가 찍은 레벨 높은 4개 (details는 이미 레벨 순으로 계산되어 있음)
          const actualStigmaCalcSkills = stigmaDetailsFromCalc
            .filter(d => d.characterLevel > 0)
            .slice(0, 4);
          
          if (actualStigmaCalcSkills.length > 0) {
            skillListHtml += '<div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px dashed rgba(251, 191, 36, 0.3);">';
            skillListHtml += '<div style="font-size: 0.65rem; color: var(--text-muted); margin-bottom: 0.25rem;">📊 스킬 중요도 예시</div>';
            skillListHtml += '<div style="display: flex; flex-wrap: wrap; gap: 0.35rem; font-size: 0.55rem;">';
            
            // 중요도 높은 순서대로 정렬
            const sortedStigmaSkills = [...actualStigmaCalcSkills].sort((a, b) => {
              return (b.multiplier || 0) - (a.multiplier || 0);
            });
            
            sortedStigmaSkills.forEach((detail) => {
              const avgLvl = detail.averageLevel || 0;
              const multiplier = detail.multiplier || 0;
              
              skillListHtml += `
                <div style="background: rgba(251, 191, 36, 0.1); border-radius: 4px; padding: 0.2rem 0.4rem; border: 1px solid rgba(251, 191, 36, 0.2);">
                  <span style="color: #fbbf24;">${detail.skillName}</span>
                  <span style="color: var(--text-muted); margin-left: 0.2rem;">랭커평균Lv:${avgLvl.toFixed(1)}</span>
                  <span style="color: #60a5fa; margin-left: 0.2rem;">${(multiplier * 100).toFixed(0)}%</span>
                </div>
              `;
            });
            
            skillListHtml += '</div></div>';
          }
          
          skillListHtml += '</div>';
        }
      } else {
        // 우선순위 데이터가 없을 때 안내 메시지
        skillListHtml += '<div style="color: var(--text-muted); font-size: 0.9rem; margin: 1rem 0;">해당 직업의 스킬 우선순위 데이터가 아직 수집되지 않았습니다.</div>';
      }
      
      const breakdownData = [
        { label: '액티브 스킬 전투 점수', value: '+' + activeDamage.toFixed(1) + '%' },
        { label: '패시브 스킬 전투 점수', value: '+' + passiveDamage.toFixed(1) + '%' },
        { label: '스티그마 스킬 전투 점수', value: '+' + stigmaDamage.toFixed(1) + '%' }
      ];
      
      // 계산식 설명 추가
      let calculationHtml = `
        <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
          <strong style="font-size: 1rem;">최종 계산식:</strong>
          
          <div style="margin-top: 1rem; background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 0.75rem;">
            <strong style="color: #a78bfa;">액티브:</strong><br>
            <div style="font-size: 0.8rem; margin-top: 0.5rem;">
              • 레벨당 +1.5%<br>
              • 8/12/16/20 레벨 달성 시 추가 +5/10/15/10%<br>
              • 스킬 중요도 계수: 1순위 스킬 200%기준, 이하 스킬 순차 감소<br>
              <br>
              <strong>합계: <span style="color: #a78bfa;">${activeDamage.toFixed(1)}%</span></strong>
            </div>
          </div>
          
          <div style="margin-top: 0.75rem; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 0.75rem;">
            <strong style="color: #4ade80;">패시브:</strong><br>
            <div style="font-size: 0.8rem; margin-top: 0.5rem;">
              • 레벨당 +1.5%<br>
              • 스킬 중요도 계수: 1순위 스킬 200%기준, 이하 스킬 순차 감소<br>
              <br>
              <strong>합계: <span style="color: #4ade80;">${passiveDamage.toFixed(1)}%</span></strong>
            </div>
          </div>
          
          <div style="margin-top: 0.75rem; background: rgba(251, 191, 36, 0.1); border: 1px solid rgba(251, 191, 36, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 0.75rem;">
            <strong style="color: #fbbf24;">스티그마 (레벨 높은 상위 4개만):</strong><br>
            <div style="font-size: 0.8rem; margin-top: 0.5rem;">
              • 레벨당 +1.5%<br>
              • 5/10/15/20 레벨 달성 시 추가 +5/10/20/40%<br>
              • 스킬 중요도: 랭커평균 레벨 대비 비율 (최고 150%)<br>
              <br>
              <strong>합계: <span style="color: #fbbf24;">${stigmaDamage.toFixed(1)}%</span></strong>
            </div>
          </div>
          
          <div style="margin-top: 1rem; padding: 1rem; background: rgba(74, 222, 128, 0.1); border: 2px solid rgba(74, 222, 128, 0.4); border-radius: 8px; font-size: 0.95rem; text-align: center;">
            <strong>최종: 액티브 + 패시브 + 스티그마<br>= ${activeDamage.toFixed(1)}% + ${passiveDamage.toFixed(1)}% + ${stigmaDamage.toFixed(1)}%<br>= <span style="color: #4ade80;">${totalDamage.toFixed(1)}%</span></strong>
            
          </div>
        </div>
      `;
      
      const description = {
        conclusion: '스킬 관련 수치 기반 스펙 지수',
        text: skillListHtml + calculationHtml,
        damageIncrease: totalDamage.toFixed(1) + '%'
      };
      
      openStatModal('skill-damage', totalDamage, breakdownData, description);
    });
  }
  
  // 재사용 대기 시간 감소
  const cooldownReductionBtn = document.querySelector('.cooldown-reduction-info-icon');
  if (cooldownReductionBtn) {
    cooldownReductionBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const cooldownValue = parseFloat(document.getElementById('cooldown-reduction-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      
      const breakdownData = [
        { label: '타이틀', value: document.getElementById('tooltip-title-cooldown')?.textContent || '+0%' },
        { label: '주신 스탯 (환상)', value: document.getElementById('tooltip-illusion-cooldown')?.textContent || '+0%' },
        { label: '데바니온 (네자칸)', value: document.getElementById('tooltip-daevanion-cooldown')?.textContent || '+0%' }
      ];
      
      // 쿨감으로 인한 딜증 계산
      // 쿨감 x%는 스킬 사용 빈도가 100/(100-x) 배 증가 → 딜증 = 100/(100-x) - 1
      // 실제로는 평균적으로 70% 정도만 소화 가능하다고 가정
      const COOLDOWN_EFFICIENCY = 0.7;
      const cooldownMultiplier = 100 / (100 - cooldownValue);
      const theoreticalDamageIncrease = (cooldownMultiplier - 1) * 100;
      const actualDamageIncrease = theoreticalDamageIncrease * COOLDOWN_EFFICIENCY;
      
      const description = {
        text: '<div style="background: rgba(255, 200, 100, 0.15); border: 1px solid rgba(255, 200, 100, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #fbbf24; line-height: 1.5;">동일 클래스 내 비교를 가정하며, 실제 효율은 다를 수 있습니다. 쿨감을 100% 소화하는 것은 물리적으로 불가하기에, <strong>평균적으로 70% 정도의 쿨감 성능을 소화한다는 가정</strong>하에 계산합니다.<br><br>실제 쿨감으로 인한 딜증가량은 클래스 주력기 쿨타임, 스킬 딜 비중 등 변수에 따라 달라질 수 있습니다.</div>재사용 대기 시간 감소(쿨타임 감소)는 스킬 사용 빈도를 높여 DPS를 증가시킵니다.<br><br><strong>계산식:</strong><br>쿨감 x%일 때, 스킬 사용 빈도가 <strong>100 / (100 - x)</strong>배 증가<br><br><div style="margin: 0.75rem 0; padding: 0.75rem; background: rgba(157, 140, 255, 0.1); border-left: 3px solid rgba(157, 140, 255, 0.5); font-family: monospace; font-size: 0.9rem; line-height: 1.6;">딜 상승률(%) = (100/(100 - x) - 1) × 0.7</div><br><strong>예시:</strong><br>쿨감 ' + cooldownValue.toFixed(1) + '%일 때:<br>이론상 딜증 = 100 / (100 - ' + cooldownValue.toFixed(1) + ') - 1 = <span style="color:#60a5fa;">' + theoreticalDamageIncrease.toFixed(2) + '%</span><br>전 클래스 평균 딜증 (×0.7배수 적용) = ' + theoreticalDamageIncrease.toFixed(2) + '% × 0.7 = <span style="color:#4ade80;">' + actualDamageIncrease.toFixed(2) + '%</span>',
        damageIncrease: actualDamageIncrease.toFixed(2) + '%'
      };
      
      openStatModal('cooldown-reduction', cooldownValue, breakdownData, description);
    });
  }
  
  // 치명타
  const criticalHitBtn = document.querySelector('.critical-hit-info-icon');
  if (criticalHitBtn) {
    criticalHitBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      
      const breakdownData = [
        { label: '장비 기본 옵션', value: document.getElementById('tooltip-base-critical')?.textContent || '+0' },
        { label: '영혼 각인', value: document.getElementById('tooltip-soul-critical')?.textContent || '+0' },
        { label: '마석 각인', value: document.getElementById('tooltip-stone-critical')?.textContent || '+0' },
        { label: '데바니온', value: document.getElementById('tooltip-daevanion-critical')?.textContent || '+0' },
        { label: '주신 스탯 (죽음)', value: document.getElementById('tooltip-death-critical')?.textContent || '+0%' },
        { label: '일반 스탯 (정확)', value: document.getElementById('tooltip-accuracy-critical')?.textContent || '+0%' }
      ];
      
      // breakdown 합계 계산 (정수와 퍼센트 분리)
      let breakdownInteger = 0;
      let deathPercent = 0;
      let accuracyPercent = 0;
      
      breakdownData.forEach(item => {
        const valueStr = item.value;
        const mainValueStr = valueStr.split('(')[0].trim();
        const mainNumericValue = parseFloat(mainValueStr.replace(/[^0-9.-]/g, '')) || 0;
        
        // 주신 스탯 (죽음)과 일반 스탯 (정확)은 곱연산으로 처리
        if (item.label === '주신 스탯 (죽음)') {
          deathPercent = mainNumericValue;
        } else if (item.label === '일반 스탯 (정확)') {
          accuracyPercent = mainNumericValue;
        } else {
          // 나머지는 정수로 합산
          breakdownInteger += mainNumericValue;
        }
      });
      
      // breakdown 합계에서 최종 치명타 스탯 계산 (퍼센트 합연산)
      const totalPercentMultiplier = 1 + ((deathPercent + accuracyPercent) / 100);
      const finalCriticalHitStat = Math.round(breakdownInteger * totalPercentMultiplier);
      // 치명타 스탯을 확률로 변환 (대만 커뮤니티 테이블 기반)
      const finalCriticalChance = convertCritStatToChance(finalCriticalHitStat);
      
      const description = {
        conclusion: '치명타 확률 추정치',
        text: '<div style="background: rgba(255, 200, 100, 0.15); border: 1px solid rgba(255, 200, 100, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #fbbf24; line-height: 1.5;">치명타 저항은 보스몹마다 다릅니다. 쫄몹이나 허수아비는 저항이 낮지만, 보스마다 다르기 때문에 정확한 치명타 확률 계산이 불가합니다. 아래는 평균 추정 수치이며, 치명타 스탯 연구가 진행됨에 따라 수정될 수 있습니다.</div> <br><div><strong>치명타 확률 계산:</strong><br>계산식: (치명타 스탯 × 0.7) ÷ 10 = 확률%<br><br>현재 치명타 스탯: <strong>' + finalCriticalHitStat.toFixed(0) + '</strong><br>보정된 스탯: <strong>' + (finalCriticalHitStat * 0.7).toFixed(1) + '</strong> (× 0.7)<br>추정 치명타 확률: <strong style="color:#60a5fa;">' + finalCriticalChance.toFixed(1) + '%</strong><br><br>※ 치명타로 인한 딜 상승률은 <strong>치명타 피해 증폭</strong>에서 확인하세요.</div>',
        damageIncrease: null
      };
      
      // finalCriticalHitStat을 전달하여 breakdown 합계와 일치시킴
      openStatModal('critical-hit', finalCriticalHitStat, breakdownData, description);
    });
  }
  
  // 강타
  const stunHitBtn = document.querySelector('.stun-hit-info-icon');
  if (stunHitBtn) {
    stunHitBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const stunHitValue = parseFloat(document.getElementById('stun-hit-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      
      const breakdownData = [
        { label: '타이틀', value: document.getElementById('tooltip-title-stun')?.textContent || '+0%' },
        { label: '주신 스탯 (지혜)', value: document.getElementById('tooltip-wisdom-stun')?.textContent || '+0%' }
      ];
      
      const description = {
        conclusion: '[조건부 곱연산] 강타가 터졌을 때만 적용되는 보너스 계수',
        text: '강타/완벽/치명타는 독립적인 확률로 발동됩니다.<br><br>강타는 <strong>강타(DOUBLE)</strong>가 발동될 확률로, 발동시 <strong>2배 대미지</strong>를 가합니다.<br><br>완벽은 <strong>완벽(PERFECT)</strong>가 발동될 확률로, 발동시 <strong>무기 최대 대미지로 딜을 가합니다</strong>.<br><br>강타로 인한 딜 증:<br><br>$$딜 상승률(%) = 강타 확률(%)$$',
        damageIncrease: stunHitValue.toFixed(1) + '%'
      };
      
      openStatModal('stun-hit', stunHitValue, breakdownData, description);
    });
  }
  
  // 완벽
  const perfectBtn = document.querySelector('.perfect-info-icon');
  if (perfectBtn) {
    perfectBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const perfectValue = parseFloat(document.getElementById('perfect-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      
      // 무기 최소/최대 공격력 가져오기
      const weaponMin = window.weaponMinAttack || 0;
      const weaponMax = window.weaponMaxAttack || 0;
      
      // 완벽 딜 증가량 계산: 완벽 확률 × (최대공 - 최소공) / (최대공 + 최소공)
      let damageIncreaseFromPerfect = 0;
      if (weaponMin > 0 && weaponMax > 0 && weaponMax > weaponMin) {
        damageIncreaseFromPerfect = perfectValue * ((weaponMax - weaponMin) / (weaponMax + weaponMin));
      }
      
      const breakdownData = [
        { label: '타이틀', value: document.getElementById('tooltip-title-perfect')?.textContent || '+0%' },
        { label: '주신 스탯 (정의)', value: document.getElementById('tooltip-justice-perfect')?.textContent || '+0%' },
        { label: '장신구 기본 옵션', value: document.getElementById('tooltip-accessory-perfect')?.textContent || '+0%' }
      ];
      
      const weaponInfo = (weaponMax > 0) ? `<br><br>현재 무기: 최소공 ${weaponMin}, 최대공 ${weaponMax}` : '<br><br>무기 정보를 찾을 수 없습니다.';
      
      const description = {
        conclusion: '무기 대미지의 \'편차(Min-Max 차이)\'가 클수록 딜증이 높음',
        text: '강타/완벽/치명타는 독립적인 확률로 발동됩니다.<br><br>강타는 <strong>강타(DOUBLE)</strong>가 발동될 확률로, 발동시 <strong>2배 대미지</strong>를 가합니다.<br><br>완벽은 <strong>완벽(PERFECT)</strong>가 발동될 확률로, 발동시 <strong>무기 최대 대미지로 딜을 가합니다</strong>.<br><br>(평균 대미지와 최대 대미지 사이의 간격만큼 이득을 보는 구조)<br><br>완벽으로 인한 딜 증:<br><br>$$기대 딜 상승률(%) = 완벽 확률(%) × (최대공 - 최소공) / (최대공 + 최소공)$$' + weaponInfo,
        damageIncrease: damageIncreaseFromPerfect.toFixed(2) + '%'
      };
      
      openStatModal('perfect', perfectValue, breakdownData, description);
    });
  }
  
  // 다단 히트 적중
  const multiHitBtn = document.querySelector('.multi-hit-info-icon');
  if (multiHitBtn) {
    multiHitBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      const multiHitStatValue = parseFloat(document.getElementById('multi-hit-value')?.textContent?.replace(/[^0-9.-]/g, '') || '0');
      
      // 다단 히트 적중 딜증 계산: y = 11.1x + 13.9x^2 + 17.8x^3 + 23.9x^4
      // x는 다단 히트 적중 퍼센트를 소수로 변환한 값 (예: 11% = 0.11)
      // 기본 다단 히트 확률 18% (스탯에 표기되지 않음)
      const baseMultiHitPercent = 18;
      const totalMultiHitPercent = baseMultiHitPercent + multiHitStatValue;
      
      // 기본 18%일 때의 딜증 계산
      const xBase = baseMultiHitPercent / 100;
      const baseDamageIncrease = 11.1 * xBase + 13.9 * Math.pow(xBase, 2) + 17.8 * Math.pow(xBase, 3) + 23.9 * Math.pow(xBase, 4);
      
      // 18% + 스탯일 때의 딜증 계산
      const xTotal = totalMultiHitPercent / 100;
      const totalDamageIncrease = 11.1 * xTotal + 13.9 * Math.pow(xTotal, 2) + 17.8 * Math.pow(xTotal, 3) + 23.9 * Math.pow(xTotal, 4);
      
      // 스탯으로 인한 실제 딜 증가율 = (1 + 총딜증) / (1 + 기본딜증) - 1
      // 기존 딜 대비 얼마나 증가했는지 계산
      const baseMultiplier = 1 + baseDamageIncrease / 100;
      const totalMultiplier = 1 + totalDamageIncrease / 100;
      const actualDamageIncrease = ((totalMultiplier / baseMultiplier) - 1) * 100;
      
      const breakdownData = [
        { label: '장비/장신구 영혼 각인', value: document.getElementById('tooltip-soul-multi-hit')?.textContent || '+0.0%' },
        { label: '장비/장신구 기본 옵션', value: document.getElementById('tooltip-base-multi-hit')?.textContent || '+0.0%' },
        { label: '데바니온 (트리니엘)', value: document.getElementById('tooltip-daevanion-multi-hit')?.textContent || '+0.0%' }
      ];
      
      const description = {
        conclusion: '최대 4타 확률 연쇄 발동으로 인한 딜증',
        text: '다단 히트 적중 스탯에 따라 최대 4타까지 확률로 연쇄 발동됩니다.<br><br><div style="background: rgba(255, 100, 100, 0.15); border: 1px solid rgba(255, 100, 100, 0.3); border-radius: 6px; padding: 0.75rem; margin-bottom: 1rem; font-size: 0.8rem; color: #ff6b6b; line-height: 1.5;"><strong>※ 스탯에 표기되지 않는 기본 다단 히트 확률이 약 18% 있습니다.</strong><br><strong>※ 다단 히트는 신석을 발동시키지 않습니다.</strong><br><strong>※ 주력 스킬의 채용 특화에 따라 실제 효율은 표기 값보다 더 좋아질 수 있습니다. <br>예를 들어, 주력기 다단히트 50% 특화 채용할 경우 실제 효율은 더 높을 수 있음. </strong></div>기본 기대값은 1타이며, 다단 히트 적중 확률에 따라 2타, 3타, 4타까지 연쇄 발동 가능합니다.<br><br>인던 기준 타수별 5%, 10%, 15%, 20% 추가 피해를 가합니다.',
        damageIncrease: actualDamageIncrease.toFixed(2) + '%'
      };
      
      openStatModal('multi-hit', multiHitStatValue, breakdownData, description);
    });
  }
}

// 모든 스탯의 딜증 계산 및 표시
function updateAllDamageIncreaseBadges() {
  // ★ 핵심 1: 모든 배지를 먼저 숨김 (이전 캐릭터 데이터 잔류 방지)
  const allBadgeIds = [
    'combat-speed-damage-badge',
    'weapon-damage-amplification-damage-badge',
    'damage-amplification-damage-badge',
    'critical-damage-amplification-damage-badge',
    'skill-damage-damage-badge',
    'cooldown-reduction-damage-badge',
    'stun-hit-damage-badge',
    'perfect-damage-badge',
    'multi-hit-damage-badge'
  ];
  allBadgeIds.forEach(id => {
    const badge = document.getElementById(id);
    if (badge) {
      badge.style.display = 'none';
      badge.textContent = '';
    }
  });
  
  // 공격력 값 가져오기 (최종 전투 점수 계산용)
  // ★ 핵심 2: 전역 변수에서 직접 가져오기 (DOM 파싱 의존성 제거)
  // ★ 공격력 % 캡 적용: 캡 초과 시 캡 적용 공격력 사용
  const attackPowerFromGlobal = window.attackPowerResult?.finalAttack;
  let attackPower = (attackPowerFromGlobal !== undefined && attackPowerFromGlobal !== null && attackPowerFromGlobal > 0) 
    ? attackPowerFromGlobal 
    : (parseFloat(document.getElementById('attack-power-value')?.textContent?.replace(/,/g, '').replace(/[^0-9.-]/g, '') || '0') || 0);
  
  // 캡 적용 공격력이 있으면 사용
  if (window.isAttackPowerOverCap && window.cappedAttackPower) {
    attackPower = window.cappedAttackPower;
  }
  
  let damageIncreaseValues = {};
  
  // ★ 전역 변수에서 직접 가져오기 (DOM 파싱 대신) - 이전 캐릭터 데이터 혼입 방지
  
  // 1. 전투 속도
  const combatSpeedValue = window.combatSpeedResult?.totalCombatSpeed || 0;
  if (combatSpeedValue > 0) {
    damageIncreaseValues.combatSpeed = combatSpeedValue;
    const badge = document.getElementById('combat-speed-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${combatSpeedValue.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 2. 무기 피해 증폭
  const weaponDamageAmpValue = window.damageAmplificationResult?.weaponDamageAmp?.totalPercent || 0;
  if (weaponDamageAmpValue > 0) {
    const damageIncrease = weaponDamageAmpValue * 0.66;
    damageIncreaseValues.weaponDamageAmp = damageIncrease;
    const badge = document.getElementById('weapon-damage-amplification-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${damageIncrease.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 3. 피해 증폭 (PVE + 일반 합산)
  const pveDamageAmp = window.damageAmplificationResult?.pveDamageAmp?.totalPercent || 0;
  const generalDamageAmp = window.damageAmplificationResult?.damageAmp?.totalPercent || 0;
  const totalDamageAmpValue = pveDamageAmp + generalDamageAmp;
  if (totalDamageAmpValue > 0) {
    damageIncreaseValues.damageAmp = totalDamageAmpValue;
    const badge = document.getElementById('damage-amplification-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${totalDamageAmpValue.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 4. 치명타 피해 증폭
  const criticalDamageAmpValue = window.damageAmplificationResult?.criticalDamageAmp?.totalPercent || 0;
  
  // ★ 수정: 치명타 스탯을 확률로 변환 (툴팁과 동일한 방식)
  let criticalChance = 0;
  if (window.criticalHitResult && window.criticalHitResult.breakdown) {
    const { baseCriticalHitInteger, soulCriticalHitInteger, stoneCriticalHitInteger, daevanionCriticalHitInteger, deathCriticalHitPercent, accuracyCriticalHitPercent } = window.criticalHitResult.breakdown;
    // 최종 치명타 정수 계산: (정수 합계) * (1 + (퍼센트 합계)/100)
    const totalCriticalHitInteger = baseCriticalHitInteger + soulCriticalHitInteger + stoneCriticalHitInteger + daevanionCriticalHitInteger;
    const totalPercentMultiplier = 1 + ((deathCriticalHitPercent + accuracyCriticalHitPercent) / 100);
    const finalCriticalHitInteger = Math.round(totalCriticalHitInteger * totalPercentMultiplier);
    // 치명타 스탯을 확률로 변환: (스탯 × 0.7) ÷ 10
    criticalChance = convertCritStatToChance(finalCriticalHitInteger);
  }
  
  if (criticalDamageAmpValue > 0 && criticalChance > 0) {
    const BASE_CRITICAL_DAMAGE = 1.5;
    const amplifiedCriticalDamage = BASE_CRITICAL_DAMAGE + (criticalDamageAmpValue / 100);
    const p = criticalChance / 100;
    const baseExpectedDamage = (1 - p) * 1 + p * BASE_CRITICAL_DAMAGE;
    const amplifiedExpectedDamage = (1 - p) * 1 + p * amplifiedCriticalDamage;
    const damageIncrease = ((amplifiedExpectedDamage / baseExpectedDamage) - 1) * 100;
    damageIncreaseValues.criticalDamageAmp = damageIncrease;
    const badge = document.getElementById('critical-damage-amplification-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${damageIncrease.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 5. 스킬 딜증 - window.skillDamageResult에서 이미 계산된 값 사용
  if (window.skillDamageResult && window.skillDamageResult.totalSkillDamage > 0) {
    const totalDamage = window.skillDamageResult.totalSkillDamage;
    damageIncreaseValues.skillDamage = totalDamage;
    const badge = document.getElementById('skill-damage-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${totalDamage.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 6. 재사용 대기 시간 감소
  const cooldownValue = window.cooldownReductionResult?.totalCooldownReduction || 0;
  if (cooldownValue > 0) {
    const COOLDOWN_EFFICIENCY = 0.7;
    const cooldownMultiplier = 100 / (100 - cooldownValue);
    const theoreticalDamageIncrease = (cooldownMultiplier - 1) * 100;
    const actualDamageIncrease = theoreticalDamageIncrease * COOLDOWN_EFFICIENCY;
    damageIncreaseValues.cooldownReduction = actualDamageIncrease;
    const badge = document.getElementById('cooldown-reduction-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${actualDamageIncrease.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 7. 강타
  const stunHitValue = window.stunHitResult?.totalStunHitPercent || 0;
  if (stunHitValue > 0) {
    damageIncreaseValues.stunHit = stunHitValue;
    const badge = document.getElementById('stun-hit-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${stunHitValue.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 8. 완벽
  const perfectValue = window.perfectResult?.totalPerfectPercent || 0;
  const weaponMin = window.weaponMinAttack || 0;
  const weaponMax = window.weaponMaxAttack || 0;
  if (perfectValue > 0 && weaponMin > 0 && weaponMax > 0 && weaponMax > weaponMin) {
    const damageIncrease = perfectValue * ((weaponMax - weaponMin) / (weaponMax + weaponMin));
    damageIncreaseValues.perfect = damageIncrease;
    const badge = document.getElementById('perfect-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${damageIncrease.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 9. 다단 히트 적중
  const multiHitStatValue = window.multiHitResult?.totalMultiHitPercent || 0;
  if (multiHitStatValue > 0) {
    const baseMultiHitPercent = 18;
    const totalMultiHitPercent = baseMultiHitPercent + multiHitStatValue;
    
    const xBase = baseMultiHitPercent / 100;
    const baseDamageIncrease = 11.1 * xBase + 13.9 * Math.pow(xBase, 2) + 17.8 * Math.pow(xBase, 3) + 23.9 * Math.pow(xBase, 4);
    
    const xTotal = totalMultiHitPercent / 100;
    const totalDamageIncrease = 11.1 * xTotal + 13.9 * Math.pow(xTotal, 2) + 17.8 * Math.pow(xTotal, 3) + 23.9 * Math.pow(xTotal, 4);
    
    const baseMultiplier = 1 + baseDamageIncrease / 100;
    const totalMultiplier = 1 + totalDamageIncrease / 100;
    const actualDamageIncrease = ((totalMultiplier / baseMultiplier) - 1) * 100;
    
    damageIncreaseValues.multiHit = actualDamageIncrease;
    const badge = document.getElementById('multi-hit-damage-badge');
    if (badge) {
      badge.textContent = `전투 점수 +${actualDamageIncrease.toFixed(1)}%`;
      badge.style.display = 'block';
    }
  }
  
  // 최종 전투 점수 계산 (공격력 × 모든 딜증의 곱)
  // 공격력 제외, 치명타 제외
  // 딜증은 곱연산으로 계산 (1 + 딜증1/100) × (1 + 딜증2/100) × ...
  let totalMultiplier = 1.0;
  for (const key in damageIncreaseValues) {
    const damageIncrease = damageIncreaseValues[key];
    totalMultiplier *= (1 + damageIncrease / 100);
  }
  
  const finalCombatScore = attackPower * totalMultiplier;
  
  // 계산된 전투 점수를 화면에 표시
  const dpsScoreValue = document.getElementById('dps-score-value');
  if (dpsScoreValue && attackPower > 0) {
    dpsScoreValue.textContent = Math.round(finalCombatScore).toLocaleString(undefined, {maximumFractionDigits: 0});
  }
  
  // 계산된 값 반환 (DOM 파싱 의존성 제거용)
  return { finalCombatScore, attackPower, totalMultiplier };
}
</script>


      </main>
      
      
      <footer>
         
        
        <div class="footer-links">
          <a href="/cdn-cgi/l/email-protection#b1d0d8dedf83c5dededd9fd2dedfc5d0d2c5f1d6dcd0d8dd9fd2dedc8ec2c4d3dbd4d2c58c808b80915a1d095d2c29" class="footer-link-text" id="inquiry-link">1:1 문의</a>
          <span class="footer-separator">|</span>
          <button class="footer-link-text" id="terms-link" style="border: none; font-family: inherit; background: none; padding: 0; margin: 0;">이용 약관</button>
          <span class="footer-separator">|</span>
          <button class="footer-link-text" id="privacy-link" style="border: none; font-family: inherit; background: none; padding: 0; margin: 0;">개인정보 처리방침</button>
        </div>
        <div class="footer-copyright">
          <p>© 2025 AION2 TOOL All Rights Reserved.</p>
          <p>This site is not associated with NCsoft Corporation & AION2.</p>
        </div>
      </footer>

      <!-- 이용 약관 모달 -->
      <div id="terms-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>서비스 이용약관</h2>
            <button class="modal-close" id="terms-close">&times;</button>
          </div>
          <div class="modal-body" id="terms-content"></div>
        </div>
      </div>

      <!-- 개인정보 처리방침 모달 -->
      <div id="privacy-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
          <div class="modal-header">
            <h2>개인정보 처리방침</h2>
            <button class="modal-close" id="privacy-close">&times;</button>
          </div>
          <div class="modal-body" id="privacy-content"></div>
        </div>
      </div>
    </div>



    
    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
      // 이용 약관 내용
      const termsContent = `
        <h3>제1조 (목적)</h3>
        <p>본 약관은 [아툴](이하 "서비스"라 함)이 제공하는 아이온2 게임 정보 및 검색 서비스의 이용과 관련하여, 서비스와 이용자 간의 권리, 의무 및 책임사항, 기타 필요한 사항을 규정함을 목적으로 합니다.</p>

        <h3>제2조 (용어의 정의)</h3>
        <p><strong>"서비스"</strong>란 [아툴]이 이용자에게 제공하는 아이온2 관련 캐릭터 검색, 통계 정보, 랭킹 등 모든 인터넷 서비스를 의미합니다.</p>
        <p><strong>"이용자"</strong>란 서비스에 접속하여 본 약관에 따라 서비스를 이용하는 회원 및 비회원을 말합니다.</p>
        <p><strong>"게임 데이터"</strong>란 아이온2 게임 내에서 발생하는 캐릭터 정보, 전투력, 아이템 정보 등을 의미하며, 이의 원천적인 저작권은 (주)엔씨소프트에 있습니다.</p>

        <h3>제3조 (약관의 효력 및 변경)</h3>
        <p>본 약관은 서비스를 이용하고자 하는 모든 이용자에게 효력이 발생합니다.</p>
        <p>서비스는 필요한 경우 관련 법령을 위배하지 않는 범위 내에서 본 약관을 개정할 수 있습니다.</p>
        <p>약관이 변경될 경우, 변경된 약관은 사이트 내 공지사항을 통해 공지하며, 공지 후 7일이 경과한 시점부터 효력이 발생합니다.</p>

        <h3>제4조 (서비스의 제공 및 변경)</h3>
        <p>서비스는 이용자에게 아래와 같은 기능을 제공합니다.</p>
        <ul>
          <li>아이온2 캐릭터 전적 및 장비 정보 검색</li>
          <li>서버별/직업별 랭킹 및 통계 정보</li>
          <li>기타 서비스가 자체 개발하거나 제휴를 통해 제공하는 일체의 서비스</li>
        </ul>
        <p>서비스는 1인 개발자에 의해 운영되므로, 운영자의 사정, 기술적 필요, 또는 게임사(엔씨소프트)의 API 정책 변경 등에 따라 서비스의 전부 또는 일부를 예고 없이 수정, 변경, 중단할 수 있습니다. 이에 대하여 서비스는 이용자에게 별도의 보상을 하지 않습니다.</p>

        <h3>제5조 (저작권 및 지식재산권)</h3>
        <p><strong>[아툴]의 저작권:</strong> 서비스가 작성한 저작물(웹사이트 디자인, 로고, 자체 개발한 통계 알고리즘, 소스 코드 등)에 대한 저작권 및 기타 지식재산권은 <strong>[아툴]</strong>에 귀속됩니다.</p>
        <p><strong>게임사의 저작권:</strong> 서비스 내에서 보여지는 게임 데이터, 이미지, 아이콘, 텍스트 등 아이온2와 관련된 모든 리소스의 저작권은 (주)엔씨소프트에 있습니다. 본 서비스는 해당 저작물을 비영리적/정보 제공 목적으로 활용합니다.</p>

        <h3>제6조 (이용자의 의무)</h3>
        <p>이용자는 다음 각 호의 행위를 하여서는 안 됩니다.</p>
        <ul>
          <li>서비스의 서버에 과도한 부하를 주는 행위 (DDoS 공격, 매크로 등을 이용한 비정상적인 트래픽 유발)</li>
          <li>서비스의 운영진, 직원 또는 관계자를 사칭하는 행위</li>
          <li>서비스 내에 허위 사실을 유포하거나 타인의 명예를 훼손하는 행위</li>
          <li>기타 관련 법령 및 본 약관을 위반하는 행위</li>
        </ul>

        <h3>제7조 (책임의 제한 및 면책)</h3>
        <p><strong>데이터의 정확성:</strong> 본 서비스가 제공하는 게임 데이터는 게임사의 API 또는 공개된 정보를 바탕으로 하므로, 실제 게임 데이터와 시차(지연)가 발생하거나 일치하지 않을 수 있습니다. 서비스는 제공되는 정보의 정확성, 신뢰성, 완전성을 보장하지 않습니다.</p>
        <p><strong>서비스 이용 결과:</strong> 이용자가 본 서비스의 정보를 신뢰하여 취한 행동(아이템 거래, 캐릭터 육성 등)으로 인해 발생한 손해에 대하여 서비스는 책임을 지지 않습니다.</p>
        <p><strong>외부 요인:</strong> 천재지변, 디도스(DDoS) 공격, IDC 장애, 게임사의 점검 등 불가항력적인 사유로 인해 서비스를 제공할 수 없는 경우, 서비스는 이에 대한 책임을 면합니다.</p>

        <h3>제8조 (광고의 게재)</h3>
        <p>서비스는 서비스 운영을 위해 사이트 내에 광고(Google AdSense 등)를 게재할 수 있습니다.</p>
        <p>이용자가 서비스 내에 게재된 광고를 이용하거나 광고주와 거래를 함으로써 발생하는 손해에 대해 서비스는 책임을 지지 않습니다.</p>

        <h3>부칙</h3>
        <p>본 약관은 2025년 11월 26일부터 시행합니다.</p>
      `;

      // 개인정보 처리방침 내용
      const privacyContent = `
        <p><strong>[아툴]</strong>(이하 '서비스')은(는) 정보주체의 자유와 권리 보호를 위해 「개인정보 보호법」 및 관계 법령이 정한 바를 준수하여, 적법하게 개인정보를 처리하고 안전하게 관리하고 있습니다. 이에 「개인정보 보호법」 제30조에 따라 정보주체에게 개인정보 처리에 관한 절차 및 기준을 안내하고, 이와 관련한 고충을 신속하고 원활하게 처리할 수 있도록 하기 위하여 다음과 같이 개인정보 처리방침을 수립·공개합니다.</p>

        <h3>1. 개인정보의 처리 목적</h3>
        <p>'서비스'는 다음의 목적을 위하여 개인정보를 처리합니다. 처리하고 있는 개인정보는 다음의 목적 이외의 용도로는 이용되지 않으며, 이용 목적이 변경되는 경우에는 「개인정보 보호법」 제18조에 따라 별도의 동의를 받는 등 필요한 조치를 이행할 예정입니다.</p>
        <ul>
          <li><strong>서비스 제공 및 운영</strong>
            <ul>
              <li>아이온2 게임 캐릭터 정보(전투력, 스킬, 장비 등) 검색 및 통계 정보 제공</li>
              <li>서비스 이용에 따른 트래픽 분석 및 서비스 품질 개선</li>
              <li>민원 처리 및 부정 이용 방지</li>
              <li>서비스 오류 신고 접수 및 처리</li>
              <li>비정상적인 접근(DDoS 공격, 매크로 등) 탐지 및 차단</li>
            </ul>
          </li>
        </ul>

        <h3>2. 처리하는 개인정보의 항목</h3>
        <p>'서비스'는 회원가입 없이 이용 가능한 서비스로, 정보주체의 별도 동의 없이 수집하는 개인정보는 최소화하고 있습니다.</p>
        <ul>
          <li><strong>자동으로 수집·생성되는 개인정보 (로그 데이터)</strong>
            <ul>
              <li>항목: 접속 IP 정보, 쿠키(Cookie), 서비스 이용 기록, 접속 로그, 브라우저 및 OS 정보</li>
              <li>수집 방법: 서비스 이용 과정에서 자동으로 생성되어 수집</li>
            </ul>
          </li>
          <li><strong>게임 데이터 (공개된 정보)</strong>
            <ul>
              <li>항목: 캐릭터명, 서버명, 직업, 전투력, 장비 정보, 스킬 정보, 레기온 정보 등</li>
              <li>출처: 게임사(NC소프트) 공식 홈페이지 및 클라이언트를 통해 공개된 데이터</li>
            </ul>
          </li>
        </ul>

        <h3>3. 개인정보의 처리 및 보유 기간</h3>
        <p>'서비스'는 법령에 따른 개인정보 보유·이용 기간 또는 정보주체로부터 동의받은 기간 내에서 개인정보를 처리·보유합니다.</p>
        <ul>
          <li><strong>서비스 접속 로그 (통신비밀보호법)</strong>
            <ul>
              <li>보유 근거: 통신비밀보호법 제15조의2</li>
              <li>보유 기간: 3개월</li>
            </ul>
          </li>
          <li><strong>게임 캐릭터 데이터</strong>
            <ul>
              <li>보유 기간: 서비스 종료 시 또는 해당 캐릭터가 게임 내에서 삭제되거나 검색 배제를 요청할 때까지</li>
            </ul>
          </li>
        </ul>

        <h3>4. 개인정보의 제3자 제공</h3>
        <p>'서비스'는 정보주체의 개인정보를 제3자에게 제공하지 않습니다. 다만, 다음의 경우에는 예외로 합니다.</p>
        <ul>
          <li>정보주체의 동의를 받은 경우</li>
          <li>법률의 특별한 규정 등 「개인정보 보호법」 제17조 및 제18조에 해당하는 경우</li>
        </ul>

        <h3>5. 개인정보 처리업무의 위탁</h3>
        <p>'서비스'는 원활한 개인정보 업무처리를 위하여 다음과 같이 개인정보 처리업무를 위탁하고 있습니다. (서버 호스팅 관련)</p>
        <ul>
          <li><strong>수탁자:</strong> 가비아</li>
          <li><strong>위탁하는 업무의 내용:</strong> 서비스 제공을 위한 서버 및 데이터베이스 운영, 데이터 보관</li>
        </ul>

        <h3>6. 개인정보의 파기</h3>
        <p>'서비스'는 개인정보 보유기간의 경과, 처리목적 달성 등 개인정보가 불필요하게 되었을 때에는 지체 없이 해당 개인정보를 파기합니다.</p>
        <ul>
          <li><strong>파기절차:</strong> 목적 달성 후 별도의 DB로 옮겨져(종이의 경우 별도의 서류함) 내부 방침 및 기타 관련 법령에 따라 일정 기간 저장된 후 파기됩니다.</li>
          <li><strong>파기방법:</strong> 전자적 파일 형태의 정보는 기록을 재생할 수 없는 기술적 방법을 사용합니다.</li>
        </ul>

        <h3>7. 개인정보의 안전성 확보조치</h3>
        <p>'서비스'는 개인정보의 안전성 확보를 위해 다음과 같은 조치를 취하고 있습니다.</p>
        <ul>
          <li><strong>기술적 조치:</strong> 개인정보처리시스템 등의 접근권한 관리, 보안프로그램 설치, 전송 구간 암호화(SSL/HTTPS 적용)</li>
          <li><strong>관리적 조치:</strong> 개인정보 접근 인원 최소화</li>
        </ul>

        <h3>8. 개인정보 자동 수집 장치의 설치·운영 및 거부에 관한 사항</h3>
        <p>'서비스'는 이용자에게 개별적인 맞춤서비스를 제공하기 위해 이용정보를 저장하고 수시로 불러오는 '쿠키(cookie)'를 사용합니다.</p>
        <ul>
          <li><strong>쿠키의 사용 목적:</strong> 이용자의 접속 빈도나 방문 시간 등을 분석하여 서비스 개선의 척도로 활용합니다.</li>
          <li><strong>쿠키의 설치·운영 및 거부:</strong> 웹브라우저 상단의 도구>인터넷 옵션>개인정보 메뉴의 옵션 설정을 통해 쿠키 저장을 거부할 수 있습니다. (단, 쿠키 저장을 거부할 경우 일부 서비스 이용에 어려움이 있을 수 있습니다.)</li>
        </ul>

        <h3>9. 개인정보 보호책임자</h3>
        <p>'서비스'는 개인정보 처리에 관한 업무를 총괄해서 책임지고, 개인정보 처리와 관련한 정보주체의 불만처리 및 피해구제 등을 위하여 아래와 같이 개인정보 보호책임자를 지정하고 있습니다.</p>
        <ul>
          <li><strong>성명/직책:</strong> 운영자</li>
          <li><strong>연락처:</strong> aion2tool.contact@gmail.com</li>
        </ul>

        <h3>10. 개인정보 처리방침의 변경</h3>
        <p>이 개인정보 처리방침은 <strong>2025년 11월 26일</strong>부터 적용됩니다.</p>
      `;

      // 모달 열기/닫기 함수
      function openModal(modalId, contentId, content) {
        const modal = document.getElementById(modalId);
        const contentEl = document.getElementById(contentId);
        if (modal && contentEl) {
          contentEl.innerHTML = content;
          modal.style.display = 'flex';
          document.body.style.overflow = 'hidden';
        }
      }

      function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
          modal.style.display = 'none';
          document.body.style.overflow = '';
        }
      }

      // SPA 라우터: 메인 탭 클릭 시 AJAX로 페이지 로드
      // 복잡한 JavaScript가 있는 페이지는 전체 리로드로 처리
      let isNavigating = false; // 중복 클릭 방지
      
      // 전체 리로드가 필요한 페이지 목록
      const fullReloadPages = [
        '/',
        '/ranking',
        '/statistics',
        '/tier',
        // '/quna-chart', // 큐나 차트 임시 숨김
        '/compare',
        '/server-comparison'
      ];
      
      function shouldFullReload(url) {
        // 정확히 일치하거나 시작하는 경로 확인
        return fullReloadPages.some(page => {
          if (page === '/') {
            return url === '/' || url === '';
          }
          return url === page || url.startsWith(page + '/');
        });
      }
      
      // loadPage 함수 제거 - 애드센스와 충돌 방지를 위해 브라우저 기본 동작 사용
      // async function loadPage(url) {
      //   // 이 함수는 사용되지 않으며, 애드센스 전면 광고와 충돌을 일으킬 수 있어 제거됨
      // }
      
      // 뒤로가기/앞으로가기 처리 제거 - 브라우저가 자동으로 처리하도록 함
      // window.addEventListener('popstate', function(e) {
      //   // 애드센스와 충돌 방지를 위해 브라우저 기본 동작 사용
      // });
      
      // 이용 약관 버튼 이벤트
      // 탭 링크 클릭 시 SPA 방식으로 처리
      document.addEventListener('DOMContentLoaded', function() {
        // 모든 탭 링크에 SPA 라우터 적용
        const tabLinks = document.querySelectorAll('.tab-link');
        tabLinks.forEach(link => {
          // href에 #이 있으면 제거
          if (link.href && link.href.includes('#')) {
            const url = new URL(link.href);
            link.href = url.pathname;
          }
          
          link.addEventListener('click', function(e) {
            const url = this.getAttribute('href');
            
            // 1. 같은 페이지면 스크롤만 올리고 이벤트 중단 (새로고침 방지)
            if (url === window.location.pathname) {
              e.preventDefault();
              window.scrollTo({ top: 0, behavior: 'smooth' });
              return;
            }
            
            // 2. 외부 링크, 메일, 앵커(#) 등은 기본 동작 유지
            if (url.startsWith('http') || url.startsWith('mailto:') || url.startsWith('#')) {
              return;
            }
            
            // 3. 서브탭 링크는 예외 처리 (같은 페이지 내 탭 전환)
            // 서브탭 링크는 statistics-sub-tab-btn 클래스를 가지고 있음
            if (this.classList.contains('statistics-sub-tab-btn') || 
                this.classList.contains('internal-sub-tab') || 
                this.classList.contains('contents-sub-tab')) {
              // 서브탭은 페이지 이동이지만 같은 페이지 내 전환이므로 로딩 화면 표시하지 않음
              return;
            }
            
            // [핵심 수정 사항] 애드센스 전면 광고와 충돌 방지
            // 전체 리로드 페이지들('/', '/ranking' 등)은 자바스크립트로 개입하지 않습니다.
            // window.location.href = url; <--- 이 코드가 애드센스를 죽이는 범인입니다.
            // e.preventDefault()도 사용하지 않습니다.
            // 아무것도 하지 않고 함수를 종료하면, HTML <a> 태그의 기본 동작이 실행되며
            // 이때 애드센스가 정상적으로 끼어들어 전면광고를 보여줍니다.
            if (shouldFullReload(url)) {
              // 로딩바가 있다면 표시 (선택사항)
              // const loader = document.getElementById('fullscreen-loading-overlay');
              // if (loader) loader.style.display = 'flex';
              
              return; // JS는 빠지고 브라우저에게 맡김 (애드센스가 처리)
            }
            
            // 만약 SPA(Ajax)로 부분 로딩해야 하는 페이지가 있다면 여기에 작성
            // 현재 코드상으로는 모든 페이지가 Full Reload이므로 아래 로직은 실행될 일이 없음
            /*
            e.preventDefault();
            loadPage(url);
            */
          });
        });
        
        // index.html에서만 탭 활성화 함수 실행 (한 번만 실행)
        if (typeof activateTabByPath === 'function' && window.location.pathname !== '/tier' && /* window.location.pathname !== '/quna-chart' && */ window.location.pathname !== '/compare' && window.location.pathname !== '/server-comparison') {
          // 약간의 지연 후 실행 (DOM이 완전히 로드된 후)
          setTimeout(() => {
            activateTabByPath();
          }, 100);
        }
        
        const termsLink = document.getElementById('terms-link');
        const privacyLink = document.getElementById('privacy-link');
        const termsClose = document.getElementById('terms-close');
        const privacyClose = document.getElementById('privacy-close');
        const termsModal = document.getElementById('terms-modal');
        const privacyModal = document.getElementById('privacy-modal');

        if (termsLink) {
          termsLink.addEventListener('click', function() {
            openModal('terms-modal', 'terms-content', termsContent);
          });
        }

        if (privacyLink) {
          privacyLink.addEventListener('click', function() {
            openModal('privacy-modal', 'privacy-content', privacyContent);
          });
        }

        if (termsClose) {
          termsClose.addEventListener('click', function() {
            closeModal('terms-modal');
          });
        }

        if (privacyClose) {
          privacyClose.addEventListener('click', function() {
            closeModal('privacy-modal');
          });
        }

        // 모달 배경 클릭 시 닫기
        if (termsModal) {
          termsModal.addEventListener('click', function(e) {
            if (e.target === termsModal) {
              closeModal('terms-modal');
            }
          });
        }

        if (privacyModal) {
          privacyModal.addEventListener('click', function(e) {
            if (e.target === privacyModal) {
              closeModal('privacy-modal');
            }
          });
        }

        // ESC 키로 모달 닫기
        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape') {
            closeModal('terms-modal');
            closeModal('privacy-modal');
          }
        });
        
        // 뒤로가기/앞으로가기 시 로딩바 숨김 처리
        window.addEventListener('pageshow', function(event) {
          // bfcache(뒤로가기 캐시)로 왔거나 페이지가 로드되었을 때 로딩바 숨김
          const loader = document.getElementById('fullscreen-loading-overlay');
          if (loader) {
            loader.style.display = 'none';
          }
        });
      });
    </script>
    <!-- Naver Analytics -->
    <script type="text/javascript" src="//wcs.pstatic.net/wcslog.js"></script>
    <script type="text/javascript">
      if(!wcs_add) var wcs_add = {};
      wcs_add["wa"] = "16e465de98311c0";
      if(window.wcs) {
        wcs_do();
      }
    </script>
    
    
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "아툴",
  "alternateName": "AION2 TOOLS",
  "url": "https://aion2tool.com/",
  "description": "아이온2 캐릭터 검색, 전투력 랭킹, 통계, 티어 분석, 스펙 비교 등 아이온2 게임 정보를 한눈에 확인하는 사이트",
  "potentialAction": {
    "@type": "SearchAction",
    "target": {
      "@type": "EntryPoint",
      "urlTemplate": "https://aion2tool.com/?keyword={search_term_string}"
    },
    "query-input": "required name=search_term_string"
  }
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "아툴 - 아이온2 정보 검색·랭킹 사이트",
  "applicationCategory": "GameApplication",
  "operatingSystem": "Web",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "KRW"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "5",
    "ratingCount": "1"
  }
}
</script>

  <script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"f500368ac56a42bb834c53e9807d5e08","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>